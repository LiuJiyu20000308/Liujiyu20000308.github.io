<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2024-08-02T13:57:31+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Liujiyu’s blog</title><subtitle>learn &amp; record</subtitle><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><entry><title type="html">Leetcode记录：链表</title><link href="http://localhost:4000/2024/08/01/DS/" rel="alternate" type="text/html" title="Leetcode记录：链表" /><published>2024-08-01T14:00:00+08:00</published><updated>2024-08-01T14:00:00+08:00</updated><id>http://localhost:4000/2024/08/01/DS</id><content type="html" xml:base="http://localhost:4000/2024/08/01/DS/"><![CDATA[<h3 id="理解虚拟头结点">理解虚拟头结点</h3>

<p>考虑单链表删除某一结点的操作，在单链表中移除头结点和移除其他节点的操作方式是不一样的，需要单独写一段逻辑来处理移除头结点的情况。此时就要使用到虚拟头结点，可以保证逻辑的一致性：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ListNode</span><span class="o">*</span> <span class="nf">removeElements</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">dummyHead</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 设置一个虚拟头结点</span>
    <span class="n">dummyHead</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span> <span class="c1">// 将虚拟头结点指向head，这样方便后面做删除操作</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">dummyHead</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ListNode</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="k">delete</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">dummyHead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">dummyHead</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="设计链表">设计链表</h3>

<p>Leetcode 707.
在链表类中实现这些功能：</p>

<ol>
  <li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li>
  <li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li>
  <li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li>
  <li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li>
  <li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li>
</ol>

<p>可以发现，使用虚拟头结点之后可以减少逻辑判断.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyLinkedList</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// 定义链表节点结构体</span>
    <span class="k">struct</span> <span class="nc">LinkedNode</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
        <span class="n">LinkedNode</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
        <span class="n">LinkedNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span><span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">next</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">){}</span>
    <span class="p">};</span>

    <span class="c1">// 初始化链表</span>
    <span class="n">MyLinkedList</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">_dummyHead</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点</span>
        <span class="n">_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点</span>
    <span class="kt">int</span> <span class="n">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">LinkedNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">_dummyHead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">index</span><span class="o">--</span><span class="p">){</span> <span class="c1">// 如果--index 就会陷入死循环</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点</span>
    <span class="kt">void</span> <span class="n">addAtHead</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LinkedNode</span><span class="o">*</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedNode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
        <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">_dummyHead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">_dummyHead</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
        <span class="n">_size</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 在链表最后面添加一个节点</span>
    <span class="kt">void</span> <span class="n">addAtTail</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LinkedNode</span><span class="o">*</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedNode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
        <span class="n">LinkedNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">_dummyHead</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">){</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
        <span class="n">_size</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span>
    <span class="c1">// 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span>
    <span class="c1">// 如果index大于链表的长度，则返回空</span>
    <span class="c1">// 如果index小于0，则在头部插入节点</span>
    <span class="kt">void</span> <span class="n">addAtIndex</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>

        <span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">_size</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>        
        <span class="n">LinkedNode</span><span class="o">*</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedNode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
        <span class="n">LinkedNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">_dummyHead</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">index</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
        <span class="n">_size</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的</span>
    <span class="kt">void</span> <span class="n">deleteAtIndex</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">_size</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">LinkedNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">_dummyHead</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">index</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span> <span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">LinkedNode</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="c1">//delete命令指示释放了tmp指针原本所指的那部分内存，</span>
        <span class="c1">//被delete后的指针tmp的值（地址）并非就是NULL，而是随机值。也就是被delete后，</span>
        <span class="c1">//如果不再加上一句tmp=nullptr,tmp会成为乱指的野指针</span>
        <span class="c1">//如果之后的程序不小心使用了tmp，会指向难以预想的内存空间</span>
        <span class="n">tmp</span><span class="o">=</span><span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">_size</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 打印链表</span>
    <span class="kt">void</span> <span class="n">printLinkedList</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">LinkedNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">_dummyHead</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">_size</span><span class="p">;</span>
    <span class="n">LinkedNode</span><span class="o">*</span> <span class="n">_dummyHead</span><span class="p">;</span>

<span class="p">};</span>
</code></pre></div></div>

<h3 id="反转链表">反转链表</h3>

<p>Leetcode 206.
给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>

<p>双指针法：</p>
<div align="center"> <img src="/pic/DS/Leetcode206.gif" width="500" /> </div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ListNode</span><span class="o">*</span> <span class="nf">reverseList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">temp</span><span class="p">;</span> <span class="c1">// 保存cur的下一个节点</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">pre</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>  <span class="c1">// 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next</span>
        <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">pre</span><span class="p">;</span> <span class="c1">// 翻转操作</span>
        <span class="c1">// 更新pre 和 cur指针</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">pre</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>递归法：让cur指向pre，然后再将cur与cur-&gt;next进行调换。本质上和双指针法相同。</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ListNode</span><span class="o">*</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">pre</span><span class="p">,</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">cur</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">cur</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">pre</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">pre</span><span class="p">;</span>
    <span class="c1">// 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步</span>
    <span class="c1">// pre = cur;</span>
    <span class="c1">// cur = temp;</span>
    <span class="k">return</span> <span class="n">reverse</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span><span class="n">temp</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">ListNode</span><span class="o">*</span> <span class="n">reverseList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 和双指针法初始化是一样的逻辑</span>
    <span class="c1">// ListNode* cur = head;</span>
    <span class="c1">// ListNode* pre = NULL;</span>
    <span class="k">return</span> <span class="n">reverse</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="数据结构与算法" /><summary type="html"><![CDATA[理解虚拟头结点]]></summary></entry><entry><title type="html">Leetcode记录：模拟过程</title><link href="http://localhost:4000/2024/07/31/DS-2/" rel="alternate" type="text/html" title="Leetcode记录：模拟过程" /><published>2024-07-31T14:00:00+08:00</published><updated>2024-07-31T14:00:00+08:00</updated><id>http://localhost:4000/2024/07/31/DS-2</id><content type="html" xml:base="http://localhost:4000/2024/07/31/DS-2/"><![CDATA[<h3 id="螺旋矩阵">螺旋矩阵</h3>

<p>给你一个正整数 <code class="language-plaintext highlighter-rouge">n</code> ，生成一个包含 <code class="language-plaintext highlighter-rouge">1</code> 到 <code class="language-plaintext highlighter-rouge">n^2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code class="language-plaintext highlighter-rouge">n x n</code> 正方形矩阵 <code class="language-plaintext highlighter-rouge">matrix</code> 。</p>

<p>模拟顺时针画矩阵的过程:</p>
<ol>
  <li>填充上行从左到右</li>
  <li>填充右列从上到下</li>
  <li>填充下行从右到左</li>
  <li>填充左列从下到上</li>
  <li>由外向内一圈一圈这么画下去。</li>
</ol>

<p>可以发现这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，会有很多bug，因此求解本题依然是要坚持循环不变量原则：例如左闭右开，代码如下：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">generateMatrix</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span> <span class="c1">// 使用vector定义一个二维数组</span>
    <span class="kt">int</span> <span class="n">startx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">starty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 定义每循环一个圈的起始位置</span>
    <span class="kt">int</span> <span class="n">loop</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 用来给矩阵中每一个空格赋值</span>
    <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">loop</span> <span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">startx</span><span class="p">;</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">starty</span><span class="p">;</span>

        <span class="c1">// 下面开始的四个for就是模拟转了一圈</span>
        <span class="c1">// 模拟填充上行从左到右(左闭右开)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 模拟填充右列从上到下(左闭右开)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 模拟填充下行从右到左(左闭右开)</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">starty</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 模拟填充左列从下到上(左闭右开)</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">startx</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span>
        <span class="n">startx</span><span class="o">++</span><span class="p">;</span>
        <span class="n">starty</span><span class="o">++</span><span class="p">;</span>

        <span class="c1">// offset 控制每一圈里每一条边遍历的长度</span>
        <span class="n">offset</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">res</span><span class="p">[</span><span class="n">mid</span><span class="p">][</span><span class="n">mid</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>也可以实时更新上下左右四个边界来判断：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">generateMatrix</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="n">ret</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">right</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span><span class="n">top</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">bottom</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">num</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">top</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="o">++</span><span class="n">top</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">top</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">bottom</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="o">--</span><span class="n">right</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">bottom</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">left</span><span class="p">;</span><span class="n">j</span><span class="o">--</span><span class="p">){</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="o">--</span><span class="n">bottom</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">bottom</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">top</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">){</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="o">++</span><span class="n">left</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="数据结构与算法" /><summary type="html"><![CDATA[螺旋矩阵]]></summary></entry><entry><title type="html">Leetcode记录：滑动窗口和前缀和</title><link href="http://localhost:4000/2024/07/31/DS/" rel="alternate" type="text/html" title="Leetcode记录：滑动窗口和前缀和" /><published>2024-07-31T14:00:00+08:00</published><updated>2024-07-31T14:00:00+08:00</updated><id>http://localhost:4000/2024/07/31/DS</id><content type="html" xml:base="http://localhost:4000/2024/07/31/DS/"><![CDATA[<h2 id="滑动窗口">滑动窗口</h2>
<p>滑动窗口算法的基本思想是维护一个窗口，通过移动窗口的两个边界来处理问题。</p>

<p>具体来说，我们可以使用两个指针 <code class="language-plaintext highlighter-rouge">left</code> 和 <code class="language-plaintext highlighter-rouge">right</code> 分别表示滑动窗口的左右边界，然后通过不断移动右指针 <code class="language-plaintext highlighter-rouge">right</code> 来扩大窗口，同时根据问题的要求调整左指针 <code class="language-plaintext highlighter-rouge">left</code> 来缩小窗口。当右指针 <code class="language-plaintext highlighter-rouge">right</code> 扫描到字符串或数组的末尾时，算法的执行就完成了。</p>

<p>在扩大或缩小窗口的过程中，可以记录下一些中间结果，例如最大值、最小值、子串长度等等，从而求解问题的最终答案。</p>

<h3 id="适用问题">适用问题</h3>

<p>滑动窗口算法可以用于解决一些字符串和数组问题，例如：</p>
<ol>
  <li>字符串匹配问题，例如 Leetcode 第 28 题和第 76 题；</li>
  <li>最长子串或子数组问题，例如 Leetcode 第 3 题、第 209 题和第 424 题；</li>
  <li>最小覆盖子串问题，例如 Leetcode 第 76 题；</li>
  <li>字符串排列问题，例如 Leetcode 第 567 题；</li>
  <li>求解字符串或数组中的一些性质，例如 Leetcode 第 438 题、第 567 题和第 1004 题等。</li>
</ol>

<h3 id="实现方法">实现方法</h3>
<p>滑动窗口算法的实现方法相对简单，主要分为以下几个步骤：</p>
<ol>
  <li>初始化左右指针 $left$ 和 $right$，并根据问题的要求进行一些初始化操作。</li>
  <li>不断移动右指针 $right$，直到出现不符合条件的情况，或者扫描到字符串或数组的末尾。</li>
  <li>对于每个右指针位置 $i$，更新一些中间结果。</li>
  <li>移动左指针 $left$，直到出现符合条件的情况，或者左右指针重合。</li>
  <li>重复第 2 步至第 4 步，直到右指针扫描到字符串或数组的末尾。</li>
</ol>

<h4 id="示例1">示例1</h4>
<p>Leetcode 206.【长度最小的子数组】
给定一个含有 <code class="language-plaintext highlighter-rouge">n</code> 个正整数的数组和一个正整数 <code class="language-plaintext highlighter-rouge">target</code> 。找出该数组中满足其总和大于等于 <code class="language-plaintext highlighter-rouge">target</code> 的长度最小的 子数组<code class="language-plaintext highlighter-rouge">[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>

<p>这道题之所以可以使用滑动窗口，很重要的一个原因是，<strong>在移动终止位置的时候，初始位置是不可逆的，初始位置只可能往后移动，而不用每次都从第零个元素开始。</strong> 代码实现如下：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">minSubArrayLen</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">INT32_MAX</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 滑动窗口数值之和</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 滑动窗口起始位置</span>
        <span class="kt">int</span> <span class="n">subLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 滑动窗口的长度</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="c1">// 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">subLength</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 取子序列的长度</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="n">subLength</span> <span class="o">?</span> <span class="n">result</span> <span class="o">:</span> <span class="n">subLength</span><span class="p">;</span>
                <span class="n">sum</span> <span class="o">-=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span> <span class="c1">// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span>
        <span class="k">return</span> <span class="n">result</span> <span class="o">==</span> <span class="n">INT32_MAX</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<h4 id="示例2">示例2</h4>

<p>Leetcode 3.【无重复最长子串】
给定一个字符串 <code class="language-plaintext highlighter-rouge">s</code> ，请你找出其中不含有重复字符的最长子串的长度。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">;</span><span class="c1">//记录字符上一次出现的位置,字符为key，位置为value</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span><span class="c1">//i表示子串的起始位置，j表示子串的结束位置</span>
        <span class="k">if</span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">!=</span> <span class="n">map</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span><span class="c1">//如果字符上一次出现的位置在i之后，更新i</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span> <span class="n">i</span><span class="p">);</span><span class="c1">//map[s[j]]表示字符s[j]上一次出现的位置</span>
        <span class="p">}</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span><span class="c1">//更新结果</span>
        <span class="n">map</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>		<span class="c1">//更新字符s[j]上一次出现的位置</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="示例3">示例3</h4>
<p>Leetcode 1004.【最大连续1的个数】</p>

<p>给定一个二进制数组 <code class="language-plaintext highlighter-rouge">nums</code> 和一个整数 <code class="language-plaintext highlighter-rouge">k</code>，如果可以翻转最多 <code class="language-plaintext highlighter-rouge">k</code> 个<code class="language-plaintext highlighter-rouge">0</code> ，则返回数组中连续 <code class="language-plaintext highlighter-rouge">1</code> 的最大个数。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">longestOnes</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lsum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rsum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rsum</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">];</span> <span class="c1">//[0，right]中0的个数.</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">lsum</span> <span class="o">&lt;</span> <span class="n">rsum</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">lsum</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
            <span class="o">++</span><span class="n">left</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>该问题也可以用前缀和思路来考虑：要想快速判断一个区间内 <code class="language-plaintext highlighter-rouge">0</code> 的个数，我们可以考虑将数组中的 <code class="language-plaintext highlighter-rouge">0</code> 变成 <code class="language-plaintext highlighter-rouge">1</code>，<code class="language-plaintext highlighter-rouge">1</code> 变成 <code class="language-plaintext highlighter-rouge">0</code>。此时，我们对数组 A 求出前缀和，记为数组 <code class="language-plaintext highlighter-rouge">P</code>，那么 <code class="language-plaintext highlighter-rouge">[left,right]</code> 中包含不超过 <code class="language-plaintext highlighter-rouge">k</code> 个 <code class="language-plaintext highlighter-rouge">1</code>（注意这里就不是 <code class="language-plaintext highlighter-rouge">0</code> 了），当且仅当二者的前缀和之差：<code class="language-plaintext highlighter-rouge">P[right]−P[left−1]&lt;=k</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">longestOnes</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">P</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">P</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">P</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">P</span><span class="p">[</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="n">P</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>其中 <code class="language-plaintext highlighter-rouge">lower_bound</code> 用于在有序序列中查找第一个大于或等于给定值的元素的位置（迭代器）。</p>

<h4 id="示例4-等二刷用优化再做一遍">示例4 等二刷用优化再做一遍</h4>
<p>Leetcode 76.【最小覆盖子串】
给你一个字符串 <code class="language-plaintext highlighter-rouge">s</code> 、一个字符串 <code class="language-plaintext highlighter-rouge">t</code> 。返回 <code class="language-plaintext highlighter-rouge">s</code> 中涵盖 <code class="language-plaintext highlighter-rouge">t</code> 所有字符的最小子串。如果 <code class="language-plaintext highlighter-rouge">s</code> 中不存在涵盖 <code class="language-plaintext highlighter-rouge">t</code> 所有字符的子串，则返回空字符串 <code class="language-plaintext highlighter-rouge">""</code> 。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ori</span><span class="p">,</span> <span class="n">cnt</span><span class="p">;</span>
    
<span class="kt">bool</span> <span class="nf">check</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">p</span> <span class="o">:</span> <span class="n">ori</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">string</span> <span class="n">minWindow</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">string</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span> <span class="n">c</span> <span class="o">:</span> <span class="n">t</span><span class="p">){</span>
        <span class="n">ori</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="n">ansLeft</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ori</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">++</span><span class="n">right</span><span class="p">])</span> <span class="o">!=</span> <span class="n">ori</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">cnt</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">check</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">&lt;=</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">){</span>
                <span class="n">ansLeft</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
                <span class="n">length</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ori</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">])</span><span class="o">!=</span> <span class="n">ori</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">cnt</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]]</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">left</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">right</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">length</span> <span class="o">==</span> <span class="n">INT_MAX</span> <span class="o">?</span> <span class="s">""</span> <span class="o">:</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">ansLeft</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>注意更新右端窗口及cnt的时候先移动左端窗口，更新length，最后再right++.</p>

<p><strong>优化算法：</strong> 用一个变量 less 维护目前子串中有 less 种字母的出现次数小于 t 中字母的出现次数。具体来说（注意下面算法中的 less 变量）：</p>

<ol>
  <li>初始化 ansLeft=−1, ansRight=m，用来记录最短子串的左右端点，其中 m 是 s 的长度。</li>
  <li>用一个哈希表（或者数组）cntT 统计 t 中每个字母的出现次数。</li>
  <li>初始化 left=0，以及一个空哈希表（或者数组）cntS，用来统计 s 子串中每个字母的出现次数。</li>
  <li>初始化 less 为 t 中的不同字母个数。</li>
  <li>遍历 s，设当前枚举的子串右端点为 right，把字母 c=s[right] 的出现次数加一。加一后，如果 cntS[c]=cntT[c]，说明 c 的出现次数满足要求，把 less 减一。</li>
  <li>如果 less=0，说明 cntS 中的每个字母及其出现次数都大于等于 cntT 中的字母出现次数，那么： 如果 right−left &lt; ansRight−ansLeft，说明我们找到了更短的子串，更新 ansLeft=left, ansRight=right。</li>
  <li>把字母 x=s[left] 的出现次数减一。减一前，如果 cntS[x]=cntT[x]，说明 x 的出现次数不满足要求，把 less 加一。</li>
  <li>左端点右移，即 left 加一。</li>
  <li>重复上述三步，直到 less&gt;0，即 cntS 有字母的出现次数小于 cntT 中该字母的出现次数为止。</li>
  <li>最后，如果 ansLeft&lt;0，说明没有找到符合要求的子串，返回空字符串，否则返回下标 ansLeft 到下标 ansRight 之间的子串。</li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="nf">minWindow</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">string</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">ans_left</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ans_right</span> <span class="o">=</span> <span class="n">m</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">less</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">cnt_s</span><span class="p">[</span><span class="mi">128</span><span class="p">]{},</span> <span class="n">cnt_t</span><span class="p">[</span><span class="mi">128</span><span class="p">]{};</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">less</span> <span class="o">+=</span> <span class="n">cnt_t</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 有 less 种字母的出现次数 &lt; t 中的字母出现次数</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">right</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 移动子串右端点</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">];</span> <span class="c1">// 右端点字母（移入子串）</span>
            <span class="n">less</span> <span class="o">-=</span> <span class="o">++</span><span class="n">cnt_s</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="n">cnt_t</span><span class="p">[</span><span class="n">c</span><span class="p">];</span> <span class="c1">// c 的出现次数从 &lt; 变成 &gt;=</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">less</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 涵盖：所有字母的出现次数都是 &gt;=</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">ans_right</span> <span class="o">-</span> <span class="n">ans_left</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 找到更短的子串</span>
                    <span class="n">ans_left</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span> <span class="c1">// 记录此时的左右端点</span>
                    <span class="n">ans_right</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="kt">char</span> <span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="o">++</span><span class="p">];</span> <span class="c1">// 左端点字母（移出子串）</span>
                <span class="n">less</span> <span class="o">+=</span> <span class="n">cnt_s</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span> <span class="o">==</span> <span class="n">cnt_t</span><span class="p">[</span><span class="n">x</span><span class="p">];</span> <span class="c1">// x 的出现次数从 &gt;= 变成 &lt;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ans_left</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">""</span> <span class="o">:</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">ans_left</span><span class="p">,</span> <span class="n">ans_right</span> <span class="o">-</span> <span class="n">ans_left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>
<h4 id="示例5">示例5</h4>
<p>Leetcode 904.【水果成篮】
实质上就是找最多包含$k$个元素的连续最长子数组。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">totalFruit</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">fruits</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fruits</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">cnt</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">++</span><span class="n">cnt</span><span class="p">[</span><span class="n">fruits</span><span class="p">[</span><span class="n">right</span><span class="p">]];</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">cnt</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">fruits</span><span class="p">[</span><span class="n">left</span><span class="p">]);</span>
                <span class="o">--</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">cnt</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="o">++</span><span class="n">left</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p><strong>可以发现，滑动窗口和最大最小子数组或字符串问题关系密切，更新左窗口和更新length的先后顺序与最大还是最小问题相关</strong></p>

<h2 id="前缀和">前缀和</h2>

<p>前缀和算法（Prefix Sum）是一种用于快速计算数组元素之和的技术。它通过预先计算数组中每个位置前所有元素的累加和，将这些部分和存储在一个新的数组中，从而在需要计算某个区间的和时，可以通过简单的减法操作得到结果，而不必重新遍历整个区间。</p>

<p>一维前缀和：给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">presum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">presum</span> <span class="o">+=</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">presum</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">sum</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">b</span><span class="p">];</span>
        <span class="k">else</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>二维前缀和：给你一个n行m列的矩阵A ，<strong>下标从1开始。</strong> 请输出以 (x1, y1) 为左上角 , (x2,y2) 为右下角的子矩阵的和。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">arr</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
 
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> <span class="c1">//注意这一步.</span>
 
    <span class="kt">int</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x1</span> <span class="o">&gt;&gt;</span> <span class="n">y1</span> <span class="o">&gt;&gt;</span> <span class="n">x2</span> <span class="o">&gt;&gt;</span> <span class="n">y2</span><span class="p">;)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">x2</span><span class="p">][</span><span class="n">y2</span><span class="p">]</span> <span class="o">-</span> <span class="n">dp</span><span class="p">[</span><span class="n">x1</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">y2</span><span class="p">]</span> <span class="o">-</span> <span class="n">dp</span><span class="p">[</span><span class="n">x2</span><span class="p">][</span><span class="n">y1</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">x1</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">y1</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div align="center"> <img src="/pic/DS/2DPrefix_Sum.png" width="800" /> </div>

<h4 id="示例1-1">示例1</h4>

<p>Leetcode 238.【除自身以外数组的乘积】
给你一个整数数组 <code class="language-plaintext highlighter-rouge">nums</code>，返回 数组 <code class="language-plaintext highlighter-rouge">answer</code> ，其中 <code class="language-plaintext highlighter-rouge">answer[i]</code> 等于 <code class="language-plaintext highlighter-rouge">nums</code> 中除 <code class="language-plaintext highlighter-rouge">nums[i]</code> 之外其余各元素的乘积。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">productExceptSelf</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">answer</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>

    <span class="c1">// answer[i] 表示索引 i 左侧所有元素的乘积</span>
    <span class="c1">// 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1</span>
    <span class="n">answer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">answer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">answer</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// R 为右侧所有元素的乘积</span>
    <span class="c1">// 刚开始右边没有元素，所以 R = 1</span>
    <span class="kt">int</span> <span class="n">R</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span>
        <span class="n">answer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">answer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">R</span><span class="p">;</span>
        <span class="c1">// R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span>
        <span class="n">R</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="示例2-1">示例2</h4>
<p>Leetcode 560.【和为k的子数组】
给你一个整数数组 <code class="language-plaintext highlighter-rouge">nums</code> 和一个整数 <code class="language-plaintext highlighter-rouge">k</code> ，请你统计并返回该数组中和为 <code class="language-plaintext highlighter-rouge">k</code> 的子数组的个数。</p>

<p>由于数组可能存在负数，我们无法使用滑动窗口来求解该问题。我们可以存储所有的前缀和出现的次数，遍历的时候寻找 <code class="language-plaintext highlighter-rouge">pre-k</code> 的个数即可。</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">subarraySum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">mp</span><span class="p">;</span>
        <span class="n">mp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//注意！</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pre</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="o">:</span><span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pre</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">pre</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">!=</span> <span class="n">mp</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="n">mp</span><span class="p">[</span><span class="n">pre</span> <span class="o">-</span> <span class="n">k</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="n">mp</span><span class="p">[</span><span class="n">pre</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<h4 id="示例3-1">示例3</h4>
<p>Leetcode 974. 【和可被K整除的子数组】
给定一个整数数组 <code class="language-plaintext highlighter-rouge">nums</code> 和一个整数 <code class="language-plaintext highlighter-rouge">k</code>，返回其中元素之和可被 <code class="language-plaintext highlighter-rouge">k</code> 整除的非空子数组的数目。</p>

<p>由于负数的存在，这里我们存储的是 <code class="language-plaintext highlighter-rouge">(pre % k + k) % k</code>的个数，</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">subarraysDivByK</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">hash</span><span class="p">;</span>
    <span class="n">hash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">e</span> <span class="o">:</span> <span class="n">nums</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">e</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">mod</span> <span class="o">=</span> <span class="p">(</span><span class="n">sum</span> <span class="o">%</span> <span class="n">k</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span> <span class="o">%</span> <span class="n">k</span><span class="p">;</span> <span class="c1">//这里考虑有负数的情况</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hash</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">mod</span><span class="p">))</span> <span class="n">ret</span> <span class="o">+=</span> <span class="n">hash</span><span class="p">[</span><span class="n">mod</span><span class="p">];</span>
        <span class="n">hash</span><span class="p">[</span><span class="n">mod</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="示例4">示例4</h4>
<p>Leetcode 525.【连续数组】
给定一个二进制数组 <code class="language-plaintext highlighter-rouge">nums</code> , 找到含有相同数量的 <code class="language-plaintext highlighter-rouge">0</code> 和 <code class="language-plaintext highlighter-rouge">1</code> 的最长连续子数组，并返回该子数组的长度。</p>

<p>这里的技巧是将0替换为-1，这样只需求和为0的最长连续子数组。
我们要想知道区间长度，就需要知道i和j，因此我们向哈希表中存入的value为当前前缀和的下标。此外，如果我们再次遇到一个值为sum的下标，由于这里求得是最长区间，所以我们不需要更新hash[sum]。而如果整个区间的长度都为0，那么我们就需要在前缀和为0的情况下，找到一个下标为-1的地方来统计整个数组长度。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">findMaxLength</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">e</span> <span class="o">:</span> <span class="n">nums</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">e</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">hash</span><span class="p">;</span>
    <span class="n">hash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hash</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">sum</span><span class="p">))</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">hash</span><span class="p">[</span><span class="n">sum</span><span class="p">]);</span>
        <span class="k">else</span> <span class="n">hash</span><span class="p">[</span><span class="n">sum</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="数据结构与算法" /><summary type="html"><![CDATA[滑动窗口 滑动窗口算法的基本思想是维护一个窗口，通过移动窗口的两个边界来处理问题。]]></summary></entry><entry><title type="html">Leetcode记录：二分查找和双指针法</title><link href="http://localhost:4000/2024/07/30/DS/" rel="alternate" type="text/html" title="Leetcode记录：二分查找和双指针法" /><published>2024-07-30T02:00:00+08:00</published><updated>2024-07-30T02:00:00+08:00</updated><id>http://localhost:4000/2024/07/30/DS</id><content type="html" xml:base="http://localhost:4000/2024/07/30/DS/"><![CDATA[<h2 id="二分查找">二分查找</h2>

<p>二分查找的前提为有序数组，同时要关注数组是否存在重复元素。</p>

<p>二分查找的框架为</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">binarySearch</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="p">...;</span>

    <span class="k">while</span><span class="p">(...)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">...</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">left</span> <span class="o">=</span> <span class="p">...</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">right</span> <span class="o">=</span> <span class="p">...</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">...;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。另外，计算 mid 时需要技巧防止溢出。</p>

<h3 id="基本的二分查找">基本的二分查找</h3>

<p>省略号的部分可以分为两种写法：左闭右闭和左闭右开，可以画图来进行分析，此处略过</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">search</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 定义target在左闭右闭的区间里，[left, right]</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span>
            <span class="kt">int</span> <span class="n">midd</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">((</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span><span class="c1">// 防止溢出 等同于(left + right)/2</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// target 在左区间，所以[left, middle - 1]</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// target 在右区间，所以[middle + 1, right]</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// nums[middle] == target</span>
                <span class="k">return</span> <span class="n">mid</span><span class="p">;</span> <span class="c1">// 数组中找到目标值，直接返回下标</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 未找到目标值</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="c1">// Another version:</span>
<span class="kt">int</span> <span class="n">search</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="c1">// 定义target在左闭右开的区间里，即：[left, right)</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span>
            <span class="kt">int</span> <span class="n">middle</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">((</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">middle</span><span class="p">;</span> <span class="c1">// target 在左区间，在[left, middle)中</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// target 在右区间，在[middle + 1, right)中</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// nums[middle] == target</span>
                <span class="k">return</span> <span class="n">middle</span><span class="p">;</span> <span class="c1">// 数组中找到目标值，直接返回下标</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 未找到目标值</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>但是如果给定有序数组 <code class="language-plaintext highlighter-rouge">nums = [1,2,2,2,3]，target = 2</code>，此算法返回的索引是 <code class="language-plaintext highlighter-rouge">2</code>，但是如果我想得到 <code class="language-plaintext highlighter-rouge">target</code> 的左侧边界，即索引 <code class="language-plaintext highlighter-rouge">1</code>，或者我想得到 <code class="language-plaintext highlighter-rouge">target</code> 的右侧边界，即索引 <code class="language-plaintext highlighter-rouge">3</code>，这样的话此算法是无法处理的。</p>

<h3 id="寻找左右侧边界的二分搜索">寻找左右侧边界的二分搜索</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">left_bound</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 注意</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 注意</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 注意</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// target 比所有数都大</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span> <span class="o">?</span> <span class="n">left</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">right_bound</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 注意</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span> <span class="o">?</span> <span class="n">right</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 注意</span>
<span class="p">}</span>
</code></pre></div></div>

<p>也可以统一写为一个函数</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">binarySearch</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">left_bound</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span> <span class="o">||</span> <span class="p">(</span><span class="n">lower</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">target</span><span class="p">)){</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">left</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">searchRange</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">leftIdx</span> <span class="o">=</span> <span class="n">binarySearch</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">rightIdx</span> <span class="o">=</span> <span class="n">binarySearch</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">leftIdx</span> <span class="o">&lt;=</span> <span class="n">rightIdx</span> <span class="o">&amp;&amp;</span> <span class="n">rightIdx</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
        <span class="n">nums</span><span class="p">[</span><span class="n">leftIdx</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">rightIdx</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="n">leftIdx</span><span class="p">,</span> <span class="n">rightIdx</span><span class="p">};</span>
    <span class="p">}</span> 
    <span class="k">return</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对应题目：</p>
<ol>
  <li><strong>704.二分查找</strong></li>
  <li><strong>35.搜索插入位置</strong></li>
  <li><strong>34.在排序数组中查找元素的第一个和最后一个位置</strong></li>
</ol>

<h2 id="双指针法">双指针法</h2>

<p>双指针是指在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个指针进行遍历，从而达到相应的目的。</p>

<p>最常见的双指针算法有两种：</p>
<ol>
  <li>在同一个序列中，用两个指针维护两个位置，或两个位置包含的区间；</li>
  <li>在两个序列里边，两个指针指向不同的序列，来维护某种次序。</li>
</ol>

<p>按照指针的移动方向，双指针分为同向双指针、异向双指针：</p>
<ol>
  <li>同向双指针，也称快慢指针（两个指针一快一慢）；</li>
  <li>异向双指针，分为对撞指针（从两边向中间移动）、背向指针（从中间向两边移动）。</li>
</ol>

<h3 id="快慢指针">快慢指针</h3>

<p>两个指针，初始在同一位置，然后向相同方向移动，一个移动速度快，一个移动速度慢。</p>

<p>适用场景：<strong>查找链表中间节点、链表是否包含环、原地修改数组。</strong></p>

<h4 id="示例1">示例1</h4>
<p>LeetCode 876.【链表的中间结点】</p>

<p>给你单链表的头结点 head ，请你找出并返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。如下图所示，链表有 5 个节点，返回第 3 个节点；链表有 6 个节点，返回第 4 个节点。</p>

<div align="center"> <img src="/pic/DS/Leetcode876.png" width="400" /> </div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ListNode</span> <span class="nf">middleNode</span><span class="p">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ListNode</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="n">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="p">.</span><span class="n">next</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">slow</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="示例2">示例2</h4>
<p>LeetCode 26.【删除有序数组中的重复项】
给你一个非严格递增排列的数组 <code class="language-plaintext highlighter-rouge">nums</code> ，请你原地删除重复出现的元素，使每个元素只出现一次 ，返回删除后数组的新长度。元素的相对顺序应该保持 一致 。然后返回 <code class="language-plaintext highlighter-rouge">nums</code> 中唯一元素的个数。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">removeElement</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">slowIndex</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">fastIndex</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">fastIndex</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">fastIndex</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">val</span><span class="o">!=</span><span class="n">nums</span><span class="p">[</span><span class="n">fastIndex</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="n">nums</span><span class="p">[</span><span class="n">slowIndex</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">nums</span><span class="p">[</span><span class="n">fastIndex</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">slowIndex</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="对撞指针">对撞指针</h3>
<p>两个指针，初始一个在左、一个在右，左指针向右移动，右指针向左移动，直到相撞停止。</p>

<p>适用场景：<strong>二分查找、反转数组、回文判定。</strong></p>
<h4 id="示例1-1">示例1</h4>
<p>LeetCode 977.【有序数组的平方】
给你一个按<strong>非递减顺序</strong>排序的整数数组 <code class="language-plaintext highlighter-rouge">nums</code>，返回每个数字的平方组成的新数组，要求也按<strong>非递减顺序</strong>排序。</p>

<p>由于数组平方的<strong>最大值就在数组的两端</strong>，不是最左边就是最右边，不可能是中间，此时可以考虑双指针法了</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sortedSquares</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;)</span> <span class="p">{</span> <span class="c1">// 注意这里要i &lt;= j，因为最后要处理两个元素</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>  <span class="p">{</span>
                <span class="n">result</span><span class="p">[</span><span class="n">k</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="n">j</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">result</span><span class="p">[</span><span class="n">k</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">i</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<div align="center"> <img src="/pic/DS/Leetcode977.gif" width="400" /> </div>

<h4 id="示例2-1">示例2</h4>
<p>LeetCode 344.【反转字符串】</p>

<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code class="language-plaintext highlighter-rouge">s</code> 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 <code class="language-plaintext highlighter-rouge">O(1)</code> 的额外空间解决这一问题。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">reverseString</span><span class="p">(</span><span class="kt">char</span><span class="p">[]</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
        <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
        <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="n">left</span><span class="o">++</span><span class="p">;</span>
        <span class="n">right</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="背向指针">背向指针</h3>
<p>两个指针，初始都在中间，左指针向左移动，右指针向右移动，直至碰到最左或最右边界。</p>

<p>使用场景：<strong>查找字符串中的最长回文子串。</strong></p>

<h4 id="示例1-2">示例1</h4>
<p>LeetCode 5.最长回文子串</p>

<p>给你一个字符串 <code class="language-plaintext highlighter-rouge">s</code>，找到 <code class="language-plaintext highlighter-rouge">s</code> 中最长的回文子串。如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>

<p>在给定字符串中找回文子串的难点在于，<strong>回文子串的的长度可能是奇数也可能是偶数</strong>，如果回文串的长度为奇数，则它有一个中心字符，例如<code class="language-plaintext highlighter-rouge">bacab</code>；如果回文串的长度为偶数，则可以认为它有两个中心字符，例如<code class="language-plaintext highlighter-rouge">baab</code>。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="nf">expandCenter</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="c1">// 要时刻注意避免越界访问</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">len</span>
           <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">left</span><span class="o">--</span><span class="p">;</span>
        <span class="n">right</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">string</span> <span class="n">longestPalindrome</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="n">string</span> <span class="n">res</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">sub1</span> <span class="o">=</span> <span class="n">expandCenter</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">string</span> <span class="n">sub2</span> <span class="o">=</span> <span class="n">expandCenter</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">sub1</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">?</span> <span class="n">res</span> <span class="o">:</span> <span class="n">sub1</span><span class="p">;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">sub2</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">?</span> <span class="n">res</span> <span class="o">:</span> <span class="n">sub2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="数据结构与算法" /><summary type="html"><![CDATA[二分查找]]></summary></entry><entry><title type="html">CSAPP-2-3:程序的机器级运行过程</title><link href="http://localhost:4000/2024/01/02/CSAPP-2-3/" rel="alternate" type="text/html" title="CSAPP-2-3:程序的机器级运行过程" /><published>2024-01-02T16:23:00+08:00</published><updated>2024-01-02T16:23:00+08:00</updated><id>http://localhost:4000/2024/01/02/CSAPP-2-3</id><content type="html" xml:base="http://localhost:4000/2024/01/02/CSAPP-2-3/"><![CDATA[<h1 id="程序的机器级表示">程序的机器级表示</h1>

<h2 id="过程">过程</h2>

<p>过程提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能，然后可以在程序不同的地方调用这个函数。
过程的形式多样：函数（function），方法（method），子例程（subroutine），处理函数（handler）等等。</p>

<p>要提供对过程的机器级支持，必须要处理许多不同的属性。假设过程P调用过程Q，Q执行后返回到P，这些动作包括下面一个或多个机制：</p>
<ol>
  <li><strong>传递控制</strong>：在进入过程Q时，程序计数器必须被设置为Q的代码的起始地址。在返回时，要把程序计数器设置为P中调用Q后的指令的地址。</li>
  <li><strong>传递数据</strong>：P必须能够向Q提供一个或多个参数，Q必须能够向P返回一个值。</li>
  <li><strong>分配和释放内存</strong>：在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些空间。</li>
</ol>

<h3 id="过程时栈">过程时栈</h3>

<p>栈提供了后进先出的内存管理原则。在过程P调用Q的例子中，当Q在执行时，P以及所有向上追溯到P的调用链中的过程都是暂时被挂起的。当Q运行时，它只需要为局部变量分配新的存储空间或者设置到另一个过程的调用。另一方面，当Q返回时，任何它所分配的局部存储空间都可以被释放。因此，程序可以用栈来管理它的过程所需要的存储空间。</p>

<div align="center"> <img src="/pic/CSAPP/Stack.png" width="400" /> </div>

<p>x86-64的栈向低地址方向增长，%rsp指向栈顶元素，将栈指针减小一个适当的量可以为没有指定初始值的数据在栈上分配空间，类似的可以通过增加栈指针来释放空间。</p>

<p>当x86-64过程需要的存储空间超过寄存器能存放的大小时，就会在栈上分配空间，这个部分称为过程的<strong>栈帧(stack frame)。</strong>上图中，当P调用Q时，会把返回地址压入栈中，<strong>指明当Q返回时要从程序的哪个位置继续执行</strong>，我们把这个返回地址当做P的栈帧的一部分，因为这是和P相关的状态。</p>

<p>Q的代码会扩展当前栈的边界，分配它的栈帧所需的空间，在这个空间中可以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。大多数栈帧都是定长的，但有些过程需要变长的栈帧（<strong>后面会讲</strong>），<strong>通过寄存器，过程P最多可以传递6个人整数值（指针和整数），如果需要更多参数，P可以在调用Q之前在自己的栈帧中存储好这些参数。</strong></p>

<h3 id="转移控制">转移控制</h3>

<p>将控制从P转移到Q只需要简单地把程序计数器（PC）设置为Q的代码起始位置。不过，当稍后从Q返回时，处理器必须记录好它需要继续P的执行的代码的位置。这个信息是用<strong>指令call Q</strong>调用过程Q来记录的。该指令会把地址A压入栈中，并将PC设置为Q的起始地址。压入的地址A称为<strong>返回地址</strong>，是紧跟call后面的那条指令的地址。对应的指令<strong>ret</strong>会从栈中弹出A并把PC设置为A。</p>

<div align="center"> <img src="/pic/CSAPP/call&amp;ret.png" width="400" /> </div>

<p>下面是一个例子：</p>

<div align="center"> <img src="/pic/CSAPP/call1.png" width="500" /> </div>
<div align="center"> <img src="/pic/CSAPP/call2.png" width="500" /> </div>

<h3 id="数据传送">数据传送</h3>

<p>x86-64中可以通过寄存器最多传递6个整型参数。寄存器使用是有特殊顺序的并且寄存器使用的名字取决于要传递的数据类型的大小。</p>

<p>如果一个函数有大于6个整型参数，超过的部分需要用栈来传递。假设P调用Q有n个整型参数且n大于6，则P的栈帧必须要容纳7~n号参数的存储空间并且参数7位于栈顶。 <strong>通过栈传递参数时，所有的数据大小都向8的倍数对齐。</strong>参数到位之后就可以调用call指令了。</p>

<p>下面是参数传递的例子，可以看到最后两个参数位于相对于栈指针距离为8和16的位置。注意：<strong>第6行movl从内存读入4字节，而后面的addb指令只是用其中的低位1字节。（因为它重置了存储a2的寄存器），另外这里也没有做扩展，因为它只是读取，不涉及再做转换，与2.1节的练习不同。</strong></p>

<div align="center"> <img src="/pic/CSAPP/stack&amp;data.png" width="500" /> </div>

<p><strong>要时刻注意MOV指令的使用。</strong></p>

<h3 id="栈上的局部存储">栈上的局部存储</h3>

<p>有些时候局部数据必须存放在内存中：</p>
<ol>
  <li>寄存器不足够存放所有数据</li>
  <li>对一个局部变量使用地址运算符</li>
  <li>某些局部变量是数组或结构</li>
</ol>

<p>下面是两个例子：</p>

<div align="center"> <img src="/pic/CSAPP/localStack1.png" width="500" /> </div>
<div align="center"> <img src="/pic/CSAPP/localStack2.png" width="500" /> </div>
<div align="center"> <img src="/pic/CSAPP/localStack3.png" width="500" /> </div>

<p><strong>注意3-6行，通过栈传参时数据大小按8的倍数对齐，分配局部变量内存时不用。再注意17-20行在读取内存的同时还会将其扩展到适当的大小。</strong></p>

<h3 id="寄存器中的局部存储空间">寄存器中的局部存储空间</h3>

<p>寄存器组是唯一被所有过程共享的资源，虽然在给定时刻只有一个过程是活动的，我们仍要保证一个过程调用另一个过程时，被调用者不会覆盖调用者稍后要使用的寄存器值。因此，根据惯例，<strong>寄存器%rbx,%rbp,$r12~%r15被划分为被调用者保存寄存器</strong>，当过程P调用过程Q时，Q必须保存这些寄存器的值，也就是说如果要用到它们，<strong>就要用pushq将原始值压入栈中，并在返回前从栈中弹出旧值。</strong></p>

<p>所有其他的寄存器除了%rsp都分类为调用者保存寄存器，这意味着任何函数都能修改它们，<strong>所以在调用之前首先保存好这个数据是调用者的责任。</strong></p>

<p>下面是一个例子：</p>

<div align="center"> <img src="/pic/CSAPP/localStack4.png" width="500" /> </div>

<h3 id="递归过程">递归过程</h3>

<p>递归调用一个函数本身与调用其他函数是一样的，栈提供了这种机制，每次函数调用都有他自己私有的状态信息。栈分配和释放规则自然的就与函数调用和返回顺序匹配。</p>

<div align="center"> <img src="/pic/CSAPP/recursion.png" width="500" /> </div>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="CSAPP" /><category term="汇编" /><summary type="html"><![CDATA[程序的机器级表示]]></summary></entry><entry><title type="html">CSAPP-2-2:程序的机器级运行控制</title><link href="http://localhost:4000/2024/01/02/CSAPP-2-2/" rel="alternate" type="text/html" title="CSAPP-2-2:程序的机器级运行控制" /><published>2024-01-02T10:23:00+08:00</published><updated>2024-01-02T10:23:00+08:00</updated><id>http://localhost:4000/2024/01/02/CSAPP-2-2</id><content type="html" xml:base="http://localhost:4000/2024/01/02/CSAPP-2-2/"><![CDATA[<h1 id="程序的机器级表示">程序的机器级表示</h1>

<h2 id="控制">控制</h2>

<p>C语言程序中存在有条件的执行语句，例如<strong>条件语句、循环语句和分支语句</strong>，机器代码提供两种基本的低级机制来实现有条件的行为：<strong>测试数据值，然后根据测试的结果来改变控制流或者数据流，</strong></p>

<h3 id="条件码">条件码</h3>

<p>除了整数寄存器，CPU还维护着一组<strong>单个位</strong>的<strong>条件码(condition code)寄存器</strong>，它们描述了最近的算术或者逻辑操作的属性，最常用的条件码有：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">CF</code>：进位标志。最近的操作使最高位产生了进位，可用来检查无符号操作的溢出。</li>
  <li><code class="language-plaintext highlighter-rouge">ZF</code>：零标志。最近的操作得出的结果为0。</li>
  <li><code class="language-plaintext highlighter-rouge">SF</code>：符号标志。最近的操作得到的结果为负数。</li>
  <li><code class="language-plaintext highlighter-rouge">OF</code>：溢出标志。最近的操作导致一个补码溢出—-正溢出或负溢出。</li>
</ol>

<p>例如，假设我们用一条ADD指令完成<code class="language-plaintext highlighter-rouge">t=a+b</code>的功能，则会根据下面的C表达式来设置条件码：</p>

<div align="center"> <img src="/pic/CSAPP/ConditionExm.png" width="400" /> </div>

<p>注意有几个特殊情况：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">leaq</code>指令<strong>不会改变任何条件码</strong>，除此之外，所有一元二元指令都会设置条件码。</li>
  <li>对于逻辑操作，例如<code class="language-plaintext highlighter-rouge">XOR</code>，<strong>进位标志和溢出标志</strong>会设置为0。</li>
  <li>对于移位操作，<strong>进位标志</strong>将设置为<strong>最后一个</strong>被移除的位，而<strong>溢出标志</strong>设置为0。</li>
  <li><code class="language-plaintext highlighter-rouge">INC</code>和<code class="language-plaintext highlighter-rouge">DEC</code>会设置<strong>溢出和零标志</strong>，但不会改变<strong>进位标志</strong>。</li>
</ol>

<p>除了算术和逻辑操作，还有两类指令会设置条件码，它们只设置条件码而不改变任何其他寄存器：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">CMP</code>指令根据两个操作数之差来设置条件码。除了不更新目的寄存器之外，行为与<code class="language-plaintext highlighter-rouge">SUB</code>指令一致，常用来比较大小。</li>
  <li><code class="language-plaintext highlighter-rouge">TEST</code>指令与<code class="language-plaintext highlighter-rouge">AND</code>指令的行为一样，除了不改变目的寄存器的值。典型的用法是两个操作数是一样的，或者其中操作数是一个掩码用来指示哪些位应该被测试（例如，<code class="language-plaintext highlighter-rouge">testq %rax,%rax</code>用来检查<code class="language-plaintext highlighter-rouge">%rax</code>是负数、零还是正数）。</li>
</ol>

<div align="center"> <img src="/pic/CSAPP/CMP&amp;TEST.png" width="400" /> </div>

<h3 id="访问条件码">访问条件码</h3>

<p>条件码通常不会直接读取，常见的使用方法有三种：</p>

<ol>
  <li>可以根据条件码的某种组合，将一个字节设置为0或1。</li>
  <li>可以条件跳转到程序的某个其他的部分。</li>
  <li>可以有条件的传送数据。</li>
</ol>

<p>针对第一种情况，我们将这一整类指令称为<code class="language-plaintext highlighter-rouge">SET</code>指令，它们的区别就在于他们考虑的条件码组合是什么，此时后缀表示<strong>不同的条件</strong>而不是操作数大小。</p>

<div align="center"> <img src="/pic/CSAPP/SET.png" width="500" /> </div>

<p>一个<code class="language-plaintext highlighter-rouge">SET</code>指令的目的操作数是低位单字节寄存器之一，或者是一个字节的内存为止，指针会将这个字节设置成0或1。为了得到一个32位或64位结果，<strong>必须对高位清零</strong>，例如<code class="language-plaintext highlighter-rouge">a&lt;b</code>的指令序列如下：</p>

<div align="center"> <img src="/pic/CSAPP/SETExm.png" width="400" /> </div>

<p>虽然所有的算术和逻辑操作都会设置条件码，但是所有<code class="language-plaintext highlighter-rouge">SET</code>指令的描述都适用的情况是：执行比较命令，根据计算<code class="language-plaintext highlighter-rouge">t=a-b</code>设置条件码。</p>

<p>考虑<code class="language-plaintext highlighter-rouge">setl</code>指令测试一个有符号比较，当没有发生溢出时（OF设置为0的时候表示无溢出），我们有当 $ a-_w^tb&lt;0 $时有 $a&lt;b$，将SF设置为1可以表明这一点，而当$ a-_w^tb\geq 0 $时有 $a&lt;geq b$，此时SF将置为0，因此有上表<code class="language-plaintext highlighter-rouge">setl</code>的效果，并且由<code class="language-plaintext highlighter-rouge">setl</code>可以推导出其他三个。</p>

<p>对于无符号比较的测试，当 $a&lt;b$时，<code class="language-plaintext highlighter-rouge">CMP</code>指令会设置进位标志，因而无符号比较使用的是进位标志和零标志的结合。</p>

<h3 id="跳转指令">跳转指令</h3>

<p>正常执行的情况下，指令会一条一条按顺序执行下去，跳转指令会导致执行切换到另一个全新的位置。在汇编代码中，这些跳转的目的地<strong>通常用一个标号(label)指明</strong>，例如：</p>

<div align="center"> <img src="/pic/CSAPP/jmpExm.png" width="400" /> </div>

<p>在产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将<strong>跳转目标</strong>（目的指令的地址）编码为跳转指令的一部分。</p>

<p>下图列举了不同的跳转指令，<code class="language-plaintext highlighter-rouge">jmp</code>为无条件跳转，他可以是直接跳转，即跳转目标是作为指令的一部分编码的，也可以是间接跳转，即跳转目标是从寄存器或内存位置中读出的，例如 <code class="language-plaintext highlighter-rouge">jmp *&amp;rax</code>是用寄存器中的值作为跳转目标，<code class="language-plaintext highlighter-rouge">jmp *(%rax)</code>以<code class="language-plaintext highlighter-rouge">%rax</code>中的值作为读地址，再从内存中读出跳转目标。</p>

<div align="center"> <img src="/pic/CSAPP/jmp.png" width="500" /> </div>

<h3 id="跳转指令的编码">跳转指令的编码</h3>

<p>在汇编代码中，跳转指令用符号标号书写，汇编器及后来的链接器会产生跳转目标的适当编码。跳转指令有几种不同的编码，但最常用的都是 <strong>PC相对的(PC-relative)。</strong> 也就是，它们会将 <strong>目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。</strong> 这些地址偏移量可以编码为1,2,4个字节。第二种编码方法就是给出“绝对”地址，用4个字节直接指定目标，汇编器和链接器会选择会选择适当的跳转目的编码。</p>

<p>下面是一个PC相对寻址的例子，第2行的<code class="language-plaintext highlighter-rouge">jmp</code>指令向前跳转到更高的地址，第7行的<code class="language-plaintext highlighter-rouge">jg</code>指令向后跳转到更低的地址：</p>

<div align="center"> <img src="/pic/CSAPP/PCjmpExm.png" width="200" /> </div>
<div align="center"> <img src="/pic/CSAPP/PCjmpExm2.png" width="300" /> </div>

<p>每个16进制两位数都是1个字节，第二行中跳转目标指明为 <code class="language-plaintext highlighter-rouge">loop+0x5+0x3</code>，第五行中为<code class="language-plaintext highlighter-rouge">loop+0xd-0x8</code>，都是下一条指令的地址的相对位置。</p>

<h3 id="用条件控制实现条件分支">用条件控制实现条件分支</h3>

<p>C语言中的if-else语句的通用形式模板如下：</p>

<pre><code class="language-C">if (test-expr)
    then-statement
else
    else-statement
</code></pre>

<p>汇编实现如下：</p>

<div align="center"> <img src="/pic/CSAPP/IfElse.png" width="200" /> </div>

<p>我们可以使用goto风格代码来更好地理解，这里注意汇编中条件跳转的参数与C语言中是相反的：</p>

<div align="center"> <img src="/pic/CSAPP/ifElseC.png" width="500" /> </div>

<p>还有一个例子：</p>

<pre><code class="language-C">void cond(long a, long *p){
    if(p &amp;&amp; a&gt;*p)
        *p=a;
}
</code></pre>

<p>汇编语言为</p>
<pre><code class="language-asm">cond:
    testq %rdi, %rdi
    jz .L2
    cmpq %rsi, (%rdi)
    jle .L2
    movq %rsi, (%rdi)
.L2:
    ret 
</code></pre>

<p>由于&amp;&amp;有短路性质，所以一个if语句在汇编中却有两个条件分支。</p>

<h3 id="用条件传送来实现条件分支">用条件传送来实现条件分支</h3>

<p>实现条件操作的传统方法是 通过使用<strong>控制</strong>的条件转移，当条件满足时程序沿着一条执行路径执行，否则走另一条路径。这种机制简单通用但是可能会低效。</p>

<p>一个替代的策略是使用<strong>数据</strong>的条件转移，这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个。下面是一个例子，注意也是求相反的结果：</p>

<div align="center"> <img src="/pic/CSAPP/cmovExm.png" width="500" /> </div>

<p>首先了解一下现代处理器如何运行，处理器通过使用流水线来获得高性能，一条指令的处理要经过一系列的阶段，例如从内存读指令，确定指令，从内存读数据，执行运算，写数据，更新计数器等。这种方法通过重叠连续指令来获得高性能，例如在取一条指令的同时执行前一条命令的算术运算。那就要实现确定要执行的指令序列才能保持流水线充满待执行的指令。</p>

<p>当机器遇到条件跳转的时候，处理器会采用非常精密的分支预测逻辑来猜测每条跳转指令是否会执行，如果猜错了就要求处理器丢掉它为该跳转指令后所有指令已做的工作，再从正确的位置处填充流水线，这会导致性能严重下降。</p>

<p>下面是一些可用的条件传送指令，源和目的的值可以是16、32、64位，但不支持单字节的条件传送。<strong>无条件传送需要将操作数长度显式编码在指令名中，但条件传送中汇编器可以从目标寄存器的名字来推断操作数长度，因此可以使用同一个名字。</strong></p>

<div align="center"> <img src="/pic/CSAPP/cmov.png" width="500" /> </div>

<p>同条件跳转不同，处理器无需预测测试结果就可以执行条件传送，<strong>在下一章会讨论它的实现。</strong></p>

<p>但是不是所有的条件表达式都可以用条件传送来编译：</p>

<ol>
  <li>如果这两个表达式中的任意一个可能产生错误条件或者副作用，就会导致非法的行为：
 例如，考虑下面这个C函数
    <pre><code class="language-C"> long cread(long *xp){
     return (xp ? *xp : 0);
 }
</code></pre>
    <p>对应的条件传送如下：</p>
    <pre><code class="language-asm"> xp in register %rdi.
 cread:
     movq (%rdi), %rax
     testq %rdi, %rdi
     movl $0, %edx
     cmove %rdx, %rax
     ret
</code></pre>
    <p>此时会出现间接引用空指针的错误。</p>
  </li>
  <li>如果两个操作都需要花费大量的运算，那就不会使用条件传送。</li>
  <li>执行任意分支可能会改变程序其他部分的状态时不会使用条件传送，例如
    <pre><code class="language-C"> val = x&gt;0 ? x*=7 : x+=3;
</code></pre>
  </li>
</ol>

<p>下面是除以2的幂次的例子：</p>

<div align="center"> <img src="/pic/CSAPP/divide8.png" width="300" /> </div>

<p>通过右移来实现，如果x小于0需要加$2^k-1$再进行右移。</p>

<h3 id="循环">循环</h3>

<p>C语言三中循环： do-while, while 和 for：</p>

<ol>
  <li><strong>do-while循环：</strong>
 do-while循环的通用形式为：
    <pre><code class="language-asm"> do
     body-statement
     while(test-expr)
</code></pre>

    <p>汇编形式为：</p>
    <pre><code class="language-asm"> loop:
     body-statement
     t = test-expr
     if (t)
         goto loop
</code></pre>
    <p>下面是阶乘计算的例子：</p>
    <div align="center"> <img src="/pic/CSAPP/dowhile.png" width="500" /> </div>
  </li>
  <li><strong>while循环：</strong>
 while语句有两种生成方法：
    <ol>
      <li>
        <p>第一种称之为jump to middle，这个是GCC带优化命令选项<code class="language-plaintext highlighter-rouge">-Og</code>时采用的翻译方法，可以翻译为：</p>

        <pre><code class="language-asm"> goto test;
 loop:
     body-statement
 test:
     t = test-expr;
     if (t)
         goto loop;
</code></pre>
        <div align="center"> <img src="/pic/CSAPP/while1.png" width="500" /> </div>
      </li>
      <li>
        <p>第二种翻译方法称为guarded-do，首先用条件分支，如果初始条件不成立就跳过循环，把代码变换为do-while循环，这是采用较高优化等级<code class="language-plaintext highlighter-rouge">-O1</code>才会采用的策略：</p>

        <pre><code class="language-asm"> t = test-expr
 if (t)
     goto done;
 loop:
     body-statement;
     t = test-expr;
     if(t)
         goto loop;
 done:
     ret
</code></pre>
        <div align="center"> <img src="/pic/CSAPP/while2.png" width="500" /> </div>
        <div align="center"> <img src="/pic/CSAPP/while3.png" width="300" /> </div>
      </li>
    </ol>
  </li>
  <li>
    <p><strong>for循环：</strong>
 for循环的通用形式为</p>

    <pre><code class="language-asm"> for(init-expr; test-expr; update-expr)
     body-statement
</code></pre>

    <p>这样一个循环的行为与下面这段代码的行为一样：</p>

    <pre><code class="language-asm"> init-expr;
 while (test-expr) {
     body-statement
     update-expr;
 }
</code></pre>
    <p>再利用while循环翻译为汇编语言。</p>

    <div align="center"> <img src="/pic/CSAPP/while2.png" width="500" /> </div>

    <pre><code class="language-C"> long fun_b(unsigned long x){
     long val = 0;
     long i;
     for(i = 64; i!=0; i--){
         val = (val &lt;&lt; 1) | (x &amp; 1);
         x &gt;&gt;= 1;
     }
     return val;
 }
</code></pre>

    <p>汇编代码为：</p>
    <pre><code class="language-asm"> fun_b:
     movl $64, %edx
     movl $0. &amp;eax
 .L10:
     movq %rdi, %rcx
     andl $1, %ecx
     addq %rax, %rax
     orq %rcx, %rax
     shrq $1, %rdi
     subq $1, %rdx
     jne .L10
     rep; ret
</code></pre>

    <p>因为64不为0，所有初始测试直接被忽略了。这个函数的行为是将x的位反过来，只需每次取x的最低位放进val低位，每次val左移，x右移。</p>
  </li>
</ol>

<h3 id="switch语句">switch语句</h3>

<p>switch语句不仅提高了C代码的可读性，而且通过使用<strong>跳转表</strong>使得实现更加高效。跳转表是一个数组，表项i是一个代码段的地址，当开关索引值等于i时程序采用对应的动作。它的优点在于：执行开关语句的时间与开关情况的数量无关。当开关情况数量比较多并且值的跨度范围比较小时就会使用跳转表。</p>

<div align="center"> <img src="/pic/CSAPP/switch1.png" width="500" /> </div>
<div align="center"> <img src="/pic/CSAPP/switch2.png" width="400" /> </div>
<p>这个例子中包括case label跨过一个不连续区域（101，105没有标号）、有多个标号（104，106）、有些情况会落入其他情况之中（102），因为没有break语句结尾。</p>

<p>可以看到，编译器首先将n减去100，把取值范围移到0-6之间，创建一个新的程序变量index，注意它是<strong>无符号值</strong>，这样我们可以通过测试index是否大于6来判定index是否在0-6之间，如果小于0的话根据补码性质也还是大于6的。根据index值有五个不同的跳转位置，loc_A(.L3)，loc_B(.L5)，loc_C(.L6)，loc_D(.L7)，loc_def(.L8)，最后一个是默认的目的地址。</p>

<p>执行switch语句的关键步骤是通过跳转表来访问代码位置，在汇编第五行以及goto代码中的第16行，<code class="language-plaintext highlighter-rouge">jmp</code>指令的操作数有前缀<code class="language-plaintext highlighter-rouge">*</code>，表明这是一个间接跳转，操作数指定一个内存为止，索引由寄存器%rsi给出，这个寄存器保存着index的值。</p>

<p>C代码将跳转表声明为一个7个元素的数组，每个元素都是一个指向代码位置的指针，可以发现，对于重复情况的处理就是对4和6采用同样的代码标号，对于确实情况的处理就是对1和5采用默认情况的标号。对于fall through的情况就是对应的代码位置也是fall through的。</p>

<p>在汇编中表示如下：</p>
<div align="center"> <img src="/pic/CSAPP/switch3.png" width="400" /> </div>

<p>其中<code class="language-plaintext highlighter-rouge">.rodata</code>为只读数据，其中包含一组7个四“字”（8个字节），每个字的值都是与指定的汇编代码标号相关联的指令地址。</p>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="CSAPP" /><category term="汇编" /><summary type="html"><![CDATA[程序的机器级表示]]></summary></entry><entry><title type="html">CSAPP-2-1:程序的机器级表示</title><link href="http://localhost:4000/2023/12/07/CSAPP-2-1/" rel="alternate" type="text/html" title="CSAPP-2-1:程序的机器级表示" /><published>2023-12-07T16:23:00+08:00</published><updated>2023-12-07T16:23:00+08:00</updated><id>http://localhost:4000/2023/12/07/CSAPP-2-1</id><content type="html" xml:base="http://localhost:4000/2023/12/07/CSAPP-2-1/"><![CDATA[<h1 id="程序的机器级表示">程序的机器级表示</h1>

<h2 id="程序编码概论">程序编码概论</h2>

<h3 id="术语介绍">术语介绍</h3>

<p>假设一个C程序有两个文件p1.c和p2.c，我们使用gcc编译这些代码，会经过以下步骤：</p>
<ol>
  <li><strong>C预处理</strong>扩展源代码，插入所有用#include命令指定的文件，并扩展所有用#define声明指定的宏；</li>
  <li><strong>编译器</strong>产生两个源文件的<strong>汇编代码</strong>，名字分别为p1.s和p2.s；</li>
  <li><strong>汇编器</strong>将汇编代码转化为二进制<strong>目标代码</strong>文件p1.o和p2.o；</li>
  <li><strong>链接器</strong>将目标代码文件和实现库函数的代码合并，并产生最终的可执行文件p。</li>
</ol>

<p>代码形式分为两种：</p>
<ol>
  <li>机器代码：byte-level的文件，包括目标代码以及可执行代码文件，目标代码中包含所有指令的二进制表示，但是还没有填入全局值的地址。</li>
  <li>汇编代码：是机器代码的文字表述。</li>
</ol>

<p>对于机器级编程来说，有两种抽象尤为重要：</p>
<ol>
  <li>第一种是由 <strong>指令集体系结构或指令集架构(Instruction Set Architecture, ISA)</strong> 来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式以及每条指令对状态的影响。大多数ISA，包括x86-64，将程序的行为描述成好像每条指令都是按顺序执行的。</li>
  <li>第二种是机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组，存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来，在后面第九章会讲到。</li>
</ol>

<p>在整个编译过程中，编译器会完成大部分的工作，将C语言提供的相对抽象的执行模型表示的程序转化为汇编代码，其主要特点是它用可读性更好的文本格式表示。</p>

<p>x86-64的机器代码和C代码差别非常大，一些通常对C语言程序员隐藏的处理器状态都是可见的：</p>
<ol>
  <li><strong>程序计数器</strong>(通常称为PC，在x86-64中用%rip表示)给出将要执行的下一条指令在内存中的地址。</li>
  <li><strong>整数寄存器文件</strong>包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址或整数数据。有的寄存器被用来记录重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量或返回值。</li>
  <li><strong>条件码寄存器</strong>保存着最近执行的算术或逻辑指令的状态信息</li>
  <li>一组<strong>向量寄存器</strong>可以存放一个或多个整数或浮点数值。</li>
</ol>

<p>虽然C语言提供了模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单地将内存看成一个很大的按字节寻址的数组，<strong>C语言中的聚合数据类型，例如数组和结构不存在于机器级代码</strong>，即使对于标量数据类型，汇编代码也不区分符号数与无符号数，不区分各种类型的指针，甚至不区分指针和整数。</p>

<p>程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块。程序内存用虚拟地址来寻址，例如x86-64的虚拟地址是由64位的字来表示的，操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。</p>

<p>一条机器指令只执行一个非常基本的操作，编译器必须产生这些指令的序列，从而实现程序结构。</p>

<h4 id="代码示例">代码示例</h4>

<p>假设我们写了一个C语言代码mstore.c</p>

<pre><code class="language-C">long mult2(long, long);

void multstore(long x, long y, long *dest) {
    long t = mult2(x,y);
    *dest = t;
}
</code></pre>

<p>使用gcc命令<code class="language-plaintext highlighter-rouge">gcc -Og -S mstore.c</code>可以产生汇编代码文件，包含以下几行：</p>

<pre><code class="language-asm">multstore:
    pushq   %rbx
    movq    %rdx, %rbx
    call    mult2
    movq    %rax, (%rbx)
    popq    %rbx
    ret
</code></pre>

<p>如果我们使用命令<code class="language-plaintext highlighter-rouge">gcc -Og -c mstore.c</code>，可以产生目标代码文件，它是二进制格式的，可以利用GDB命令<code class="language-plaintext highlighter-rouge">(gdb) x/14xb mulstore</code>查看。由此可见，机器对产生这些指令的源代码一无所知。</p>

<p>要查看机器代码文件的内容，有一类称为 <strong>反汇编器(disassembler)</strong>的程序非常有用，这些程序根据机器代码产生一种类似于汇编代码的格式，在Linux系统中可以使用<code class="language-plaintext highlighter-rouge">objdump -d mstore.o</code>命令实现，结果如下：</p>

<pre><code class="language-asm">0000000000000000 &lt;multstore&gt;:
    0:  53                  push    %rbx
    1:  48  89  d3          mov     %rdx, %rbx
    4： e8  00  00  00  00  callq   9 &lt;multstore+0x9&gt;
    9:  48  89  03          mov    %rax, (%rbx)
    c:  5b                  pop    %rbx
    d:  c3                  retq
</code></pre>

<p>其中一些关于机器代码和他的反汇编表示特性值得注意：</p>
<ol>
  <li>x86-64的指令长度从1到15个字节不等。</li>
  <li>设计指令格式的方式是从某个给定位置开始，可以将字节唯一解码成机器指令。例如，只有<code class="language-plaintext highlighter-rouge">pushq %rbx</code>是以字节值53开头的。</li>
  <li>反汇编器只是基于机器代码文件中的字节序列来确定汇编代码，它无需访问源代码或汇编代码。</li>
  <li>反汇编器使用的指令命令规则与gcc生成的汇编代码有细微差别，它省略了后缀的大小指示符。</li>
  <li>源程序所有名称在汇编代码级别完全消失，变成了寄存器或内存的某个位置。</li>
</ol>

<p>链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置，将代码的地址移到不同的地址范围中并在callq指令调用中填入需要使用的地址；另外，它也会插入一些nop指令使得函数代码变为16字节，使得就存储器系统性能而言，能更好地放置下一个代码块。</p>

<h2 id="数据格式">数据格式</h2>

<p>由于是从16位体系结构扩展到现在的，Intel用术语 <strong>字(word)</strong>来表示16位(2字节)数据类型，称32位为 <strong>双字(double words)</strong>，称64位为 <strong>四字(quad words)</strong>，下图给出了语言基本数据类型对应的x86-64表示。</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>C声明</td>
      <td>Intel数据类型</td>
      <td>汇编代码后缀</td>
      <td>大小（字节）</td>
    </tr>
    <tr>
      <td>char</td>
      <td>字节</td>
      <td>b</td>
      <td>1</td>
    </tr>
    <tr>
      <td>short</td>
      <td>字</td>
      <td>w</td>
      <td>2</td>
    </tr>
    <tr>
      <td>int</td>
      <td>双字</td>
      <td>l</td>
      <td>4</td>
    </tr>
    <tr>
      <td>long</td>
      <td>四字</td>
      <td>q</td>
      <td>8</td>
    </tr>
    <tr>
      <td>char*</td>
      <td>四字</td>
      <td>q</td>
      <td>8</td>
    </tr>
    <tr>
      <td>float</td>
      <td>单精度</td>
      <td>s</td>
      <td>4</td>
    </tr>
    <tr>
      <td>double</td>
      <td>双精度</td>
      <td>l</td>
      <td>8</td>
    </tr>
  </tbody>
</table>

<h2 id="访问信息">访问信息</h2>

<p>一个x86-64的CPU包含一组16个存储64位值的 <strong>通用目的寄存器</strong>，用于存储整数数据和指针，如下图所示。</p>

<div align="center"> <img src="/pic/CSAPP/register.png" width="500" /> </div>

<p>最初的8086中有8个16位的寄存器，即图中的%ax到%sp，它们的名字反映了不同的用途，分别是accumulate, base, counter, data, source index, destination index, base pointer, stack pointer.</p>

<p>目前它们已经和过去的功能几乎毫无关系，只是保留了名字。新扩充的8个寄存器则命名为%r8到%r15。</p>

<p>图中嵌套的方框表明，指令可以对这些寄存器的低位字节存放的不同大小的数据进行操作。当指令以寄存器为目标时，对于生成小于8字节结果的指令，有两个规则：</p>
<ol>
  <li>生成1字节和2字节数字的指令会保持剩下的字节不变，</li>
  <li>生成4字节数字的指令会把高位4个字节置为0。</li>
</ol>

<p>在常见的程序里，不同的寄存器扮演着不同的角色，有一组标准的变成规范控制着如何使用寄存器来管理栈、传递函数参数、从函数返回值以及存储局部和临时数据。</p>

<h3 id="操作数指示符">操作数指示符</h3>

<p>大多数指令有一个或多个 <strong>操作数(operand)</strong>，指示出执行一个操作要使用的源数据值以及放置结果的目的为止。<strong>源数据值可以以常数形式给出，或是寄存器或内存中读出，结果可以存放在寄存器或者内存中。</strong>因此，操作数分为3种类型：</p>
<ol>
  <li><strong>立即数(immediate)</strong>用来表示常数值，书写方式为$后面跟一个用C表示法表示的整数，例如<code class="language-plaintext highlighter-rouge">$-557, $0x1F</code></li>
  <li><strong>寄存器(register)</strong>表示某个寄存器的内容，我们用符号 $r_a$ 来表示任意寄存器a，用引用 $R[r_a]$ 表示它的值，这是将寄存器集合看成一个数组 $R$，用寄存器标识符作为索引。</li>
  <li><strong>内存引用</strong>，它会根据计算出来的地址访问某个内存位置，我们用符号$M_b[Addr]$ 表示对存储在内存中从地址Addr开始$b$个字节值的引用。</li>
</ol>

<p>如下图所示，有多种不同的寻址模式，允许不同形式的内存引用。其中最底部的 $Imm(r_b,r_i,s)$ 为最常用的形式，这里基址寄存器 $r_b$ 可以是任意寄存器，变址寄存器 $r_i$ 可以是除 \%rsp 外的任意寄存器，s必须为1、2、4或者8。<strong>有效地址被计算为</strong> $Imm+ R[r_b]+R[r_i]\cdot s$。</p>

<div align="center"> <img src="/pic/CSAPP/Mem.png" width="600" /> </div>

<h3 id="数据传送指令">数据传送指令</h3>

<p>最简单形式的数据传送指令为MOV类，这类指令把数据从源位置复制到目的位置，如下图所示：</p>
<div align="center"> <img src="/pic/CSAPP/MOV.png" width="400" /> </div>

<p>源操作数指定的值可以是立即数，也可以存储在寄存器或者内存中。目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址。 <strong>x86-64限制传送指令的两操作数不能都指向内存为止</strong>，如果想这样做需要先将源值加载到寄存器然后再写入目的位置。</p>

<p>大多数情况中MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置，唯一的例外是 <strong><code class="language-plaintext highlighter-rouge">movl</code>指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0。</strong>这是由于x86-64惯例为任何为寄存器生成32位值的指令都会把高位设置为0。</p>

<p>另外，常规的<code class="language-plaintext highlighter-rouge">movq</code>指令以立即数为源操作数时，只能表示32位补码数字再将其扩展到64位的值，<strong><code class="language-plaintext highlighter-rouge">movabsq</code>指令能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的。</strong></p>

<p>下面两个图记录的是另外两类数据移动指令，在将较小的源值复制到较大的目的时使用。</p>

<div align="center"> <img src="/pic/CSAPP/MOVZ.png" width="500" /> </div>

<div align="center"> <img src="/pic/CSAPP/MOVS.png" width="500" /> </div>

<p>注意到并没有一条明确的指令把4字节源值扩展到8字节目的，因为这个可以依靠<code class="language-plaintext highlighter-rouge">movl</code>指令实现。</p>

<p>例子：</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">movabsq $0x0011223344556677, %rax</code></td>
      <td>%rax = 0x0011223344556677</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">movb $-1, %al</code></td>
      <td>%rax = 0x00112233445566FF</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">movw $-1, %ax</code></td>
      <td>%rax = 0x001122334455FFFF</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">movl $-1, %eax</code></td>
      <td>%rax = 0x00000000FFFFFFFF</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">movq $-1, %rax</code></td>
      <td>%rax = 0xFFFFFFFFFFFFFFFF</td>
    </tr>
  </tbody>
</table>

<p>反例：</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">movb $0xF, (%ebx)</code></td>
      <td><strong>内存引用要用4字寄存器</strong></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">movl %rax, (%rsp)</code></td>
      <td><code class="language-plaintext highlighter-rouge">movl</code>改为<code class="language-plaintext highlighter-rouge">movq</code>，<strong>MOV指令以源操作数字长为准</strong></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">movw (%rax), 4(%rsp)</code></td>
      <td><strong>两操作数不能同时为内存引用</strong></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">movb %al,  %sl</code></td>
      <td>不存在%sl这个寄存器</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">movq %rax, $0x123</code></td>
      <td>立即数不能作为目的地址，去掉$是可以的</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">movl %eax, %rdx</code></td>
      <td><strong>两寄存器的大小必须一致</strong></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">movb %si, 8(%rbp)</code></td>
      <td><code class="language-plaintext highlighter-rouge">movb</code>改为<code class="language-plaintext highlighter-rouge">movw</code></td>
    </tr>
  </tbody>
</table>

<p>注释：</p>
<ol>
  <li>从小字长复制到大字长寄存器或内存都需要扩展；</li>
  <li>MOV指令一定确保能将源操作数完整地传送；</li>
  <li>从大字长类型内存复制到小字长内存需要先利用寄存器存值，再用寄存器的低位传递到小字长类型的内存中；
例子：
    <ol>
      <li><code class="language-plaintext highlighter-rouge">int *sp, char *dp, *dp = (char) *sp</code>
        <pre><code class="language-ams">  movl    (%rdi), %eax
  movb    %al, (%rsi)
</code></pre>
      </li>
      <li><code class="language-plaintext highlighter-rouge">char *sp, int *dp, *dp = (int) *sp</code>
        <pre><code class="language-ams">  movsbl    (%rdi), %eax
  movl    %eax, (%rsi)
</code></pre>
      </li>
    </ol>
  </li>
</ol>

<h3 id="压入和弹出栈数据">压入和弹出栈数据</h3>

<p>栈遵循后进先出的原则，弹出的值永远是最近被压入而且仍然在栈中的值。栈可以实现为一个数组，总是从数组的一端插入和删除元素，称为栈顶。</p>

<p>在x86-64中栈存放在内存的某个区域，如下图所示，栈向下增长。对栈可以进行两个操作：</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">pushq %rbp</code>指令首先将栈指针减8，然后将值写入新的栈顶位置，等价于
    <pre><code class="language-ams"> subq    $8, %rsp
 movq    %rbp, (%rsp)
</code></pre>
  </li>
  <li><code class="language-plaintext highlighter-rouge">popq</code>指令首先从栈顶位置读出数据，再将栈指针加8，等价于
    <pre><code class="language-ams"> movq    (%rsp), %rax
 addq    $8, %rsp
</code></pre>
  </li>
</ol>

<div align="center"> <img src="/pic/CSAPP/PushPop.png" width="500" /> </div>

<div align="center"> <img src="/pic/CSAPP/StackOp.png" width="500" /> </div>

<h2 id="算术和逻辑操作">算术和逻辑操作</h2>

<p>操作指令主要分为四组：加载有效地址、一元操作、二元操作和移位，如下图所示：</p>

<div align="center"> <img src="/pic/CSAPP/amsArith.png" width="400" /> </div>

<h3 id="加载有效地址">加载有效地址</h3>

<p>加载有效地址(load effective address)指令<code class="language-plaintext highlighter-rouge">leaq</code>实际上是<code class="language-plaintext highlighter-rouge">movq</code>指令的变形，它的指令形式是从内存读数据到寄存器，但 <strong>实际上它根本没有引用该内存，而是将有效地址写入到目的操作数</strong>。另外，他也可以简洁地表述普通的算术操作，例如，如果寄存器\%rdx存有 $x$，那么<code class="language-plaintext highlighter-rouge">leaq 7(%rdx,%rdx,4), %rax</code>就是将寄存器 \%rax的值设置为 $5x+7$。</p>

<p><strong><code class="language-plaintext highlighter-rouge">leaq</code>指令的目的操作数必须是一个寄存器</strong>，下面将<code class="language-plaintext highlighter-rouge">movq,leaq</code>与数组进行类比：</p>

<p><code class="language-plaintext highlighter-rouge">movq</code>相当于<code class="language-plaintext highlighter-rouge">array[i]</code>，<code class="language-plaintext highlighter-rouge">movq (%rdi,%rsi,8), %rbp</code>是将源内存地址的值传给\%rbp；
<code class="language-plaintext highlighter-rouge">leaq</code>相当于<code class="language-plaintext highlighter-rouge">&amp;array[i]</code>，<code class="language-plaintext highlighter-rouge">leaq (%rdi,%rsi,8), %rbp</code>是将源内存地址直接传给\%rbp。</p>

<h3 id="一元和二元操作">一元和二元操作</h3>

<p>二元操作的第二个操作数既是源又是目的，类似于<code class="language-plaintext highlighter-rouge">x-=y</code>，第一个操作数可以是立即数、寄存器或者内存，第二个操作数可以是寄存器或者内存， <strong>当第二个操作数为内存时，处理器必须从内存读出值，执行操作，再把结果写回内存。</strong></p>

<h3 id="移位操作">移位操作</h3>

<p><strong>移位量可以是一个立即数，或者放在单字节寄存器\%cl中。</strong>(这些指令很特别，因为只允许以这个特定的寄存器为操作数。)</p>

<p>原则上来说1个字节的移位量使得移位量的编码范围可以达到 $2^8-1=255$，<strong>移位操作对 $w$ 位长的数据值进行操作，移位量是由\%cl寄存器的低m位决定的，这里 $2^m=w$，高位会被忽略。</strong></p>

<p>例如，当寄存器\%cl的十六进制的值为0xFF时，指令<code class="language-plaintext highlighter-rouge">salb</code>会左移7位，而指令<code class="language-plaintext highlighter-rouge">salw</code>会左移15位，<code class="language-plaintext highlighter-rouge">salq</code>会左移63位。</p>

<p>移位操作的目的操作数可以是一个寄存器或是一个内存位置。</p>

<h3 id="特殊的算术操作">特殊的算术操作</h3>

<p>两个64位有符号或无符号整数相乘需要128位来表示，Intel把16字节的数称为 <strong>八字(oct word)</strong>，下图为支持两个64位数字的全128位乘积和除法的指令：</p>

<div align="center"> <img src="/pic/CSAPP/64ArithOp.png" width="500" /> </div>

<p><code class="language-plaintext highlighter-rouge">imulq</code>指令有两种不同形式:</p>
<ol>
  <li>一种是前面的双操作数乘法指令，实现了前一章的操作 $\times_{64}^u, \times_{64}^t$；</li>
  <li>另外一种是上图中的单操作数乘法指令—-一个是无符号数乘法(<code class="language-plaintext highlighter-rouge">mulq</code>)，而另一个是补码乘法(<code class="language-plaintext highlighter-rouge">imulq</code>)，<strong>这两种指令都要求都要求一个参数必须在寄存器\%rax中，而另一个作为指令的源操作数给出，最后乘积存放在寄存器\%rdx(高64位)和\%rax(低64位)中。</strong> 例：
    <pre><code class="language-C">typedef unsigned __int128 uint128_t;
void store_uprod(uint128_t *dest, uint64_t x, uint64_t y){
 *dest = x * (uint128_t) y;
}
</code></pre>
  </li>
</ol>

<p>GCC生成的汇编代码如下：</p>
<pre><code class="language-asm">% dest in %rdi, x in %rsi, y in %rdx
store_uprod:
    movq    %rsi, %rax          Copy x to multiplicand
    mulq    %rdx                Multiply by y
    movq    %rax, (%rdi)        Store lower 8 bytes at dest
    movq    %rdx, 8(%rdi)       Store upper 8 bytes at dest+8
</code></pre>
<p><strong>因为我们针对的是小端法机器，所以高位字节存储在大地址。</strong></p>

<p>类似的，有符号除法指令<code class="language-plaintext highlighter-rouge">idivl</code>将寄存器\%rdx(高64位)和\%rax(低64位)中的128位数作为被除数，而 <strong>除数作为指令的操作数给出，指令将商存在寄存器\%rax中，将余数存在寄存器\%rdx中。</strong></p>

<p>对于大多数64位除法应用来说，被除数也常常是64位的值，这个时候值应该存在\%rax中，<strong>\%rdx的位应该设置为0(无符号运算)或者\%rax的符号位(有符号运算)，这个操作可以用<code class="language-plaintext highlighter-rouge">cqto</code>完成。</strong> 以有符号64位整数除法运算为例：</p>

<pre><code class="language-C">void remdiv(long x, long y, long *qp, long *rp){
    long q = x/y;
    long r = x%y;
    *qp = q;
    *rp = r;
}
</code></pre>

<p>GCC编译得到如下汇编代码：</p>

<pre><code class="language-asm">% x in %rdi, y in %rsi, qp in %rdx, rp in %rcx
remdiv:
    movq    %rdx, %r8
    movq    %rdi, %rax
    cqto
    idivq   %rsi
    movq    %rax, (%r8)
    movq    %rdx, (%rcx)
    ret
</code></pre>

<p>上述代码中，必须先把qp保存到另一个寄存器中，因为除法操作需要使用。</p>

<p>再考虑无符号64位数的除法：</p>

<pre><code class="language-C">void remdiv(unsigned long x, unsigned long y,
            unsigned long *qp, unsigned long *rp){
    unsigned long q = x/y;
    unsigned long r = x%y;
    *qp = q;
    *rp = r;
}
</code></pre>

<p>GCC编译得到如下汇编代码：</p>

<pre><code class="language-asm">% x in %rdi, y in %rsi, qp in %rdx, rp in %rcx
remdiv:
    movq    %rdx, %r8
    movq    %rdi, %rax
    movl    $0, %edx
    divq   %rsi
    movq    %rax, (%r8)
    movq    %rdx, (%rcx)
    ret
</code></pre>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="CSAPP" /><category term="汇编" /><summary type="html"><![CDATA[程序的机器级表示]]></summary></entry><entry><title type="html">CSAPP-1:信息的表示和处理</title><link href="http://localhost:4000/2023/11/24/CSAPP-1/" rel="alternate" type="text/html" title="CSAPP-1:信息的表示和处理" /><published>2023-11-24T14:23:00+08:00</published><updated>2023-11-24T14:23:00+08:00</updated><id>http://localhost:4000/2023/11/24/CSAPP-1</id><content type="html" xml:base="http://localhost:4000/2023/11/24/CSAPP-1/"><![CDATA[<h1 id="信息的表示和处理">信息的表示和处理</h1>

<h2 id="信息存储">信息存储</h2>

<h3 id="基本概念">基本概念</h3>

<p><strong>位(bit)</strong> 为计算机方位内存中单独的位，<strong>字节(byte)</strong> 为计算机中最小的可寻址的内存单位，大多数计算机使用8-Bit的字节。机器级程序将内存视为一个非常大的字节数，称为<strong>虚拟内存(virtual memory)</strong>。内存的每个字节都由一个唯一的数字来标识，被称为它的<strong>地址(address)</strong>，所有可能地址的集合被称为<strong>虚拟地址空间</strong>。</p>

<p>每台计算机都有一个<strong>字长(word size)</strong>，指明指针数据的标准大小(normal size)，对于一个字长为 $w$ 的机器而言，虚拟地址的范围为 $0\sim 2^w-1$，程序最多访问 $2^w$ 个字节。</p>

<div align="center"> <img src="/pic/CSAPP/WordSize.png" width="300" /> </div>
<center><p>基本C数据类型的典型大小(以字节为单位)</p></center>

<h3 id="寻址和字节顺序">寻址和字节顺序</h3>
<p>在几乎所有的机器上，多字节对象都被存储为连续的字节，但排列表示一个对象的字节有两种通用规则：</p>
<ol>
  <li>最低有效字节在前面的方式称为<strong>小端法(little endian)</strong>，大多数Intel兼容机，Android和IOS都只用小端模式，</li>
  <li>最高有效字节在前面的方式称为<strong>大端法(big endian)</strong>，网络传送数据时要求使用大端法规则。</li>
</ol>

<p>假设变量 $x$ 类型为int，位于地址0x100处，十六进制的值为0x01234567，下图表示两种方法排列表示的规则：</p>
<div align="center"> <img src="/pic/CSAPP/LHEndian.png" width="600" /> </div>

<p>对于大多数情况下，及其所使用的字节顺序是完全不可见的，但在一些情况下，字节顺序会成为问题：</p>
<ol>
  <li>当小端法机器产生的数据被发送到大端法机器时，接收程序会发现字节反序，为避免这类问题，网络应用程序的代码编写必须遵守大端法规则（<strong>见11章</strong>）。</li>
  <li>当阅读表示整数数据的字节序列时字节顺序很重要，这通常发生在检查机器级程序时，例如阅读反汇编器生成的代码时（<strong>见3章</strong>）。</li>
  <li>
    <p>当编写规避正常的类型系统的程序时字节顺序变得重要，例如：我们将byte_pointer定义为一个指向类型为unsigned char的对象的指针，这样一个字节指针引用一个字节序列，其中每一个字节都被认为是一个非负整数，</p>

    <pre><code class="language-C"> typedef unsigned char *byte_pointer;

 void show_bytes(byte_pointer start, size_t len) {
     size_t i;
     for (i = 0; i &lt; len; i++)
     printf(" %.2x", start[i]);
     printf("\n");
 }

 void show_int(int x) {
     show_bytes((byte_pointer) &amp;x, sizeof(int)); 
 }

 void show_float(float x) {
     show_bytes((byte_pointer) &amp;x, sizeof(float)); 
 }

 void show_pointer(void *x) {
     show_bytes((byte_pointer) &amp;x, sizeof(void *));
 }

 void test_show_bytes(int val) {
     int ival = val;
     float fval = (float) ival;
     int *pval = &amp;ival;
     show_int(ival);
     show_float(fval);
     show_pointer(pval);
 }
</code></pre>
    <p>在不同机器上得到的结果并不相同，如下图所示：</p>
  </li>
</ol>
<div align="center"> <img src="/pic/CSAPP/Show_Bytes.png" width="500" /> </div>
<p>这里注意每输出一次都是两位十六进制数，因为一个字节是8Bit，对应两位十六进制数。</p>

<h3 id="字符串表示">字符串表示</h3>

<p>C语言中字符串被编码为一个以null(其值为0)字符结尾的字符数组，例如我们以参数<code class="language-plaintext highlighter-rouge">12345</code>和<code class="language-plaintext highlighter-rouge">6</code>来运行<code class="language-plaintext highlighter-rouge">show_bytes</code>，我们会得到结果 <code class="language-plaintext highlighter-rouge">31 32 33 34 35 00</code>.</p>

<h2 id="布尔代数简介">布尔代数简介</h2>

<p>最简单的布尔代数是在二元集合{0,1}上定义的:</p>
<ol>
  <li>布尔运算 $\sim$ 对应于逻辑运算 <code class="language-plaintext highlighter-rouge">NOT</code>，在命题逻辑中用符号 $\lnot$ 表示，</li>
  <li>布尔运算 $\And$ 对应于逻辑运算 <code class="language-plaintext highlighter-rouge">AND</code>，在命题逻辑中用符号 $\land$ 表示，</li>
  <li>布尔运算 $\vert$ 对应于逻辑运算 <code class="language-plaintext highlighter-rouge">OR</code>，在命题逻辑中用符号 $\lor$ 表示，</li>
  <li>布尔运算 ^ 对应于逻辑运算异或(Exlusive or)，在命题逻辑中用符号用 $\oplus$ 表示。
具体规则如下图所示：</li>
</ol>
<div align="center"> <img src="/pic/CSAPP/Boolean.png" width="400" /> </div>

<p>以上布尔运算可以扩展到<strong>位向量</strong>的运算，其中位向量就是固定长度为w，由0和1组成的串，它一个很有用的应用就是表示有限集合。</p>

<h3 id="c语言中的位级运算">C语言中的位级运算</h3>

<p>位级运算的一个常见用法就是<strong>掩码运算</strong>，例如：</p>
<ol>
  <li>掩码<code class="language-plaintext highlighter-rouge">0xFF</code>表示一个字的低位字节，位级运算<code class="language-plaintext highlighter-rouge">x &amp; 0xFF</code>生成一个由 $x$ 的最低有效字节组成的值，而其他的字节都被置为0，</li>
  <li>位级运算<code class="language-plaintext highlighter-rouge">x | 0xFF</code>将x的最低有效字节设为1，其他字节保持不变，</li>
  <li><code class="language-plaintext highlighter-rouge">x ^ 0xFFFFFFFF</code>等价于<code class="language-plaintext highlighter-rouge">~x</code>，<code class="language-plaintext highlighter-rouge">x ^ 0</code>不发生改变，</li>
  <li><code class="language-plaintext highlighter-rouge">x ^ ~0xFF</code>使得x最低有效字节不变，其他位都取补。</li>
  <li><strong>注意是最低有效字节，8位，所以是0xFF。</strong></li>
</ol>

<p>关于异或运算还有两点注意：</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">x ^ y = (x &amp; ~y) | (~x &amp; y)</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">a ^ a = 0</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">y = x^y, x = x^y, y = x^y</code>即可做到不需要第三个位置就可以交换 $x$ 和 $y$ 的值。</li>
  <li><code class="language-plaintext highlighter-rouge">!(x^y)</code>满足当 $x,y$ 相等时返回1，否则返回0。</li>
</ol>

<p><strong>三个二元位级运算都具有交换律和结合律。</strong></p>

<h3 id="c语言中的逻辑运算">C语言中的逻辑运算</h3>

<p>逻辑运算有三种: <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>, <code class="language-plaintext highlighter-rouge">||</code>, <code class="language-plaintext highlighter-rouge">!</code>，注意别和位级运算混淆即可，另外<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>和<code class="language-plaintext highlighter-rouge">||</code>具有短路性。</p>

<h3 id="c语言中的移位运算">C语言中的移位运算</h3>

<p>对于一个位表示为 $[x_{w-1},x_{w-2},\ldots,x_0]$ 的操作数 $x$，左移运算<code class="language-plaintext highlighter-rouge">x&lt;&lt;k</code>使得 $x$ 向左移动 $k$ 位，丢弃最高的 $k$ 位，并在右端补上 $k$ 个0。并且<strong>移位运算从左到右是可结合的。</strong></p>

<p>相应地，右移运算<code class="language-plaintext highlighter-rouge">x&gt;&gt;k</code>分为两种:</p>
<ol>
  <li>对无符号数使用逻辑右移，即在左端补 $k$ 个0，得到 $[0,\ldots,0,x_{w-1},\ldots,x_k]$ .</li>
  <li>对有符号数使用算术右移，即在左端补 $k$ 个最高有效位的值，得到 $[x_{w-1},\ldots,x_{w-1},x_{w-1},x_{w-2},\ldots,x_{k}]$.</li>
</ol>

<p>注意:</p>
<ol>
  <li>对于一个 $w$ 位组成的数据类型，当 $k\geq w$ 很大的时候，实际上的位移量就是<code class="language-plaintext highlighter-rouge">k mod w</code>位。</li>
  <li>加减法的优先级比移位运算要高，因此在拿不准的时候记得加括号。</li>
</ol>

<h2 id="整数表示">整数表示</h2>

<h3 id="整数编码">整数编码</h3>

<p>对于位向量 $\mathbf{x} = [x_{w-1},x_{w-2},\ldots,x_0]$, 无符号数编码定义为
\(\text{B2U}_w(\mathbf{x}) = \sum\limits_{i=0}^{w-1} x_i 2^i\)</p>

<p>补码编码的定义为 \(\text{B2T}_w(\mathbf{x}) = -x_{w-1}2^{w-1} - \sum\limits_{i=0}^{w-2} x_i 2^i\)</p>

<p>可以证明当 $0\leq x \leq 2^w-1$ 时，无符号数编码是唯一的，
当 $\text{TMin}_w = -2^{w-1} \leq x \leq 2^{w-1}-1 = \text{TMax}_w$ 时，补码编码是唯一的。</p>

<p>关于这些数字，有几点值得注意：</p>
<ol>
  <li>补码的范围是不对称的，即 <code class="language-plaintext highlighter-rouge">|TMin| = |TMax| + 1</code>，</li>
  <li>最大的无符号数刚好比补码的最大数的两倍大1，即<code class="language-plaintext highlighter-rouge">UMax = 2TMax +1</code>，</li>
  <li>-1和 UMax 有同样的位表示，即一个全1的串。</li>
</ol>

<h3 id="有符号数和无符号数的转换">有符号数和无符号数的转换</h3>

<ol>
  <li>对于满足 $\text{TMin}_w \leq x \leq \text{TMax}_w$ 的 $x$ 有，</li>
</ol>

\[\text{T2U}_w(x) = \begin{cases}
    x+2^w ,\quad &amp;x &lt; 0 \\
    x,\quad &amp;x \geq 0    
\end{cases}\]

<ol>
  <li>对于满足 $0 \leq u \leq \text{UMax}_w$ 的$u$有，</li>
</ol>

\[\text{U2T}_w(u) = \begin{cases}
    u-2^w ,\quad &amp; u &gt; \text{TMax}_w \\
    u,\quad &amp; u \leq \text{TMax}_w   
\end{cases}\]

<p>当 $u&gt;\text{TMax}_w$ 时，$u$的最高位有效数字为1，转化为补码表示就相当于最高位权重从+1变为-1，因此少了 $2^w$，反之同理，越靠近0的负数映射为越大的无符号数。</p>

<p>另外，可以证明U2T和T2U两个函数都是双射，两个函数的行为如下图所示：</p>
<div align="center"> <img src="/pic/CSAPP/U2T_T2U.png" width="500" /> </div>

<p>在C语言中允许两者之间相互转换，主要有四种情况：</p>
<ol>
  <li>显示的强制类型转换就会导致转换发生，例如
    <pre><code class="language-C"> int tx; 
 unsigned ux; 
 tx = (int)ux;
</code></pre>
  </li>
  <li>一种类型的表达式被赋值给另外一种类型的变量，例如
    <pre><code class="language-C"> tx = ux;
</code></pre>
  </li>
  <li>当用printf输出数值时，分别用<code class="language-plaintext highlighter-rouge">%d</code>,<code class="language-plaintext highlighter-rouge">%u</code>和`%x%表示有符号十进制、无符号十进制和十六进制格式输出一个数字，例如
    <pre><code class="language-C"> int x = -1;
 printf("x = %u = %d\n", x, x); \\ x = 4294967295 = -1.
</code></pre>
  </li>
  <li><strong>当执行一个两侧分别为有符号和无符号数的运算时，会隐式地将有符号数转换为无符号数</strong>，例如
    <ol>
      <li><code class="language-plaintext highlighter-rouge">-1 &lt; 0U</code>是错误的，</li>
      <li><code class="language-plaintext highlighter-rouge">-1 &gt; (unsigned)-2</code>是正确的，</li>
      <li><code class="language-plaintext highlighter-rouge">2147483647 &gt; (int)2147483648U</code>是正确的。</li>
    </ol>
  </li>
</ol>

<p>在C头文件<code class="language-plaintext highlighter-rouge">limit.h</code>中是这样定义TMin和TMax的：</p>
<pre><code class="language-C">#define INT_MAX 2147483647
#define INT_MIN (-INT_MAX - 1)
</code></pre>
<p>因为在某些编译器中可能会把-2147482648认为是正数，这里不深究，了解即可。</p>

<h3 id="扩展一个数字的位表示">扩展一个数字的位表示</h3>

<ol>
  <li>
    <p>宽度为 $w$ 的位向量 $\mathbf{u} = [u_{w-1},\ldots,u_0]$ 扩展到 $w’$ 位的 $\mathbf{u}’ = [0,\ldots,0,u_{w-1},\ldots,u_0]$，则有
\(\text{B2U}_w(\mathbf{u}) == \text{B2U}_{w'}(\mathbf{u}')\)</p>
  </li>
  <li>
    <p>宽度为 $w$ 的位向量 $\mathbf{x} = [x_{w-1},\ldots,x_0]$ 扩展到 $w’$ 位的 $\mathbf{x}’ = [x_{w-1},\ldots,x_{w-1},x_{w-1},\ldots,x_0]$，则有
\(\text{B2T}_w(\mathbf{x}) == \text{B2T}_{w'}(\mathbf{x}')\)</p>
  </li>
</ol>

<p>举个例子，有符号数<code class="language-plaintext highlighter-rouge">1001 -&gt; -7</code>，扩展到8位时<code class="language-plaintext highlighter-rouge">11111001 -&gt; -7</code>，因为 \(-2^{p+k}+2^{p+k-1}+\ldots+2^p = -2^p.\)</p>

<p>值得注意的是，从一个数据大小到另一个数据大小的转换，以及无符号和有符号之间的转换的相对顺序能够影响一个程序的行为，例如</p>

<pre><code class="language-C">short sx = -12345;
unsigned uy = sx; /* Mystery! */
printf("uy = %u:\t", uy);
show_bytes( (byte_pointer)&amp;uy, sizeof(unsigned));
\\ uy = 4294954951: ff ff cf c7.
</code></pre>

<p>这表明<strong>当short转换成unsigned时，我们先要改变大小，然后再完成有符号到无符号的转换</strong>，即<code class="language-plaintext highlighter-rouge">(unsigned)sx</code>等价于<code class="language-plaintext highlighter-rouge">(unsigned)(int)sx</code>而不是<code class="language-plaintext highlighter-rouge">(unsigned)(unsigned short)sx</code>。</p>

<h3 id="截断数字">截断数字</h3>

<p>截断一个数字可能会改变它的值，这也是溢出的一种形式。</p>

<ol>
  <li>
    <p>令 $\mathbf{x} = [x_{w-1},\ldots,x_0]$，将其阶段为k位有 $\mathbf{x}’ = [x_{k-1},\ldots,x_0]$, 
记 $x=\text{B2U}<em>w(\mathbf{x}), x’ = \text{B2U}</em>{k}(\mathbf{x}’)$， 则有 $x’ = x\mod\ 2^k$.</p>
  </li>
  <li>
    <p>令 $\mathbf{x} = [x_{w-1},\ldots,x_0]$，将其阶段为k位有 $\mathbf{x}’ = [x_{k-1},\ldots,x_0]$, 
记 $x=\text{B2U}<em>w(\mathbf{x}), x’ = \text{B2T}</em>{k}(\mathbf{x}’)$, 则有 $x’ = \text{U2T}_k(x\mod\ 2^k)$.</p>
  </li>
</ol>

<p>其实<strong>两个操作在位级别上是相同的，只是最后按照不同编码表示而已</strong>。</p>

<h2 id="整数运算">整数运算</h2>

<h3 id="整数加法">整数加法</h3>

<ol>
  <li>对于满足 $0\leq x,y &lt; 2^w$ 的整数 $x,\ y$ 有:</li>
</ol>

\[x+_w^u y = \begin{cases}
    x+y,\quad &amp;x+y&lt;2^w\quad &amp;\text{正常} \\
    x+y - 2^w,\quad &amp;2^w \leq x+y &lt; 2^{w+1}\quad &amp;\text{溢出}
\end{cases}\]

<ol>
  <li>对于满足 $-2^{w-1} \leq x,y \leq 2^{w-1}-1$ 的整数 $x,\ y$，有:</li>
</ol>

\[x +_w^t y = \begin{cases}
    x + y - 2^w, \quad &amp; 2^{w-1}\leq x+y \quad &amp;\text{正溢出} \\
    x + y, \quad &amp; -2^{w-1} \leq x+y &lt; 2^{w-1} \quad &amp;\text{正常} \\
    x + y + 2^w, \quad &amp; x+y &lt; -2^{w-1} \quad &amp;\text{负溢出}
\end{cases}\]

<p>负溢出的情况下截断后最高位有效数字必为0，否则就不会出现溢出了。</p>

<p>这里值得注意的是<strong>补码加法与无符号数加法有相同的位级表示</strong>，用数学语言表示就是</p>

\[x +_w^t y = \text{U2T}_w(\text{T2U}_w(x) +_w^u \text{T2U}_w(y)) = \text{U2T}_w[(x+y) mod 2^w]\]

<p>这样计算机就可以用同一个算法进行加法，之后的乘法也是如此。</p>

<p>另外，<strong>模数加法形成了阿贝尔群</strong>，它是可交换的并且可结合的，存在单位元0，并且每个元素有一个加法逆元（<strong>位级操作上为取反后+1</strong>）：</p>
<ol>
  <li>对于满足 $0\leq x&lt; 2^w$ 的整数 $x$ 有:</li>
</ol>

\[-_w^u x = \begin{cases}
    x, \quad &amp; x=0 \\
    2^w-x, \quad &amp; x&gt;0
\end{cases}\]

<ol>
  <li>对于满足 $-2^{w-1} \leq x\leq 2^{w-1}-1$ 的整数 $x$，有:</li>
</ol>

\[-_w^t x = \begin{cases}
    \text{TMin}_x, \quad &amp; x = \text{TMin}_w \\
    -x, \quad &amp; x &gt; \text{TMin}_w
\end{cases}\]

<p>判断是否出现溢出的方法如下:</p>
<ol>
  <li>
    <p>对于在范围 $0\leq x,y \leq \text{UMax}_w$ 的 $x,\ y$, 令 $s=x +_w^u y$，则计算发生溢出当且仅当 $s&lt;x$(或者等价地$s&lt;y$)。</p>
  </li>
  <li>
    <p>对于在范围 $\text{TMin}_w \leq x,y \leq \text{TMax}_w$的 $x,\ y$, 令$s=x +_w^t y$，则</p>
    <ol>
      <li>发生正溢出当且仅当 $x&gt;0,y&gt;0,s\leq 0$，</li>
      <li>发生负溢出当且仅当 $x&lt;0,y&lt;0,s\geq 0$.</li>
    </ol>
  </li>
</ol>

<p>对于补码而言，判断是否发生溢出的代码如下：</p>

<pre><code class="language-C">int tadd_ok(int x, int y){
    int sum = x + y;
    int neg_over = x &lt; 0 &amp;&amp; y &lt; 0 &amp;&amp; sum &gt;=0;
    int pos_over = x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; sum &lt; 0;
    return !neg_over &amp;&amp; !pos_over;
}
</code></pre>

<p>注意以下写法是不对的：</p>

<pre><code class="language-C">int tadd_ok(int x, int y){
    int sum = x + y;
    return (sum - x == y) &amp;&amp; (sum -y == x);
}
</code></pre>

<p>因为模数加法构成阿贝尔群，$(x+y-x)$ 的结果永远都是$y$.</p>

<p>虽然我们现在可以判断加法是否溢出，我们是无法直接简单地通过加法来判断减法是否溢出的：</p>

<pre><code class="language-C">int tsub_ok(int x, int y){
    return tadd_ok(x, -y);
}
</code></pre>

<p>当 $x&gt;0,\ y = \text{TMin}_w$ 时，$-y = \text{TMin}_w$，此时一正一负判断为不溢出，然而实际是溢出的。</p>

<h3 id="整数乘法">整数乘法</h3>

<ol>
  <li>
    <p>对于满足 $0\leq x,y &lt; 2^w$ 的整数$x,\ y$ 有:</p>

\[x *_w^u y = (x\cdot y)\ \text{mod}\ 2^w.\]
  </li>
  <li>
    <p>对于满足 $-2^{w-1} \leq x,y \leq 2^{w-1}-1$的整数$x,\ y$，有:</p>

\[x *_w^t y = \text{U2T}_w((x\cdot y)\ \text{mod}\ 2^w).\]
  </li>
</ol>

<p>无符号和补码乘法的位级操作是等价的，即给定长度为$w$的位向量 $\mathbf{x}, \mathbf{y}$，用补码形式来定义整数 $x,y$，用无符号形式来定义整数 $x’, y’$，则有</p>

\[\text{T2B}_w(x *_w^t y) = \text{U2B}_w(x' *_w^u y').\]

<p>检测整数乘法是否溢出的代码如下：</p>

<pre><code class="language-C">int tmult_ok(int x, int y){
    // first way:
    int p = x * y;
    return !x || p/x == y;

    // second way:
    int64_t p = x*y;
    return p == (int)p;
}
</code></pre>

<p>证明思路如下：</p>
<ol>
  <li>$x$和$y$的乘积可以写作 $x\cdot y = p + t2^w$, 计算溢出当且仅当 $t\neq 0$.</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>$p$ 可以写作 $p = xq +r$，其中 $</td>
          <td>r</td>
          <td>&lt;</td>
          <td>x</td>
          <td>$.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>可证明 $q=y$ 当且仅当 $r=t=0$.</li>
</ol>

<p><strong>在分配内存的时候尤其要注意溢出的情况，由此会产生很多安全漏洞！</strong></p>

<h3 id="乘以常数">乘以常数</h3>

<ol>
  <li>C中变量x和k有无符号数$x$和$k$，且 $0\leq k &lt; w$，则有<code class="language-plaintext highlighter-rouge">x&lt;&lt;k</code>得到数值 $x *_w^u 2^k$.</li>
  <li>C中变量x和k有补码值$x$和无符号数$k$，且 $0\leq k &lt; w$，则有<code class="language-plaintext highlighter-rouge">x&lt;&lt;k</code>得到数值 $x *_w^t 2^k$.</li>
</ol>

<p>对于某个常数$K$，编译器会将$K$的二进制表达为一组01序列: $[(0\ldots 0)(1\ldots 1)(0\ldots 0)\ldots(1\ldots 1)]$，考虑一组从位置$n$到位置$m$的连续的1，我们可以用下面两种不同形式的一种来计算这些位对乘积的影响：</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">(x&lt;&lt;n) + (x&lt;&lt;(n-1)) + ... + (x&lt;&lt;m)</code></li>
  <li><code class="language-plaintext highlighter-rouge">(x&lt;&lt;(n+1)) - (x&lt;&lt;m)</code></li>
</ol>

<p>例：</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">x*17 == (x&lt;&lt;4) + x</code></li>
  <li><code class="language-plaintext highlighter-rouge">x*(-7) == x - (x &lt;&lt; 3)</code></li>
  <li><code class="language-plaintext highlighter-rouge">x*60 == (x&lt;&lt;6) + (x&lt;&lt;2)</code></li>
  <li><code class="language-plaintext highlighter-rouge">x*-112 == (x&lt;&lt;4) - (x&lt;&lt;7)</code></li>
</ol>

<h3 id="除以2的幂">除以2的幂</h3>

<ol>
  <li>C中变量x和k有无符号数$x$和$k$，且 $0\leq k &lt; w$，则有<code class="language-plaintext highlighter-rouge">x&gt;&gt;k</code>得到数值 $\lfloor x/2^k \rfloor$.</li>
  <li>C中变量x和k有补码值$x$和无符号数$k$，且 $0\leq k &lt; w$，则有<code class="language-plaintext highlighter-rouge">x&gt;&gt;k</code>得到数值 $\lfloor x/2^k \rfloor$.</li>
</ol>

<p>然而对于负数而言，移位会导致结果向下舍入，但我们更希望向零舍入，此时我们利用<strong>偏移(biasing)</strong>的方法来进行修正：</p>

<p>C中变量x和k有补码值$x$和无符号数$k$，且 $0\leq k &lt; w$，则有<code class="language-plaintext highlighter-rouge">(x+ (1&lt;&lt;k) - 1) &gt;&gt; k</code>得到数值 $\lceil x/2^k \rceil$.</p>

<p>这里利用了性质：对于整数 $x,y(y&gt;0)$，有 $\rceil x/y \rceil = \rfloor (x+y-1)/y \lfloor.$ 由此我们可以写出C语言计算 $x/2^k$的代码</p>

<pre><code class="language-C">(x &lt; 0 ? x + (1&lt;&lt;k) - 1 : x) &gt;&gt; k
</code></pre>

<p>例题：写一个函数计算$x/16$:</p>

<pre><code class="language-C">int bias = (x &gt;&gt; 31) &amp; 0xF;
x = (x + bias) &gt;&gt; 4;
</code></pre>

<p><strong>注意这里利用了算术右移以及掩码的性质。</strong></p>

<h3 id="一些c语言interger-puzzles">一些C语言Interger puzzles</h3>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1. $x&lt;0 \nRightarrow(x*2)&lt;0$</td>
      <td>可能会出现溢出</td>
    </tr>
    <tr>
      <td>2. $ux \geq 0$</td>
      <td>正确</td>
    </tr>
    <tr>
      <td>3. $x \&amp; 7 == 7 \Rightarrow (x«30)&lt;0$</td>
      <td>正确</td>
    </tr>
    <tr>
      <td>4. $ux &gt; -1$是错的</td>
      <td>隐含的int转换为unsigned</td>
    </tr>
    <tr>
      <td>5. $x&gt;y \nRightarrow -x&lt;-y$，注意TMin的情况</td>
      <td>-(Tmin)=TMin</td>
    </tr>
    <tr>
      <td>6. $x*x\geq 0$是错的</td>
      <td>可能会出现溢出</td>
    </tr>
    <tr>
      <td>7. $x&gt;0 \&amp;\&amp; y&gt;0 \nRightarrow x+y &gt; 0 $</td>
      <td>可能会出现溢出</td>
    </tr>
    <tr>
      <td>8. $x\geq 0 \Rightarrow -x\leq 0$</td>
      <td>正确</td>
    </tr>
    <tr>
      <td>9. $x\leq 0 \nRightarrow -x \geq 0$</td>
      <td>TMin</td>
    </tr>
    <tr>
      <td>10. $(x \vert -x)»31 == -1$ 当$x\neq 0$的情况下成立</td>
      <td>正确</td>
    </tr>
    <tr>
      <td>11. $ux»3 == ux/8$</td>
      <td>正确</td>
    </tr>
    <tr>
      <td>12. $x»3 == x/8$ 当$x$为负数的时候不成立</td>
      <td>正确</td>
    </tr>
    <tr>
      <td>13. $x\&amp; (x-1)!=0$当$x==2^k$的时候不成立</td>
      <td>正确</td>
    </tr>
    <tr>
      <td>14. $x+y == ux + uy$</td>
      <td>正确，隐含转换</td>
    </tr>
    <tr>
      <td>15. $x * \sim y + uy*ux == -x$</td>
      <td>~y=-y-1,模数加乘具有交换性</td>
    </tr>
    <tr>
      <td>16. $(x&lt;y) == (-x&gt;-y)$</td>
      <td>注意y=TMin</td>
    </tr>
    <tr>
      <td>17. $((x+y)«4)+y-x = 17<em>y+15</em>x$</td>
      <td><strong>正确</strong>，模数加乘具有交换性</td>
    </tr>
    <tr>
      <td>18. $(ux-uy) == -(unsigned)(y-x)$</td>
      <td><strong>正确</strong></td>
    </tr>
    <tr>
      <td>19. $((x»2)«2) \leq x$</td>
      <td><strong>正确</strong></td>
    </tr>
  </tbody>
</table>

<h2 id="浮点数">浮点数</h2>

<h3 id="ieee浮点表示">IEEE浮点表示</h3>

<p>IEEE浮点标准用 $V=(-1)^s\times M \times 2^E$ 的形式来表示一个数：</p>
<ol>
  <li><strong>符号(sign)</strong>: $s$ 决定这个数是负数$(s=1)还是正数 $(s=0)$，而对于数值0的符号位解释作为特殊情况处理。</li>
  <li><strong>尾数(significand)</strong>: $M$是一个二进制小数，它的范围是 $[1, 2-\epsilon]$或者是 $[0, 1-\epsilon]$。</li>
  <li><strong>阶码(exponent)</strong>: $E$的作用是对浮点数加权，这个权重是2的$E$次幂（可能是负数）。</li>
</ol>

<p>由此将浮点数的位分为三个字段，分别对这些值进行编码：</p>
<ol>
  <li>一个单独的符号位 $s$ 编码符号 $s$，</li>
  <li>$k$ 位的阶码字段exp $=e_{k-1}\ldots e_0$ 编码阶数 $E$，</li>
  <li>$n$ 位小数字段frac $=f_{n-1}\ldots f_0$ 编码尾数 $M$，但是编码出来的值也依赖于阶码字段的值是否为0.</li>
</ol>

<p>在单精度浮点格式中，$s$,exp,frac字段分别为1位，$k=8$位，$n=23$位；在双精度浮点格式中，$s$,exp,frac字段分别为1位，$k=11$位，$n=52$位。</p>

<div align="center"> <img src="/pic/CSAPP/IEEE.png" width="500" /> </div>

<p>给定位表示，根据exp的值，被编码的值分为三种情况：</p>
<ol>
  <li>
    <p><strong>规格化的值</strong>：
 当exp的位模式既不全为0，也不全为1的时候，称为规格化的值，阶码字段被解释为<strong>偏置(<em>bias</em>)形式</strong>表示的有符号整数，阶码的值为 $\mathbf{E=e-bias}$，其中 $e$ 是无符号数，其位表示为 $e_{k-1}\ldots e_1e_0$(1-254,1-2046)，而<em>bias</em>是一个等于 $2^{k-1}-1$ (127,1023)的偏置值。
 由此产生的指数取值范围对于单精度是 $[-126,127]$，对于双精度为 $[-1022,1023]$。</p>

    <p>小数字段frac被解释为描述小数值 $0\leq f &lt; 1$，其二进制表示为 $0.f_{n-1}\ldots f_1f_0$，尾数定义为 $\mathbf{M=1+f}$，这样也叫做<strong>隐含的以1开头的表示(implied leading 1)</strong>，这样我们就可以轻松获得一个额外精度位。</p>
  </li>
  <li>
    <p><strong>非规格化的值</strong>
 当阶码域全为0时，所表示的数是非规格化形式，在这种情况下，阶码值为$\mathbf{E=1-Bias}$，而尾数值为 $\mathbf{M=f}$，也就是不包含隐含的开头的1。</p>

    <p>这种数有两个用途：</p>
    <ol>
      <li>提供了一种表示0的方法，因为使用规格化数必须使 $M\geq 1$,因此我们不能表示0，此时有+0.0和-0.0，在一些数值运算下被认为是不同的。</li>
      <li>非规格化数也用来表示那些非常接近于0.0的数，他们提供了一种属性称为<em>逐渐下溢</em>，其中，可能的数值分布均匀地接近于0.0.</li>
    </ol>
  </li>
  <li>
    <p><strong>特殊值</strong>
当阶码全为1时，如果小数域全为0，表示的则是无穷；如果小数域非零，表示的则是NaN，通常一些运算的结果不能是实数或者无穷的时候就会返回NaN。</p>
  </li>
</ol>

<p>下图是三种情况的位表示图例：</p>
<div align="center"> <img src="/pic/CSAPP/IEEEcate.png" width="500" /> </div>

<h4 id="数字示例">数字示例</h4>

<p>假如我们有8位格式，阶码位 $k=4$ 位，尾数位 $n=3$ 位，则偏置量为 $2^{4-1}-1=7$，部分可能结果如下：</p>
<div align="center"> <img src="/pic/CSAPP/IEEEexample.png" width="700" /> </div>

<p>可以观察到<strong>最大非规格数和最小规格化数之间的平滑转变</strong>，这归功于我们对<strong>非规格化数$E$的定义</strong>。另外，阶数越高，两个数之间的间距越大。</p>

<p>还可以发现，假如我们将浮点数的位表达式解释为无符号整数，那么对于所有正数而言，<strong>它们就是升序排列的</strong>，负数正好相反，IEEE这样设计就是为了浮点数能够使用整数排序函数来进行排序。</p>

<p>这里举一些特殊的值：</p>
<ol>
  <li>值+0.0总有一个全为0的位表示。</li>
  <li>最小的正非规格化值的位表示是最低有效位为1而其他所有位为0构成的，此时尾码值$M=f=2^{-n}$，阶码值 $E=-2^{k-1}+2$，因此 $V=2^{-n-2^{k-1}+2}$。</li>
  <li>最大的正非规格化值的位表示是全为0的阶码字段和最低有效位为1而其他所有位为0构成的，此时尾码值 $M=f=1-2^{-n}$，阶码值 $E=-2^{k-1}+2$，因此 $V=(1-2^{-n})\times 2^{-2^{k-1}+2}$。</li>
  <li>最小的正规格化值的位模式的阶码的最低有效位为1，其他为0，此时尾码值$M=1$，阶码值为 $E=-2^{k-1}+2$，因此 $V=2^{-2^{k-1}+2}$。</li>
  <li>最大的正规格化值的位模式的阶码的最低有效位为0，其他为1，此时尾码值 $M=2-2^{-n}$，阶码值为 $E=2^{k-1}-1$，因此 $V=(2-2^{-n})\times 2^{2^{k-1}-1} = 2^{2^{k-1}}(1-2^{-n-1})$。</li>
  <li>值1.0的位表示的阶码字段除了最高有效位为0外，其他位均为1，尾码字段均为0，此时 $M=1,E=0$。</li>
</ol>

<p>例子：12345具有二进制表示[11000000111001] = $1.1000000111001_2\times 2^{12}$，此时我们丢掉开头的1，并且在末尾加10个0，来构造小数字段，得到二进制表示[10000001110010000000000]，位构造阶码字段，我们用13加上偏置值127得到140，二进制表示为[10001100]，再加上符号位0，就得到了二进制的浮点数表示[0 10001100 10000001110010000000000],观察到整数值二进制[11000000111001]，正好对应于等于1的最高有效位之前（这就是隐含的开头1）。</p>

<p><strong>对于一个具有$n$位小数的浮点格式，不能准确描述的最小正整数为 $2^{n+1}+1$</strong>：当表示到 $2^{n+1}$ 之后，下一个数为 $2^{n+1}+2^{n+1}\times 2^{-n}=2^{n+1}+10$。</p>

<p><strong>能够被准确描述的最大奇整数位 $2^{n+1}-1$</strong>。</p>

<h3 id="舍入">舍入</h3>

<p>舍入共有四种形式：向偶数舍入、向零舍入、向上舍入、向下舍入。</p>

<p>向偶数舍入可以叫做“四舍六入五留双”，例如，可以将1.234999舍入为1.23，1.235001舍入为1.24，1.235000舍入为1.24，因为4是偶数。</p>

<p>同样的，向偶数舍入可以应用到二进制小数上，我们将最低有效位的值0认为是偶数，1认为是奇数。一般来说，只有形如XXXXX.YYYY10000的二进制位模式才会向偶数舍入，其中最右边的Y是被舍入的位置。</p>

<p>例：</p>
<ol>
  <li>$10.010_2\Rightarrow 10.0$</li>
  <li>$10.011_2\Rightarrow 10.1$</li>
  <li>$10.110_2\Rightarrow 11.0$</li>
  <li>$11.001_2\Rightarrow 11.0$</li>
</ol>

<h3 id="浮点运算">浮点运算</h3>

<p>前面我们看到了整数加法形成了阿贝尔群，实数的加法同样如此，但是我们要考虑舍入的影响。我们定义 $x+^f y = \text{Round}(x+y)$。</p>

<p>加法运算过程：$(-1)^{s_1}M_12^{E_1} +^f (-1)^{s_2}M_2 2^{E_2} \rightarrow (-1)^sM2^E(E_1\geq E_2)$:</p>
<ol>
  <li>$S,M$位对齐后的加法，$E=E_1$.</li>
  <li>如果$M\geq 2$，$M$右移一位，$E$加1.</li>
  <li>如果$M&lt;1$，$M$左移$k$位，$E$减$k$.</li>
  <li>如果$E$超出范围则溢出，</li>
  <li>舍入到frac精度范围。</li>
</ol>

<p>可以看到它有以下性质：</p>
<ol>
  <li>运算是可交换的，即$x+^f y = y +^f x$，</li>
  <li>运算是<strong>不可结合</strong>的，例如$(3,14+1e10)-1e10=0.0,\ 3.14+(1e10-1e10)=3.14$，</li>
  <li>大多数值在浮点加法下存在逆元，但是无穷和NaN是例外，</li>
  <li>浮点加法满足单调性：如果$a\geq b$，那么除了NaN，对于任何$x$的值都有$x+a\geq x+b$。<strong>整数加法是不具备这个性质的</strong>，</li>
  <li>0是加法的单位元。</li>
</ol>

<p>浮点数乘法的定义也是类似的$x\times^fy=\text{Round}(x\times y)$，浮点乘法有以下性质：</p>
<ol>
  <li>乘法是封闭的，是可交换的，有乘法单位元1.0，</li>
  <li>不可结合的，例如$(1e20<em>1e20)</em>1e-20$为正无穷，而$1e20<em>(1e20</em>1e-20)$为$1e20$.</li>
  <li>对于加法没有分配性，例如$1e20<em>1e20-1e20</em>1e20$会得到NaN，</li>
  <li>对于任何$a,b,c$，并且都不为NaN，则乘法也满足单调性。</li>
</ol>

<h3 id="c语言中的浮点数">C语言中的浮点数</h3>

<ol>
  <li>int转换为double，数字不会溢出但是可能被舍入。</li>
  <li>int或float转换为double，能够保留精确数值。</li>
  <li>double转换成float，可能会溢出，也可能会舍入。</li>
  <li>float或double转换为int，如果没有溢出的话，<strong>值会向零舍入</strong>。</li>
</ol>

<p>例子：x,f,d分别为int, float, double.</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">x==(int)(double)x</code></li>
  <li><code class="language-plaintext highlighter-rouge">x!=(int)(float)x</code></li>
  <li><code class="language-plaintext highlighter-rouge">d != (double)(float)d</code></li>
  <li><code class="language-plaintext highlighter-rouge">f == (float)(double)f</code></li>
  <li><code class="language-plaintext highlighter-rouge">f == -(-f)</code></li>
  <li><code class="language-plaintext highlighter-rouge">1.0/2 = 1/2.0</code></li>
  <li><code class="language-plaintext highlighter-rouge">d*d&gt;=0</code></li>
  <li><code class="language-plaintext highlighter-rouge">(f+d)-f != d</code>：浮点加法不存在结合律（后面的-f无法移动到前边）</li>
  <li><code class="language-plaintext highlighter-rouge">d&gt;f =&gt; -d &lt; -f</code></li>
</ol>

<p>x,y,z为int，dx,dy,dz = (double)x,y,z.</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">(float) x == (float)dx</code>  dx保留了x的所有精度，所以转化为float是一样的。</li>
  <li><code class="language-plaintext highlighter-rouge">dx-dy == (double)(x-y)</code> <strong>错误</strong>，x-y有可能会溢出</li>
  <li><code class="language-plaintext highlighter-rouge">(dx+dy)+dz == dx+(dy+dz)</code> <strong>正确</strong>，因为三个int相加不会出现舍入误差</li>
  <li><code class="language-plaintext highlighter-rouge">(dx*dy)*dz == dx*(dy*dz)</code> <strong>正确</strong></li>
  <li><code class="language-plaintext highlighter-rouge">dx/dx == dz/dz</code> <strong>错误</strong>，当dx为0，dz不为0的时候不相等。</li>
</ol>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="CSAPP" /><summary type="html"><![CDATA[信息的表示和处理]]></summary></entry><entry><title type="html">CSAPP-1:家庭作业以及Data Lab要点</title><link href="http://localhost:4000/2023/11/24/CSAPP-hm1/" rel="alternate" type="text/html" title="CSAPP-1:家庭作业以及Data Lab要点" /><published>2023-11-24T14:23:00+08:00</published><updated>2023-11-24T14:23:00+08:00</updated><id>http://localhost:4000/2023/11/24/CSAPP-hm1</id><content type="html" xml:base="http://localhost:4000/2023/11/24/CSAPP-hm1/"><![CDATA[<h2 id="信息存储">信息存储</h2>

<ol>
  <li>
    <p>将一个$w$位的字中的字节0(最低位)开始编号，并将参数$x$的字节$i$替换为字节$b$，<strong>要考虑大小端</strong>：</p>

    <pre><code class="language-C"> unsigned replace_byte(unsigned x, int i, unsigned char b)
 {
     unsigned int *p = &amp;x;
     unsigned char *v = (unsigned char *) p;
        
     if (is_little_endian())
         v[i] = b;
     else 
         v[sizeof(unsigned) - i - 1] = b;
        
     return *p;
 }

 int is_little_endian(void)
 {
     int n = 1;
     int *p = &amp;n;
     int *v = (void *) p;
        
     if (*v == 0x01)
         return 1;
     else
         return 0;
 }
</code></pre>
  </li>
  <li>判断表达式是否满足以下任一条件： <strong>通过逻辑反的判断来确保任何结果都是对的</strong>
    <ol>
      <li>$x$的任何位都为1                <code class="language-plaintext highlighter-rouge">!(x ^ 0xffffffff)</code></li>
      <li>$x$的任何位都为0                <code class="language-plaintext highlighter-rouge">!(x ^ 0x0)</code></li>
      <li>$x$的最低有效字节的位都为1       <code class="language-plaintext highlighter-rouge">!((x &amp; 0xff) ^ 0xff)</code></li>
      <li>$x$的最低有效字节的位都为0       <code class="language-plaintext highlighter-rouge">!((x &amp; 0xff) ^ 0x0)</code></li>
    </ol>
  </li>
  <li>
    <p>判断机器是否为算术右移：</p>

    <pre><code class="language-C"> int int_shifts_are_arithmetic()
 {
     int n = -1;
     int shifts = (n&gt;&gt;2);
     return shifts == n;
 }
</code></pre>
  </li>
  <li>
    <p>用算术右移来完成逻辑右移以及用逻辑右移完成算术右移，后面其他操作不能包含右移和除法。
在实现算术右移的时候注意 <strong>如何判断x的最高位是否为1</strong></p>

    <pre><code class="language-C"> // 算术右移到逻辑右移
 unsigned srl(unsigned x, int k)
 {
     /* perform shift arithmetically */
     unsigned xsra = (int) x &gt;&gt; k;
        
     int mask = -1;
        
     mask = mask &lt;&lt; ((sizeof(int) &lt;&lt; 3) - k);
     return ~mask &amp; xsra;
 }

 unsigned sra(int x, int k)
 {
     /* perform shift logically */
     int xsrl = (unsigned) x &gt;&gt; k;
        
     unsigned mask = 1;
     int *p = &amp;x;
     char *temp = (void *) p;
        
     // 判断x的最高位是否为1
     int h = (((mask &lt;&lt; 7) &amp; temp[sizeof(int) - 1]) == 128);
        
     h = (-h) &lt;&lt; ((sizeof(int) &lt;&lt; 3) - k);
     return h | xsrl;
 }
</code></pre>
  </li>
  <li>
    <p>判断是否$x$的任一奇数位为1：<code class="language-plaintext highlighter-rouge">!(x &amp; 0x55555555)</code>. <strong>这里要用<code class="language-plaintext highlighter-rouge">&amp;</code>是因为避免$x$偶数位的影响。</strong></p>
  </li>
  <li>
    <p>判断$x$的位表示中是否有奇数个1：</p>

    <pre><code class="language-C"> int odd_ones(unsigned x)
 {
     x ^= x &gt;&gt; 1;
     x ^= x &gt;&gt; 2;
     x ^= x &gt;&gt; 4;
     x ^= x &gt;&gt; 8;
     x ^= x &gt;&gt; 16;
     return x &amp; 0x1;
 }
</code></pre>

    <p>第一次异或的结果，第$i$个位置上是1代表原数中第$i$位和第$i+1$位有一个为1，也就是奇数个1。也就是说，某个位为1，代表从它开始向左连续两位中1的个数是奇数（异或的本质）。第二次异或，就是两位两位的比较了，比如，若结果第6位为1，那么代表上一次的结果的第6位和第8位有奇数个1，也就是原数中第6,7,8,9位中有奇数个1。
 <strong>整个过程就是不断的压缩信息。</strong></p>
  </li>
  <li>
    <p>得到暗示x最左侧的1的掩码，例如<code class="language-plaintext highlighter-rouge">0xFF00 -&gt; 0x8000</code></p>

    <pre><code class="language-C"> int leftmost_one(unsigned int x)
 {
     unsigned int base = 0x80000000;
     while(base)
     {
         if((x &amp; base))
             break;
         base &gt;&gt;= 1;
     }
 }
</code></pre>

    <p>这样做可以返回<code class="language-plaintext highlighter-rouge">0x8000</code>，但是没有涉及到掩码：</p>

    <pre><code class="language-C"> int leftmost_one(unsigned x)
 {
     x |= x &gt;&gt; 1;
     x |= x &gt;&gt; 2;
     x |= x &gt;&gt; 4;
     x |= x &gt;&gt; 8;
     x |= x &gt;&gt; 16;
     return (x &amp; (~(x &gt;&gt; 1)));
 }
</code></pre>

    <p>假设此时的字长$w$ = 8，假设 <code class="language-plaintext highlighter-rouge">x = 00010110</code>，首先<strong>前五步将$x$最左侧的1的右侧全置为1</strong>，得到<code class="language-plaintext highlighter-rouge">0x00011111</code>，在此基础上右移一位再取反就可以得到掩码了。</p>
  </li>
  <li>
    <p>得到最低侧$n$位均为1的值：<code class="language-plaintext highlighter-rouge">-1 &gt;&gt; (w-n)</code><strong>注意当$n=w$的情况，此时右移$n$位的实际操作是不变</strong></p>
  </li>
  <li>
    <p>将$x$的最高$n$位交换到末尾，例如: <code class="language-plaintext highlighter-rouge">n=4, x=0x12345678 -&gt; 0x23456781</code></p>

    <pre><code class="language-C"> unsigned rotate_left(unsigned x, int n)
 {
     int w = sizeof(int) &lt;&lt; 3;
     unsigned temp = x &gt;&gt; (w - n - 1) &gt;&gt; 1;
        
     return (x &lt;&lt; n) + temp;
 }
</code></pre>
  </li>
  <li>
    <p>判断一个数能否用$n$位补码来表示：</p>

    <p><strong>正数需要要求第$n$位不为1，例如2是无法用2位来表示的。</strong>
<strong>负数要求$n$到$w$位均为1才可以。</strong></p>

    <pre><code class="language-C">int fits_bits(int x, int n)
{
    int neg = x &gt;&gt; (n - 1); //考虑算术右移
    int pos = x &gt;&gt; (n - 1); 
    return neg == -1 || pos == 0;
}
</code></pre>
  </li>
  <li>$a^k$表示$a$重复$k$次，假设一个$w$位的类型，如何不适用$w$得到以下数值
    <ol>
      <li>$1^{w-k}0^{k}$:             <code class="language-plaintext highlighter-rouge">(-1) &lt;&lt; k</code></li>
      <li>$0^{w-k-j}1^k0^j$:          <code class="language-plaintext highlighter-rouge">a = -1 &lt;&lt; (k-j), b = -1 &lt;&lt; j,  ~(a|~b)</code></li>
    </ol>
  </li>
</ol>

<h2 id="整数运算">整数运算</h2>

<ol>
  <li>
    <p>符号整数饱和加法（正溢出返回TMax，负溢出返回TMin）以及对应的判断减法是否溢出（<strong>注意y=TMin的情况</strong>）</p>

    <pre><code class="language-C"> int asturating_add(int x, int y)
 {
     int sum = x + y;
     int w = sizeof(int) &lt;&lt; 3;
        
     // x, y, sum的最高位
     int h_x = (unsigned) x &gt;&gt; (w - 1);
     int h_y = (unsigned) y &gt;&gt; (w - 1);
     int h_sum = (unsigned) sum &gt;&gt; (w - 1);
        
     // neg = 1 表示负溢出， pos = 1 表示正溢出
     int neg = h_x &amp;&amp; h_y &amp;&amp; !h_sum;
     int pos = !h_x &amp;&amp; !h_y &amp;&amp; h_sum;
        
     return (-neg &amp; INT_MIN) + (-pos &amp; INT_MAX);
 }

 int tsub_ok(int x, int y)
 {
     if(y == INT_MIN){
         return x &lt; 0;
     }
     int temp = asturating_add(x, -y);
     return temp != INT_MIN &amp;&amp; temp != INT_MAX;
 }
</code></pre>
  </li>
  <li>
    <p>假设我们已有用于计算$x$和$y$采用补码形式下$x\cdot y$的高$w$位的函数</p>

    <pre><code class="language-C"> int signed_high_prod(int x, int y);
</code></pre>
    <p>现在计算无符号变量$x\cdot y$的高$w$位：</p>

    <p>这里用到$x’\cdot y’ = x\cdot y + (x_{w-1}y+y_{w-1}x)2^w + x_{w-1}y_{w-1}2^{2w}$.</p>

    <pre><code class="language-C"> int signed_high_prod(int x, int y) 
 {
 int64_t mul = (int64_t) x * y;
 return mul &gt;&gt; 32;
 }

 unsigned unsigned_high_prod(unsigned x, unsigned y)
 {
     int w = sizeof(int) &lt;&lt; 3;
     int x_highest_bit = x &gt;&gt; w - 1;
     int y_highest_bit = y &gt;&gt; w - 1;
     return signed_high_prod(x, y) + (-y_highest_bit &amp; x) + (-x_highest_bit &amp; y);
 }
</code></pre>
  </li>
  <li>
    <p>实现<code class="language-plaintext highlighter-rouge">calloc</code>函数为一个数组分配内存，该数组有nmemb个元素，每个元素size字节：<strong>判断是否发生溢出！</strong></p>

    <pre><code class="language-C"> void *calloc(size_t nmemb, size_t size)
 {
     if (nmemb == 0 || size == 0)
         return NULL;
     size_t bytes = nmemb * size;
     if (nmemb == bytes / size) // 判断是否溢出
     {
         void* ptr = malloc(bytes);
         memset(ptr, 0, bytes);
         return ptr;
     }
     return NULL;
 }
</code></pre>
  </li>
  <li>
    <p>实现整数除以2的幂数：
<strong>如何不适用判断来做到合理偏置（-1\0 &amp; mask）</strong></p>

    <pre><code class="language-C"> int divide_power2(int x, int k)
 {
     int sign = (x &amp; INT_MIN) == INT_MIN;
     int mask = (1 &lt;&lt; k) - 1;
     int bias = -sign &amp; mask;
        
     return (x + bias) &gt;&gt; k;
 }
</code></pre>
  </li>
  <li>
    <p>对于整数参数$x$，分两种方式计算$3*x/4$的值：1.会出现溢出；2.向零舍入，不会溢出。
<strong>不溢出就需要用更大的类型来存储，计算完毕后再进行舍入。</strong></p>

    <pre><code class="language-C"> int mul3div4(int x)
 {
     int result = (x &lt;&lt; 1) + x;
     return divide_power2(result, 2);
 }

 int threefourths(int x)
 {
     int64_t result = ((int64_t) x &lt;&lt; 1) + x;
     int sign = (x &amp; INT_MIN) == INT_MIN;
     int mask = (1 &lt;&lt; 2) - 1;
     int bias = -sign &amp; mask;
     return (result + bias) &gt;&gt; 2;
 }

</code></pre>
  </li>
</ol>

<h2 id="浮点数运算">浮点数运算</h2>

<ol>
  <li>实现浮点数小于号判断（假设两个参数都不是NaN）：
    <ol>
      <li>+0.0等于-0.0</li>
      <li>考虑NaN（默认比任何数都大）</li>
      <li>考虑正负号</li>
      <li>正数升序，负数降序（正负无穷也可以按照此规律）</li>
    </ol>

    <pre><code class="language-C"> unsigned f2u(float x) 
 {
 return *(unsigned*)&amp;x;
 }

 int float_le(float x, float y) 
 {
 unsigned ux = f2u(x);
 unsigned uy = f2u(y);

 unsigned sx = ux &gt;&gt; 31;
 unsigned sy = uy &gt;&gt; 31;
    
 return (ux &lt;&lt; 1 == 0 &amp;&amp; uy &lt;&lt; 1 == 0) ||
         (sx &gt; sy) ||
         (sx &amp;&amp; sy &amp;&amp; ux &gt;= uy) ||
         (!sx &amp;&amp; !sy &amp;&amp; ux &lt;= uy);
 }
</code></pre>
  </li>
  <li>
    <p>实现$2^x$的浮点表示：</p>

    <pre><code class="language-C"> float u2f(unsigned u)
 {
     return *(float *) &amp;u;
 }
 float fpwr2(int x)
 {
     /* Result exponent and fraction */
     unsigned exp, frac;
     unsigned u;
     if (x &lt; -126 - 23)
     {
         /* Too small. Return 0.0 */
         exp = 0;
         frac = 0;
     }
     else if (x &lt; -126)
     {
         /* Denormalized result */
         exp = 0;
         frac = 1 &lt;&lt; (23 + x + 126);
     }
     else if (x &lt; 128)
     {
         /* Normalized result. */
         exp = x + 127;
         frac = 0;
     }
     else
     {
         /* Too big. Return +oo */
         exp = 255;
         frac = 0;
     }
     /* Pack exp and frac into 32 bits */
     u = exp &lt;&lt; 23 | frac;
     return u2f(u);
 }
</code></pre>
  </li>
  <li>
    <p>实现对一个浮点数求相反数：
 <strong>关键是符号，阶码，尾码的获取与重组</strong></p>

    <pre><code class="language-C"> typedef unsigned float_bits;
    
 /* Compute -f. If f is NaN, then return f. */
 float_bits float_negate(float_bits f)
 {
     float_bits sign, exp, frac;
        
     sign = f &gt;&gt; 31;
     exp = f &gt;&gt; 23 &amp; 0xff;
     frac = f &amp; 0x7fffff;
        
     if (exp == 0xff &amp;&amp; frac)
         return f;
     else
         return (~sign &lt;&lt; 31) | (exp &lt;&lt; 23) | frac;
 }
</code></pre>
  </li>
  <li>
    <p>实现浮点数绝对值函数：</p>

    <pre><code class="language-C"> float_bits float_absval(float_bits f)
 {
     float_bits exp, frac;
        
     exp = f &gt;&gt; 23 &amp; 0xff;
     frac = f &amp; 0x7fffff;
        
     if (exp == 0xff &amp;&amp; frac)
         return f;
     else
         return 0 &lt;&lt; 31 | (exp &lt;&lt; 23) | frac;
 }
</code></pre>
  </li>
  <li>实现$2.0*f$：
    <ol>
      <li>考虑NaN</li>
      <li>考虑非规格化： <strong>frac左移一位就相当于exp最低位有1</strong></li>
      <li>考虑2f溢出的情况，即exp=0xff或0xff-1</li>
      <li>考虑规格化</li>
    </ol>

    <pre><code class="language-C"> float_bits float_twice(float_bits f)
 {
     float_bits sign, exp, frac;
        
     sign = f &gt;&gt; 31;
     exp = f &gt;&gt; 23 &amp; 0xff;
     frac = f &amp; 0x7fffff;
        
     if (exp == 0xff &amp;&amp; frac)
         return f;
        
     if (exp == 0)  // 非规格化的值
         frac &lt;&lt;= 1;
     else if (exp == 0xff - 1)  //无穷大时
     {
         frac = 0;
         exp = 0xff;
     }
     else
         exp += 1;
        
     return (sign &lt;&lt; 31) | (exp &lt;&lt; 23) | frac;
 }
</code></pre>
  </li>
  <li>实现$0.5*f$：
    <ol>
      <li>考虑NaN</li>
      <li>考虑非规格化时的舍入 <strong>学习如何向偶数舍入（只有11的情况才需要+1）</strong></li>
      <li>考虑exp=1 <strong>抛开符号位，整体右移一位再舍入</strong></li>
      <li>考虑其他规格化情况</li>
    </ol>

    <pre><code class="language-C"> float_bits float_half(float_bits f)
 {
     float_bits sign, exp, frac, rest;
        
     sign = f &gt;&gt; 31;
     exp = f &gt;&gt; 23 &amp; 0xff;
     frac = f &amp; 0x7fffff;
     rest = f &amp; 0x7FFFFFFF;
        
     if (exp == 0xff)
         return f;
        
     /* 向偶数舍入
     * round to even, we care about last 2 bits of frac
     *
     * 00 =&gt; 0 just &gt;&gt;1
     * 01 =&gt; 0 (round to even) just &gt;&gt;1
     * 10 =&gt; 1 just &gt;&gt;1
     * 11 =&gt; 1 + 1 (round to even) just &gt;&gt;1 and plus 1
     */
     int addition = (frac &amp; 0x3) == 0x3;

     if (exp == 0) {
         /* Denormalized */
         frac &gt;&gt;= 1;
         frac += addition;
     } else if (exp == 1) {
         /* Normalized to denormalized */
         rest &gt;&gt;= 1;
         rest += addition;
         exp = rest &gt;&gt; 23 &amp; 0xFF;
         frac = rest &amp; 0x7FFFFF;
     } else {
         /* Normalized */
         exp -= 1;
     }

     return (sign &lt;&lt; 31) | (exp &lt;&lt; 23) | frac;
 }
</code></pre>
  </li>
  <li>实现float到int的转换，向零舍入，如果超出表示范围则返回0x80000000：
    <ol>
      <li>考虑溢出或者NaN（<strong>int 最大只能表示$2^{31}$</strong>）</li>
      <li>当exp &lt; bias时，浮点数f的绝对值小于1，直接返回0</li>
      <li>此时bias &lt;= exp &lt; 31+bias, 即 0 &lt;= E &lt; 31 时，由于浮点数小数部分只有23位，此时分为两种情况：
        <ol>
          <li>E &gt; 23 时，rest 左移 E-23位</li>
          <li>E &lt;= 23 时，rest 右移 23-E位（<strong>将精确数字舍去一部分就是向零舍入</strong>）</li>
        </ol>
      </li>
    </ol>

    <pre><code class="language-C"> int float_f2i(float_bits f)
 {
     float_bits sign, exp, frac;
     float_bits M, E, bias;
        
     sign = f &gt;&gt; 31;
     exp = f &gt;&gt; 23 &amp; 0xff;
     frac = f &amp; 0x7fffff;
     bias = 0x7f;
        
     if (exp&gt;= 31 + bias || exp == 0xff)  // overflow or f is NaN
         return 0x80000000;
     else if (exp &lt; bias)  // 结果小于1
         return 0;
     else
     {
         M = frac | 0x800000;
         E = exp - bias;
         if (E &gt; 23)
             return pow(-1, sign) * (M &lt;&lt; (E - 23));
         else
             return pow(-1, sign) * (M &gt;&gt; (23 - E));
     }
 }
</code></pre>
  </li>
  <li>实现int到float的转换：
    <ol>
      <li>0直接返回</li>
      <li>如果是负数，先确定sign，然后取反+1获得其绝对值</li>
      <li><strong>算出最左侧的1在第k位，则exp = k+bias</strong></li>
      <li>如果k &gt; 23，<strong>需要考虑如何舍入</strong>：
        <ol>
          <li>截断的部分大于截断的一半，向上舍入</li>
          <li>截断的部分等于截断的一半，向偶数舍入 <strong>i&amp;hide == hide是判断某一位是否为1，与判断符号数是否是负数一样</strong></li>
          <li>截断的部分小于截断的一半，向下舍入</li>
        </ol>
      </li>
    </ol>

    <pre><code class="language-C"> float_bits float_i2f(int i)
 {
         unsigned sign, exp, frac;
         unsigned leftmost, rightmost, t;

         if (i == 0)
                 return i;

         sign = (i &amp; INT_MIN) == INT_MIN;
         if (sign)
                 i = ~i + 1;
         for (rightmost = 1, t = INT_MIN; (t &amp; i) != t; t &gt;&gt;= 1)
                 rightmost++;
         leftmost = (sizeof(int) &lt;&lt; 3) - rightmost; //最左侧的1的位置
         exp = leftmost + 127;

         int shift;
         if (leftmost &gt; 23) { // 考虑舍入
                 shift = leftmost - 23;
                 int mask = ((1 &lt;&lt; shift) - 1) &amp; i;
                 int half = 1 &lt;&lt; (shift - 1);
                 int hide = 1 &lt;&lt; shift;
                 //mask == half时只有舍入位为1时才加1
                 int round = mask&gt;half || (mask==half &amp;&amp; (i&amp;hide)==hide); 
                 frac = (i &gt;&gt; shift) &amp; 0x7FFFFF; //考虑算术右移的影响
                 if (frac == 0x7FFFFF &amp;&amp; round == 1) //+1有可能导致进位
                         frac = 0, exp++;
                 else
                         frac += round;
         } else { // 补满23位
                 shift = 23 - leftmost;
                 frac = (i &lt;&lt; shift) &amp; 0x7FFFFF;
         }

         return (sign &lt;&lt; 31) | (exp &lt;&lt; 23) | frac;
 }
</code></pre>
  </li>
</ol>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="CSAPP" /><summary type="html"><![CDATA[信息存储]]></summary></entry><entry><title type="html">A Good start</title><link href="http://localhost:4000/2023/11/04/A-good-start/" rel="alternate" type="text/html" title="A Good start" /><published>2023-11-04T21:43:00+08:00</published><updated>2023-11-04T21:43:00+08:00</updated><id>http://localhost:4000/2023/11/04/A-good-start</id><content type="html" xml:base="http://localhost:4000/2023/11/04/A-good-start/"><![CDATA[<p>之后会在这个主页上更新自己学习的总结。</p>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="life" /><summary type="html"><![CDATA[之后会在这个主页上更新自己学习的总结。]]></summary></entry></feed>