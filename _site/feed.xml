<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2024-11-08T23:41:02+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Liujiyu’s blog</title><subtitle>learn &amp; record</subtitle><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><entry><title type="html">设计模式</title><link href="http://localhost:4000/2024/10/27/DesignPattern/" rel="alternate" type="text/html" title="设计模式" /><published>2024-10-27T10:00:00+08:00</published><updated>2024-10-27T10:00:00+08:00</updated><id>http://localhost:4000/2024/10/27/DesignPattern</id><content type="html" xml:base="http://localhost:4000/2024/10/27/DesignPattern/"><![CDATA[<h3 id="一创建型模式">一、创建型模式</h3>

<p><strong>1. 单例模式（Singleton Pattern）</strong></p>

<p><strong>概念：</strong>
确保一个类只有一个实例，并提供一个全局访问点。</p>

<p><strong>应用场景：</strong></p>
<ul>
  <li>需要全局唯一的对象，例如日志记录器、线程池、配置管理器等。</li>
</ul>

<p><strong>示例：</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Logger</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="k">static</span> <span class="n">Logger</span><span class="o">*</span> <span class="n">instance</span><span class="p">;</span>
    <span class="n">Logger</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// 私有构造函数，防止外部实例化</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="n">Logger</span><span class="o">*</span> <span class="n">getInstance</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">instance</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Logger</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">log</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Log: "</span> <span class="o">&lt;&lt;</span> <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 初始化静态成员</span>
<span class="n">Logger</span><span class="o">*</span> <span class="n">Logger</span><span class="o">::</span><span class="n">instance</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

<span class="c1">// 使用示例</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Logger</span><span class="o">*</span> <span class="n">logger1</span> <span class="o">=</span> <span class="n">Logger</span><span class="o">::</span><span class="n">getInstance</span><span class="p">();</span>
    <span class="n">Logger</span><span class="o">*</span> <span class="n">logger2</span> <span class="o">=</span> <span class="n">Logger</span><span class="o">::</span><span class="n">getInstance</span><span class="p">();</span>

    <span class="n">logger1</span><span class="o">-&gt;</span><span class="n">log</span><span class="p">(</span><span class="s">"This is a log message."</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">logger1</span> <span class="o">==</span> <span class="n">logger2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Logger1 and Logger2 are the same instance."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Logger1 and Logger2 are different instances."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>运行结果：</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Log: This is a log message.
Logger1 and Logger2 are the same instance.
</code></pre></div></div>

<hr />

<p><strong>2. 工厂方法模式（Factory Method Pattern）</strong></p>

<p><strong>概念：</strong>
定义一个创建对象的接口，但由子类决定要实例化的类是哪一个。</p>

<p><strong>应用场景：</strong></p>
<ul>
  <li>需要在不指定具体类的情况下创建对象。</li>
  <li>客户端不需要知道所创建对象的类。</li>
</ul>

<p><strong>示例：</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Product</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">use</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ConcreteProductA</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Product</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">use</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Using Product A"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ConcreteProductB</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Product</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">use</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Using Product B"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Factory</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="n">Product</span><span class="o">*</span> <span class="n">createProduct</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">FactoryA</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Factory</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Product</span><span class="o">*</span> <span class="n">createProduct</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">ConcreteProductA</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">FactoryB</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Factory</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Product</span><span class="o">*</span> <span class="n">createProduct</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">ConcreteProductB</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 使用示例</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Factory</span><span class="o">*</span> <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FactoryA</span><span class="p">();</span>
    <span class="n">Product</span><span class="o">*</span> <span class="n">product</span> <span class="o">=</span> <span class="n">factory</span><span class="o">-&gt;</span><span class="n">createProduct</span><span class="p">();</span>
    <span class="n">product</span><span class="o">-&gt;</span><span class="n">use</span><span class="p">();</span>

    <span class="k">delete</span> <span class="n">product</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">factory</span><span class="p">;</span>

    <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FactoryB</span><span class="p">();</span>
    <span class="n">product</span> <span class="o">=</span> <span class="n">factory</span><span class="o">-&gt;</span><span class="n">createProduct</span><span class="p">();</span>
    <span class="n">product</span><span class="o">-&gt;</span><span class="n">use</span><span class="p">();</span>

    <span class="k">delete</span> <span class="n">product</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">factory</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>运行结果：</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Using Product A
Using Product B
</code></pre></div></div>

<hr />

<p><strong>3. 抽象工厂模式（Abstract Factory Pattern）</strong></p>

<p><strong>概念：</strong>
提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>

<p><strong>应用场景：</strong></p>
<ul>
  <li>需要创建一组相关或相互依赖的对象。</li>
  <li>系统需要独立于产品的创建方式。</li>
</ul>

<p><strong>示例：</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="c1">// 抽象产品：按钮</span>
<span class="k">class</span> <span class="nc">Button</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 具体产品：Windows风格按钮</span>
<span class="k">class</span> <span class="nc">WinButton</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Button</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Draw a Windows Button."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 具体产品：Mac风格按钮</span>
<span class="k">class</span> <span class="nc">MacButton</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Button</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Draw a Mac Button."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 抽象工厂</span>
<span class="k">class</span> <span class="nc">GUIFactory</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="n">Button</span><span class="o">*</span> <span class="n">createButton</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 具体工厂：Windows工厂</span>
<span class="k">class</span> <span class="nc">WinFactory</span> <span class="o">:</span> <span class="k">public</span> <span class="n">GUIFactory</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Button</span><span class="o">*</span> <span class="n">createButton</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">WinButton</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 具体工厂：Mac工厂</span>
<span class="k">class</span> <span class="nc">MacFactory</span> <span class="o">:</span> <span class="k">public</span> <span class="n">GUIFactory</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Button</span><span class="o">*</span> <span class="n">createButton</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">MacButton</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 使用示例</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">GUIFactory</span><span class="o">*</span> <span class="n">factory</span><span class="p">;</span>
    <span class="n">Button</span><span class="o">*</span> <span class="n">button</span><span class="p">;</span>

    <span class="c1">// 假设我们需要创建Windows风格的UI组件</span>
    <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WinFactory</span><span class="p">();</span>
    <span class="n">button</span> <span class="o">=</span> <span class="n">factory</span><span class="o">-&gt;</span><span class="n">createButton</span><span class="p">();</span>
    <span class="n">button</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">();</span>

    <span class="k">delete</span> <span class="n">button</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">factory</span><span class="p">;</span>

    <span class="c1">// 创建Mac风格的UI组件</span>
    <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MacFactory</span><span class="p">();</span>
    <span class="n">button</span> <span class="o">=</span> <span class="n">factory</span><span class="o">-&gt;</span><span class="n">createButton</span><span class="p">();</span>
    <span class="n">button</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">();</span>

    <span class="k">delete</span> <span class="n">button</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">factory</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>运行结果：</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Draw a Windows Button.
Draw a Mac Button.
</code></pre></div></div>

<hr />

<p><strong>4. 建造者模式（Builder Pattern）</strong></p>

<p><strong>概念：</strong>
将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</p>

<p><strong>应用场景：</strong></p>
<ul>
  <li>需要创建复杂对象，其构建过程独立于部件的组成。</li>
  <li>需要创建不同表示的对象。</li>
</ul>

<p><strong>示例：</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Product</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">setPartA</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">partA</span><span class="p">)</span> <span class="p">{</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">partA</span> <span class="o">=</span> <span class="n">partA</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">setPartB</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">partB</span><span class="p">)</span> <span class="p">{</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">partB</span> <span class="o">=</span> <span class="n">partB</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">setPartC</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">partC</span><span class="p">)</span> <span class="p">{</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">partC</span> <span class="o">=</span> <span class="n">partC</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">show</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Product Parts: "</span> <span class="o">&lt;&lt;</span> <span class="n">partA</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">partB</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">partC</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">partA</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">partB</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">partC</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Builder</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">buildPartA</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">buildPartB</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">buildPartC</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">Product</span><span class="o">*</span> <span class="n">getResult</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ConcreteBuilder</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Builder</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">Product</span><span class="o">*</span> <span class="n">product</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">ConcreteBuilder</span><span class="p">()</span> <span class="p">{</span> <span class="n">product</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Product</span><span class="p">();</span> <span class="p">}</span>
    <span class="o">~</span><span class="n">ConcreteBuilder</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">product</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">buildPartA</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">product</span><span class="o">-&gt;</span><span class="n">setPartA</span><span class="p">(</span><span class="s">"Part A"</span><span class="p">);</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">buildPartB</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">product</span><span class="o">-&gt;</span><span class="n">setPartB</span><span class="p">(</span><span class="s">"Part B"</span><span class="p">);</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">buildPartC</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">product</span><span class="o">-&gt;</span><span class="n">setPartC</span><span class="p">(</span><span class="s">"Part C"</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">Product</span><span class="o">*</span> <span class="n">getResult</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">product</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Director</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">construct</span><span class="p">(</span><span class="n">Builder</span><span class="o">*</span> <span class="n">builder</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">builder</span><span class="o">-&gt;</span><span class="n">buildPartA</span><span class="p">();</span>
        <span class="n">builder</span><span class="o">-&gt;</span><span class="n">buildPartB</span><span class="p">();</span>
        <span class="n">builder</span><span class="o">-&gt;</span><span class="n">buildPartC</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 使用示例</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Director</span> <span class="n">director</span><span class="p">;</span>
    <span class="n">Builder</span><span class="o">*</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcreteBuilder</span><span class="p">();</span>
    <span class="n">director</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">builder</span><span class="p">);</span>
    <span class="n">Product</span><span class="o">*</span> <span class="n">product</span> <span class="o">=</span> <span class="n">builder</span><span class="o">-&gt;</span><span class="n">getResult</span><span class="p">();</span>
    <span class="n">product</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">();</span>

    <span class="k">delete</span> <span class="n">builder</span><span class="p">;</span> <span class="c1">// 注意，这里删除builder时也会删除product</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>运行结果：</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Product Parts: Part A, Part B, Part C
</code></pre></div></div>

<hr />

<h3 id="二结构型模式">二、结构型模式</h3>

<p><strong>1. 适配器模式（Adapter Pattern）</strong></p>

<p><strong>概念：</strong>
将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的类可以协同工作。</p>

<p><strong>应用场景：</strong></p>
<ul>
  <li>需要使用一个已有的类，而它的接口不符合需求。</li>
  <li>希望创建一个可重用的类，用于与一些彼此之间没有太大关联的类一起工作。</li>
</ul>

<p><strong>示例：</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="c1">// 目标接口</span>
<span class="k">class</span> <span class="nc">Target</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">request</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 需要适配的类</span>
<span class="k">class</span> <span class="nc">Adaptee</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">specificRequest</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Adaptee's specific request."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 适配器</span>
<span class="k">class</span> <span class="nc">Adapter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Target</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">Adaptee</span><span class="o">*</span> <span class="n">adaptee</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">Adapter</span><span class="p">(</span><span class="n">Adaptee</span><span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">adaptee</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="n">request</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">adaptee</span><span class="o">-&gt;</span><span class="n">specificRequest</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 使用示例</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Adaptee</span><span class="o">*</span> <span class="n">adaptee</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Adaptee</span><span class="p">();</span>
    <span class="n">Target</span><span class="o">*</span> <span class="n">target</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Adapter</span><span class="p">(</span><span class="n">adaptee</span><span class="p">);</span>
    <span class="n">target</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">();</span>

    <span class="k">delete</span> <span class="n">target</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">adaptee</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>运行结果：</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Adaptee's specific request.
</code></pre></div></div>

<hr />

<p><strong>2. 装饰器模式（Decorator Pattern）</strong></p>

<p><strong>概念：</strong>
动态地给一个对象添加一些额外的职责，就增加功能来说，装饰器模式比生成子类更为灵活。</p>

<p><strong>应用场景：</strong></p>
<ul>
  <li>需要在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li>
  <li>需要对对象进行一些额外的功能拓展。</li>
</ul>

<p><strong>示例：</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Component</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">operation</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Component</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ConcreteComponent</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Component</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">operation</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ConcreteComponent operation."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Decorator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Component</span> <span class="p">{</span>
<span class="nl">protected:</span>
    <span class="n">Component</span><span class="o">*</span> <span class="n">component</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">Decorator</span><span class="p">(</span><span class="n">Component</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="o">:</span> <span class="n">component</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Decorator</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">component</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">operation</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">component</span><span class="o">-&gt;</span><span class="n">operation</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ConcreteDecorator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Decorator</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ConcreteDecorator</span><span class="p">(</span><span class="n">Component</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="o">:</span> <span class="n">Decorator</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="n">operation</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">Decorator</span><span class="o">::</span><span class="n">operation</span><span class="p">();</span>
        <span class="n">addedBehavior</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">addedBehavior</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ConcreteDecorator added behavior."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 使用示例</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Component</span><span class="o">*</span> <span class="n">component</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcreteComponent</span><span class="p">();</span>
    <span class="n">Component</span><span class="o">*</span> <span class="n">decorator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcreteDecorator</span><span class="p">(</span><span class="n">component</span><span class="p">);</span>
    <span class="n">decorator</span><span class="o">-&gt;</span><span class="n">operation</span><span class="p">();</span>

    <span class="k">delete</span> <span class="n">decorator</span><span class="p">;</span> <span class="c1">// 会递归删除component</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>运行结果：</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ConcreteComponent operation.
ConcreteDecorator added behavior.
</code></pre></div></div>

<hr />

<p><strong>3. 代理模式（Proxy Pattern）</strong></p>

<p><strong>概念：</strong>
为其他对象提供一种代理以控制对这个对象的访问。</p>

<p><strong>应用场景：</strong></p>
<ul>
  <li>需要为某对象提供代理以控制对它的访问。</li>
  <li>远程代理、本地代理、虚代理等。</li>
</ul>

<p><strong>示例：</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Subject</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">request</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Subject</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">RealSubject</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Subject</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">request</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"RealSubject handling request."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Proxy</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Subject</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">RealSubject</span><span class="o">*</span> <span class="n">realSubject</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">Proxy</span><span class="p">()</span> <span class="o">:</span> <span class="n">realSubject</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="p">{}</span>
    <span class="o">~</span><span class="n">Proxy</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">realSubject</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">request</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">realSubject</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">realSubject</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RealSubject</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Proxy delegating request to RealSubject."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">realSubject</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 使用示例</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Subject</span><span class="o">*</span> <span class="n">subject</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Proxy</span><span class="p">();</span>
    <span class="n">subject</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">();</span>

    <span class="k">delete</span> <span class="n">subject</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>运行结果：</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Proxy delegating request to RealSubject.
RealSubject handling request.
</code></pre></div></div>

<hr />

<h3 id="三行为型模式">三、行为型模式</h3>

<p><strong>1. 策略模式（Strategy Pattern）</strong></p>

<p><strong>概念：</strong>
定义一系列的算法，把它们一个个封装起来，并且使它们可互相替换。</p>

<p><strong>应用场景：</strong></p>
<ul>
  <li>需要在不同的情况下使用不同的算法。</li>
  <li>算法在运行时需要互相替换。</li>
</ul>

<p><strong>示例：</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Strategy</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">algorithmInterface</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Strategy</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ConcreteStrategyA</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Strategy</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">algorithmInterface</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Strategy A algorithm implementation."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ConcreteStrategyB</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Strategy</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">algorithmInterface</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Strategy B algorithm implementation."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Context</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">Strategy</span><span class="o">*</span> <span class="n">strategy</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">Context</span><span class="p">(</span><span class="n">Strategy</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">strategy</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{}</span>
    <span class="o">~</span><span class="n">Context</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">strategy</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">contextInterface</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">strategy</span><span class="o">-&gt;</span><span class="n">algorithmInterface</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 使用示例</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Strategy</span><span class="o">*</span> <span class="n">strategyA</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcreteStrategyA</span><span class="p">();</span>
    <span class="n">Context</span><span class="o">*</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Context</span><span class="p">(</span><span class="n">strategyA</span><span class="p">);</span>
    <span class="n">context</span><span class="o">-&gt;</span><span class="n">contextInterface</span><span class="p">();</span>

    <span class="k">delete</span> <span class="n">context</span><span class="p">;</span>

    <span class="n">Strategy</span><span class="o">*</span> <span class="n">strategyB</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcreteStrategyB</span><span class="p">();</span>
    <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Context</span><span class="p">(</span><span class="n">strategyB</span><span class="p">);</span>
    <span class="n">context</span><span class="o">-&gt;</span><span class="n">contextInterface</span><span class="p">();</span>

    <span class="k">delete</span> <span class="n">context</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>运行结果：</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Strategy A algorithm implementation.
Strategy B algorithm implementation.
</code></pre></div></div>

<hr />

<p><strong>2. 观察者模式（Observer Pattern）</strong></p>

<p><strong>概念：</strong>
定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>

<p><strong>应用场景：</strong></p>
<ul>
  <li>一个对象的改变需要同时改变其他对象，而且不知道有多少对象需要被改变。</li>
  <li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。</li>
</ul>

<p><strong>示例：</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Observer</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Observer</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ConcreteObserver</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Observer</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">ConcreteObserver</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Observer "</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">" has been notified."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Subject</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Observer</span><span class="o">*&gt;</span> <span class="n">observers</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">attach</span><span class="p">(</span><span class="n">Observer</span><span class="o">*</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">observers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">detach</span><span class="p">(</span><span class="n">Observer</span><span class="o">*</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">observers</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">remove</span><span class="p">(</span><span class="n">observers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">observers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">o</span><span class="p">),</span> <span class="n">observers</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">notify</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">observer</span> <span class="o">:</span> <span class="n">observers</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">observer</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 使用示例</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Subject</span><span class="o">*</span> <span class="n">subject</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Subject</span><span class="p">();</span>

    <span class="n">Observer</span><span class="o">*</span> <span class="n">observer1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcreteObserver</span><span class="p">(</span><span class="s">"A"</span><span class="p">);</span>
    <span class="n">Observer</span><span class="o">*</span> <span class="n">observer2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcreteObserver</span><span class="p">(</span><span class="s">"B"</span><span class="p">);</span>
    <span class="n">Observer</span><span class="o">*</span> <span class="n">observer3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcreteObserver</span><span class="p">(</span><span class="s">"C"</span><span class="p">);</span>

    <span class="n">subject</span><span class="o">-&gt;</span><span class="n">attach</span><span class="p">(</span><span class="n">observer1</span><span class="p">);</span>
    <span class="n">subject</span><span class="o">-&gt;</span><span class="n">attach</span><span class="p">(</span><span class="n">observer2</span><span class="p">);</span>
    <span class="n">subject</span><span class="o">-&gt;</span><span class="n">attach</span><span class="p">(</span><span class="n">observer3</span><span class="p">);</span>

    <span class="n">subject</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">();</span>

    <span class="n">subject</span><span class="o">-&gt;</span><span class="n">detach</span><span class="p">(</span><span class="n">observer2</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"After detaching observer B:"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">subject</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">();</span>

    <span class="k">delete</span> <span class="n">observer1</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">observer2</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">observer3</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">subject</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>运行结果：</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Observer A has been notified.
Observer B has been notified.
Observer C has been notified.
After detaching observer B:
Observer A has been notified.
Observer C has been notified.
</code></pre></div></div>

<hr />

<p><strong>3. 命令模式（Command Pattern）</strong></p>

<p><strong>概念：</strong>
将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p>

<p><strong>应用场景：</strong></p>
<ul>
  <li>需要对操作进行参数化。</li>
  <li>需要将操作放入队列中执行、日志记录、支持撤销操作。</li>
</ul>

<p><strong>示例：</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Command</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">execute</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Command</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Receiver</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">action</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Receiver action performed."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ConcreteCommand</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Command</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">Receiver</span><span class="o">*</span> <span class="n">receiver</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">ConcreteCommand</span><span class="p">(</span><span class="n">Receiver</span><span class="o">*</span> <span class="n">r</span><span class="p">)</span> <span class="o">:</span> <span class="n">receiver</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="n">execute</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">receiver</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Invoker</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Command</span><span class="o">*&gt;</span> <span class="n">commands</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">setCommand</span><span class="p">(</span><span class="n">Command</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">commands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">executeCommands</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">command</span> <span class="o">:</span> <span class="n">commands</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">command</span><span class="o">-&gt;</span><span class="n">execute</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">Invoker</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">command</span> <span class="o">:</span> <span class="n">commands</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">delete</span> <span class="n">command</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 使用示例</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Receiver</span><span class="o">*</span> <span class="n">receiver</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Receiver</span><span class="p">();</span>
    <span class="n">Command</span><span class="o">*</span> <span class="n">command</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcreteCommand</span><span class="p">(</span><span class="n">receiver</span><span class="p">);</span>

    <span class="n">Invoker</span><span class="o">*</span> <span class="n">invoker</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Invoker</span><span class="p">();</span>
    <span class="n">invoker</span><span class="o">-&gt;</span><span class="n">setCommand</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>
    <span class="n">invoker</span><span class="o">-&gt;</span><span class="n">executeCommands</span><span class="p">();</span>

    <span class="k">delete</span> <span class="n">invoker</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">receiver</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>运行结果：</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Receiver action performed.
</code></pre></div></div>

<hr />

<p><strong>4. 状态模式（State Pattern）</strong></p>

<p><strong>概念：</strong>
允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</p>

<p><strong>应用场景：</strong></p>
<ul>
  <li>一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变行为。</li>
</ul>

<p><strong>示例：</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Context</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">State</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">Context</span><span class="o">*</span> <span class="n">context</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">State</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ConcreteStateA</span> <span class="o">:</span> <span class="k">public</span> <span class="n">State</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">Context</span><span class="o">*</span> <span class="n">context</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ConcreteStateB</span> <span class="o">:</span> <span class="k">public</span> <span class="n">State</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">Context</span><span class="o">*</span> <span class="n">context</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Context</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">State</span><span class="o">*</span> <span class="n">state</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">Context</span><span class="p">(</span><span class="n">State</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">state</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{}</span>
    <span class="o">~</span><span class="n">Context</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">state</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">setState</span><span class="p">(</span><span class="n">State</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">delete</span> <span class="n">state</span><span class="p">;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">request</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">state</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">ConcreteStateA</span><span class="o">::</span><span class="n">handle</span><span class="p">(</span><span class="n">Context</span><span class="o">*</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"State A handling request. Switching to State B."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">context</span><span class="o">-&gt;</span><span class="n">setState</span><span class="p">(</span><span class="k">new</span> <span class="n">ConcreteStateB</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">ConcreteStateB</span><span class="o">::</span><span class="n">handle</span><span class="p">(</span><span class="n">Context</span><span class="o">*</span> <span class="n">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"State B handling request. Switching to State A."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">context</span><span class="o">-&gt;</span><span class="n">setState</span><span class="p">(</span><span class="k">new</span> <span class="n">ConcreteStateA</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">// 使用示例</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Context</span><span class="o">*</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Context</span><span class="p">(</span><span class="k">new</span> <span class="n">ConcreteStateA</span><span class="p">());</span>

    <span class="n">context</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">();</span>
    <span class="n">context</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">();</span>
    <span class="n">context</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">();</span>

    <span class="k">delete</span> <span class="n">context</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>运行结果：</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>State A handling request. Switching to State B.
State B handling request. Switching to State A.
State A handling request. Switching to State B.
</code></pre></div></div>

<hr />

<p><strong>5. 模板方法模式（Template Method Pattern）</strong></p>

<p><strong>概念：</strong>
定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变算法的结构即可重新定义算法的某些步骤。</p>

<p><strong>应用场景：</strong></p>
<ul>
  <li>一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。</li>
  <li>各子类中公共的行为被提取出来并集中到一个公共父类中，以避免代码重复。</li>
</ul>

<p><strong>示例：</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">AbstractClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">templateMethod</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">primitiveOperation1</span><span class="p">();</span>
        <span class="n">primitiveOperation2</span><span class="p">();</span>
        <span class="n">hook</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">primitiveOperation1</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">primitiveOperation2</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">hook</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// 钩子方法，子类可选择性重写</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">AbstractClass</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ConcreteClass</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AbstractClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">primitiveOperation1</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ConcreteClass Operation1 implementation."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">primitiveOperation2</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ConcreteClass Operation2 implementation."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">hook</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ConcreteClass optional hook implementation."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 使用示例</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">AbstractClass</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcreteClass</span><span class="p">();</span>
    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">templateMethod</span><span class="p">();</span>

    <span class="k">delete</span> <span class="n">obj</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>运行结果：</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ConcreteClass Operation1 implementation.
ConcreteClass Operation2 implementation.
ConcreteClass optional hook implementation.
</code></pre></div></div>

<hr />

<h3 id="总结">总结</h3>

<p>通过在每个设计模式的示例中添加<code class="language-plaintext highlighter-rouge">main</code>函数，我们可以更直观地看到这些模式在实际开发中的应用方式。每个<code class="language-plaintext highlighter-rouge">main</code>函数都演示了如何创建和使用相应的设计模式，帮助理解其工作原理和使用场景。在实际项目中，根据具体需求和场景，选择合适的设计模式能够提高代码的可维护性、可扩展性和可读性。</p>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="设计模式" /><summary type="html"><![CDATA[一、创建型模式]]></summary></entry><entry><title type="html">C++11\14特性</title><link href="http://localhost:4000/2024/10/21/Cpp11_14/" rel="alternate" type="text/html" title="C++11\14特性" /><published>2024-10-21T10:00:00+08:00</published><updated>2024-10-21T10:00:00+08:00</updated><id>http://localhost:4000/2024/10/21/Cpp11_14</id><content type="html" xml:base="http://localhost:4000/2024/10/21/Cpp11_14/"><![CDATA[<h2 id="c11特性">C++11特性</h2>

<h3 id="1-自动类型推导-auto">1. <strong>自动类型推导 (<code class="language-plaintext highlighter-rouge">auto</code>)</strong></h3>

<p>C++11 引入了 <code class="language-plaintext highlighter-rouge">auto</code> 关键字，允许编译器根据表达式的类型自动推导变量的类型。它可以简化代码，特别是在处理复杂的类型时。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>      <span class="c1">// 编译器推导 x 为 int</span>
<span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>   <span class="c1">// 编译器推导 y 为 double</span>
<span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">int</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>  <span class="c1">// 推导为 int*</span>
</code></pre></div></div>

<p>推导规则看CppLearning.pdf。</p>

<h3 id="2-范围-for-循环range-based-for-loop">2. <strong>范围 for 循环（Range-based for loop）</strong></h3>

<p>C++11 引入了范围 for 循环，简化了对容器或数组元素的迭代操作。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">v</span> <span class="o">:</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="3-智能指针-shared_ptr-unique_ptr-weak_ptr">3. <strong>智能指针 (<code class="language-plaintext highlighter-rouge">shared_ptr</code>, <code class="language-plaintext highlighter-rouge">unique_ptr</code>, <code class="language-plaintext highlighter-rouge">weak_ptr</code>)</strong></h3>
<p>智能指针本质是一个封装了一个原始C++指针的类模板，为了确保动态内存的安全性而产生的。
C++11 提供了新的智能指针，用于更好地管理动态内存：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">std::unique_ptr</code>：独占所有权。</li>
  <li><code class="language-plaintext highlighter-rouge">std::shared_ptr</code>：共享所有权，使用引用计数来管理对象的生命周期。</li>
  <li><code class="language-plaintext highlighter-rouge">std::weak_ptr</code>：用于打破 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 之间的循环引用。</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
</code></pre></div></div>

<p>在 C++ 的早期，<code class="language-plaintext highlighter-rouge">auto_ptr</code> 是标准库中唯一提供的智能指针，用于自动管理动态分配的内存。然而，<code class="language-plaintext highlighter-rouge">auto_ptr</code> 有一些设计缺陷，尤其是所有权的转移行为不直观、不安全，因此在 C++11 引入了新的智能指针类型，如 <code class="language-plaintext highlighter-rouge">unique_ptr</code>、<code class="language-plaintext highlighter-rouge">shared_ptr</code> 和 <code class="language-plaintext highlighter-rouge">weak_ptr</code>，并逐渐淘汰了 <code class="language-plaintext highlighter-rouge">auto_ptr</code>。</p>

<p>接下来，我们详细讨论从 <code class="language-plaintext highlighter-rouge">auto_ptr</code> 到 C++11 的智能指针演变。</p>

<h4 id="1-auto_ptrc98">1. <strong><code class="language-plaintext highlighter-rouge">auto_ptr</code>（C++98）</strong></h4>

<p><code class="language-plaintext highlighter-rouge">auto_ptr</code> 是 C++98 标准中的智能指针，用来管理动态分配的对象。它的主要目的是在对象离开作用域时自动释放动态分配的内存，避免内存泄漏。</p>

<h5 id="11-基本用法">1.1 <strong>基本用法</strong>：</h5>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>  <span class="c1">// 动态分配内存并绑定到 auto_ptr</span>
    <span class="n">std</span><span class="o">::</span><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>          <span class="c1">// 转移所有权，p1 不再持有对象</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>       <span class="c1">// 输出 10</span>
    <span class="c1">// p1 现在是空指针，持有 nullptr</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="12-auto_ptr-的问题">1.2 <strong><code class="language-plaintext highlighter-rouge">auto_ptr</code> 的问题</strong>：</h5>
<ul>
  <li><strong>所有权转移</strong>：<code class="language-plaintext highlighter-rouge">auto_ptr</code> 在拷贝和赋值时会转移资源的所有权。例如，<code class="language-plaintext highlighter-rouge">auto_ptr p2 = p1;</code> 会将资源从 <code class="language-plaintext highlighter-rouge">p1</code> 转移到 <code class="language-plaintext highlighter-rouge">p2</code>，而 <code class="language-plaintext highlighter-rouge">p1</code> 被置为空。这种所有权转移是不直观的，容易导致悬空指针或双重释放的问题。</li>
  <li><strong>不能用于容器</strong>：由于 <code class="language-plaintext highlighter-rouge">auto_ptr</code> 拷贝时会改变源对象的状态，它无法安全地用于 STL 容器（如 <code class="language-plaintext highlighter-rouge">std::vector</code>）。容器通常会在元素的插入和删除过程中进行拷贝操作，使用 <code class="language-plaintext highlighter-rouge">auto_ptr</code> 会导致意外的行为。</li>
  <li><strong>已经废弃</strong>：由于这些问题，<code class="language-plaintext highlighter-rouge">auto_ptr</code> 在 C++11 被标记为<strong>废弃</strong>，并在 C++17 中完全移除。</li>
</ul>

<h4 id="2-unique_ptrc11">2. <strong><code class="language-plaintext highlighter-rouge">unique_ptr</code>（C++11）</strong></h4>

<p><code class="language-plaintext highlighter-rouge">unique_ptr</code> 是 C++11 引入的智能指针，旨在替代 <code class="language-plaintext highlighter-rouge">auto_ptr</code>。它也是一种<strong>独占所有权</strong>的智能指针，但相比 <code class="language-plaintext highlighter-rouge">auto_ptr</code>，<code class="language-plaintext highlighter-rouge">unique_ptr</code> 更加安全和高效。</p>

<h5 id="21-特点">2.1 <strong>特点</strong>：</h5>
<ul>
  <li><strong>独占所有权</strong>：<code class="language-plaintext highlighter-rouge">unique_ptr</code> 独占所管理的资源，不能被拷贝，但可以通过<strong>移动语义</strong>（move semantics）转移所有权。</li>
  <li><strong>轻量高效</strong>：相比于 <code class="language-plaintext highlighter-rouge">shared_ptr</code>，<code class="language-plaintext highlighter-rouge">unique_ptr</code> 没有额外的引用计数开销。</li>
  <li><strong>自定义删除器</strong>：<code class="language-plaintext highlighter-rouge">unique_ptr</code> 支持自定义删除器，可以管理复杂资源（如文件句柄、网络连接等）。</li>
</ul>

<h5 id="22-基本用法">2.2 <strong>基本用法</strong>：</h5>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">20</span><span class="p">));</span>       <span class="c1">// 创建 unique_ptr，管理动态分配的内存</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>    <span class="c1">// 使用 std::move 转移所有权</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>              <span class="c1">// 输出 20</span>
    <span class="c1">// p1 现在是空的，不能再使用它</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="23-与-auto_ptr-的区别">2.3 <strong>与 <code class="language-plaintext highlighter-rouge">auto_ptr</code> 的区别</strong>：</h5>
<ul>
  <li>
    <p><strong>不能拷贝</strong>：与 <code class="language-plaintext highlighter-rouge">auto_ptr</code> 不同，<code class="language-plaintext highlighter-rouge">unique_ptr</code> 不能通过复制构造或赋值操作来拷贝。必须使用 <code class="language-plaintext highlighter-rouge">std::move</code> 将所有权从一个 <code class="language-plaintext highlighter-rouge">unique_ptr</code> 转移到另一个。这避免了 <code class="language-plaintext highlighter-rouge">auto_ptr</code> 的潜在所有权混乱问题。</p>
  </li>
  <li>
    <p><strong>自定义删除器</strong>：<code class="language-plaintext highlighter-rouge">unique_ptr</code> 可以接受自定义删除器来释放资源，适用于更复杂的资源管理场景。</p>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">FILE</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fclose</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">filePtr</span><span class="p">(</span><span class="n">fopen</span><span class="p">(</span><span class="s">"test.txt"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">),</span> <span class="n">fclose</span><span class="p">);</span>
</code></pre></div></div>

<h5 id="24-应用场景">2.4 <strong>应用场景</strong>：</h5>
<ul>
  <li>用于确保资源在离开作用域时被正确释放，避免内存泄漏。</li>
  <li><code class="language-plaintext highlighter-rouge">unique_ptr</code> 适用于独占资源的场景，如管理文件、网络连接或设备句柄等。</li>
</ul>

<h4 id="3-shared_ptrc11">3. <strong><code class="language-plaintext highlighter-rouge">shared_ptr</code>（C++11）</strong></h4>

<p><code class="language-plaintext highlighter-rouge">shared_ptr</code> 是一种支持<strong>共享所有权</strong>的智能指针，多个 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 可以共同管理同一个对象。对象的生命周期会延长，直到最后一个 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 释放它。</p>

<h5 id="31-特点">3.1 <strong>特点</strong>：</h5>
<ul>
  <li><strong>引用计数</strong>：<code class="language-plaintext highlighter-rouge">shared_ptr</code> 内部维护一个引用计数，当引用计数为 0 时，所管理的对象会被自动销毁。</li>
  <li><strong>拷贝安全</strong>：<code class="language-plaintext highlighter-rouge">shared_ptr</code> 可以被拷贝，拷贝时引用计数增加。</li>
  <li><strong>线程安全</strong>：C++11 标准中，<code class="language-plaintext highlighter-rouge">shared_ptr</code> 的引用计数是线程安全的。</li>
</ul>

<h5 id="32-基本用法">3.2 <strong>基本用法</strong>：</h5>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>   <span class="c1">// 推荐的创建方式</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>                          <span class="c1">// 拷贝 p1，引用计数增加</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>                         <span class="c1">// 输出 30</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Use count: "</span> <span class="o">&lt;&lt;</span> <span class="n">p1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 引用计数输出 2</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="33-shared_ptr-与-unique_ptr-的区别">3.3 <strong><code class="language-plaintext highlighter-rouge">shared_ptr</code> 与 <code class="language-plaintext highlighter-rouge">unique_ptr</code> 的区别</strong>：</h5>
<ul>
  <li>
    <p><strong>共享所有权</strong>：<code class="language-plaintext highlighter-rouge">shared_ptr</code> 的设计目的是让多个智能指针共享同一个对象。当不再需要对象时，引用计数归零，自动销毁对象。相比之下，<code class="language-plaintext highlighter-rouge">unique_ptr</code> 独占对象，不能共享。</p>
  </li>
  <li>
    <p><strong>性能开销</strong>：由于 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 需要维护引用计数，它比 <code class="language-plaintext highlighter-rouge">unique_ptr</code> 有更大的内存和性能开销。如果没有必要的共享行为，应该优先使用 <code class="language-plaintext highlighter-rouge">unique_ptr</code>。</p>
  </li>
</ul>

<h5 id="34-自定义删除器">3.4 <strong>自定义删除器</strong>：</h5>
<p>与 <code class="language-plaintext highlighter-rouge">unique_ptr</code> 类似，<code class="language-plaintext highlighter-rouge">shared_ptr</code> 也支持自定义删除器：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">FILE</span><span class="o">&gt;</span> <span class="n">filePtr</span><span class="p">(</span><span class="n">fopen</span><span class="p">(</span><span class="s">"test.txt"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">),</span> <span class="n">fclose</span><span class="p">);</span>
</code></pre></div></div>

<h5 id="35-应用场景">3.5 <strong>应用场景</strong>：</h5>
<ul>
  <li>当多个对象需要共享同一个资源时，可以使用 <code class="language-plaintext highlighter-rouge">shared_ptr</code>。例如，一个对象在多个模块中被使用，所有模块都应该控制其生命周期。</li>
  <li>当对象的强引用计数降为0时，shared_ptr会释放该对象的内存，但控制块不会立即释放，因为仍然有weak_ptr可能在观察它。控制块会在弱引用计数也降为0时释放，这样可以确保weak_ptr可以安全地判断对象是否有效。</li>
</ul>

<h4 id="4-weak_ptrc11">4. <strong><code class="language-plaintext highlighter-rouge">weak_ptr</code>（C++11）</strong></h4>

<p><code class="language-plaintext highlighter-rouge">weak_ptr</code> 是一种<strong>非拥有</strong>（non-owning）的智能指针，它与 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 配合使用，用于解决共享对象的<strong>循环引用</strong>问题。<code class="language-plaintext highlighter-rouge">weak_ptr</code> 不影响引用计数。</p>

<h5 id="41-特点">4.1 <strong>特点</strong>：</h5>
<ul>
  <li><strong>弱引用</strong>：<code class="language-plaintext highlighter-rouge">weak_ptr</code> 只是指向对象，并不影响对象的生命周期，不能直接解引用。</li>
  <li><strong>循环引用解决</strong>：在使用 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 时，如果两个对象相互持有对方的 <code class="language-plaintext highlighter-rouge">shared_ptr</code>，会导致循环引用，无法释放内存。使用 <code class="language-plaintext highlighter-rouge">weak_ptr</code> 可以打破这种循环。</li>
</ul>

<h5 id="42-基本用法">4.2 <strong>基本用法</strong>：</h5>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sp</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">40</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">wp</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>  <span class="c1">// 创建 weak_ptr，不增加引用计数</span>

    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">wp</span><span class="p">.</span><span class="n">lock</span><span class="p">())</span> <span class="p">{</span>  <span class="c1">// 使用 lock() 生成 shared_ptr</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">temp</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 输出 40</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Resource no longer available."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="43-应用场景">4.3 <strong>应用场景</strong>：</h5>
<ul>
  <li><code class="language-plaintext highlighter-rouge">weak_ptr</code> 通常用于避免循环引用。例如在双向链表、图结构或依赖关系复杂的系统中，<code class="language-plaintext highlighter-rouge">shared_ptr</code> 的循环引用问题可以通过 <code class="language-plaintext highlighter-rouge">weak_ptr</code> 解决。</li>
</ul>

<p><strong>智能指针中的引用计数是线程安全的，但是智能指针所指向的对象的线程安全问题，智能指针没有做任何保障线程不安全。</strong></p>

<h3 id="4-lambda-表达式">4. <strong>Lambda 表达式</strong></h3>

<p>C++11 引入了 lambda 表达式，使得可以在代码中编写匿名函数，特别适合于函数作为参数的场景，如回调、事件处理等。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">add</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 输出 3</span>
</code></pre></div></div>

<p>捕获外部变量：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">](</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">func</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 输出 8</span>
</code></pre></div></div>

<p>匿名函数本质上是一个对象，在其定义的过程中会创建出一个栈对象，内部通过重载()符号实现函数调用的外表。</p>

<p>优点：使用匿名函数，可以免去函数的声明和定义。这样匿名函数仅在调用函数的时候才会创建函数对象，而调用结束后立即释放，所以匿名函数比非匿名函数更节省空间。</p>

<h3 id="5-移动语义与右值引用-rvalue-references">5. <strong>移动语义与右值引用 (<code class="language-plaintext highlighter-rouge">rvalue references</code>)</strong></h3>

<p>C++11 引入了移动语义和右值引用，允许开发者通过转移资源所有权来避免不必要的拷贝，极大地提升了性能，尤其是对于临时对象的处理。</p>

<ul>
  <li>右值引用通过 <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> 定义，可以捕获右值，并通过 <code class="language-plaintext highlighter-rouge">std::move()</code> 转移资源。</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">v1</span><span class="p">);</span>  <span class="c1">// v1 的资源被转移给 v2，避免了拷贝</span>
</code></pre></div></div>

<p><strong>完美转发</strong>（Perfect Forwarding）是 C++11 引入的一个特性，<strong>允许函数将其接收到的参数（包括其值类型、引用类型和右值或左值属性）完美地转发给另一个函数</strong>。这种转发可以保留参数的所有特性，从而避免不必要的拷贝或引用失效问题。</p>

<p>完美转发的核心是<strong>右值引用</strong>（rvalue references）和<strong>模板参数推导</strong>，特别是结合了 <code class="language-plaintext highlighter-rouge">std::forward</code> 的使用，使得我们可以将函数接收到的参数以最优的方式传递给其他函数。</p>

<p>完美转发依赖于以下几个概念：</p>

<ol>
  <li><strong>右值引用（Rvalue Reference）</strong>：
    <ul>
      <li>右值引用通过 <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> 语法定义，用来接受右值对象（临时对象），并允许开发者高效地使用和转移这些对象的资源。</li>
      <li>对于模板参数中的 <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code>，它既能接受右值引用，也能接受左值引用，这是完美转发的基础。</li>
    </ul>
  </li>
  <li><strong>万能引用（Universal Reference）</strong>：
    <ul>
      <li>当 <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> 作为模板参数出现时，它被称为<strong>万能引用</strong>，可以同时接受左值引用和右值引用。编译器根据传递的参数类型推导 <code class="language-plaintext highlighter-rouge">T</code> 的类型，从而决定是左值引用还是右值引用。</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">std::forward</code></strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">std::forward</code> 是一个帮助函数，用来在函数内部将参数以原始的类型（左值或右值）转发给另一个函数。它根据模板参数的类型决定是否执行<strong>移动语义</strong>（move semantics）。</li>
    </ul>
  </li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="c1">  // for std::forward</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Lvalue reference: "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">process</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Rvalue reference: "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">forwarder</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">process</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span>  <span class="c1">// 保持 arg 的值类别</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
    <span class="n">forwarder</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>        <span class="c1">// 转发左值，调用 process(int&amp;)</span>
    <span class="n">forwarder</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>      <span class="c1">// 转发右值，调用 process(int&amp;&amp;)</span>
<span class="p">}</span>
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Lvalue reference: 42
Rvalue reference: 100
</code></pre></div></div>

<p>如果没有使用 <code class="language-plaintext highlighter-rouge">std::forward</code>，完美转发就无法正常工作。例如：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">forwarder</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">process</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>  <span class="c1">// 没有使用 std::forward</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
    <span class="n">forwarder</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>        <span class="c1">// 错误：a 是左值，传递给 process 时应为左值引用</span>
    <span class="n">forwarder</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>      <span class="c1">// 错误：100 是右值，但被转发为左值</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在这段代码中，<code class="language-plaintext highlighter-rouge">process(arg)</code> 传递的是 <code class="language-plaintext highlighter-rouge">arg</code>，无论 <code class="language-plaintext highlighter-rouge">arg</code> 是左值还是右值，都会被视为<strong>左值</strong>传递。结果是，即使你传递的是右值，它在传递过程中也会丧失右值属性。</p>

<p><strong><code class="language-plaintext highlighter-rouge">std::forward</code> 根据模板参数的类型来决定是否转发为右值：</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>如果 <code class="language-plaintext highlighter-rouge">T</code> 是左值引用类型，<code class="language-plaintext highlighter-rouge">std::forward&lt;T&gt;(t)</code> 会返回 <code class="language-plaintext highlighter-rouge">t</code> 的左值引用。</li>
  <li>如果 <code class="language-plaintext highlighter-rouge">T</code> 是右值引用类型，<code class="language-plaintext highlighter-rouge">std::forward&lt;T&gt;(t)</code> 会将 <code class="language-plaintext highlighter-rouge">t</code> 转换为右值引用。</li>
</ul>

<h3 id="6-完美转发的注意事项">6. <strong>完美转发的注意事项</strong></h3>

<ol>
  <li><strong>引用折叠</strong>：
    <ul>
      <li>在完美转发中，C++11 引入了<strong>引用折叠规则</strong>，帮助解决模板参数推导过程中多重引用的问题。具体规则如下：
        <ul>
          <li><code class="language-plaintext highlighter-rouge">T&amp; &amp;</code>、<code class="language-plaintext highlighter-rouge">T&amp; &amp;&amp;</code>、<code class="language-plaintext highlighter-rouge">T&amp;&amp; &amp;</code> 都会折叠为 <code class="language-plaintext highlighter-rouge">T&amp;</code>（左值引用）。</li>
          <li>只有 <code class="language-plaintext highlighter-rouge">T&amp;&amp; &amp;&amp;</code> 会折叠为 <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code>（右值引用）。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>性能问题</strong>：
    <ul>
      <li>完美转发的设计目的是优化性能，减少不必要的拷贝和对象构造。然而，完美转发可能引入额外的复杂性，尤其是在处理移动语义时。</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">std::forward</code> 与 <code class="language-plaintext highlighter-rouge">std::move</code> 的区别</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">std::move</code> 总是将其参数转换为右值引用，而 <code class="language-plaintext highlighter-rouge">std::forward</code> 会根据参数类型决定是否保留其值类别。因此，<code class="language-plaintext highlighter-rouge">std::forward</code> 更适合用于模板参数转发。</li>
    </ul>
  </li>
</ol>

<h3 id="6-nullptr">6. <strong><code class="language-plaintext highlighter-rouge">nullptr</code></strong></h3>

<p>C++11 引入了 <code class="language-plaintext highlighter-rouge">nullptr</code>，它取代了传统的 <code class="language-plaintext highlighter-rouge">NULL</code>，成为一个类型安全的空指针常量。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>  <span class="c1">// 代替 NULL</span>
</code></pre></div></div>

<h3 id="7-constexpr">7. <strong><code class="language-plaintext highlighter-rouge">constexpr</code></strong></h3>

<p>C++11 引入了 <code class="language-plaintext highlighter-rouge">constexpr</code>，它允许在编译时计算常量表达式，提高编译期的优化。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">square</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">square</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>  <span class="c1">// 在编译时计算</span>
</code></pre></div></div>

<h3 id="8-委托构造函数delegating-constructors">8. <strong>委托构造函数（Delegating constructors）</strong></h3>

<p>C++11 允许一个构造函数调用另一个构造函数，简化了构造函数的实现。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">MyClass</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>  <span class="c1">// 调用另一个构造函数</span>
    <span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{}</span>

<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="9-显式转换运算符explicit-conversion-operators">9. <strong>显式转换运算符（Explicit conversion operators）</strong></h3>

<p>C++11 允许将类型转换运算符标记为 <code class="language-plaintext highlighter-rouge">explicit</code>，避免隐式转换带来的错误。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">MyClass</span> <span class="n">obj</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 只有通过显示的转换，才能将 obj 转换为 bool</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="10-stdthread-和多线程支持">10. <strong><code class="language-plaintext highlighter-rouge">std::thread</code> 和多线程支持</strong></h3>

<p>C++11 引入了标准库的多线程支持，包括 <code class="language-plaintext highlighter-rouge">std::thread</code>、<code class="language-plaintext highlighter-rouge">std::mutex</code>、<code class="language-plaintext highlighter-rouge">std::lock_guard</code> 等，可以直接使用标准库进行线程创建和同步。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span><span class="kt">void</span> <span class="nf">threadFunc</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello from thread"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">threadFunc</span><span class="p">);</span>  <span class="c1">// 创建一个线程</span>
    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>                   <span class="c1">// 等待线程结束</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="11-变参模板variadic-templates">11. <strong>变参模板（Variadic templates）</strong></h3>

<p>C++11 支持变参模板，允许模板接受任意数量的模板参数。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">...</span> <span class="o">&lt;&lt;</span> <span class="n">args</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// C++17 fold expression</span>
<span class="p">}</span>
<span class="n">print</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="s">"Hello"</span><span class="p">);</span>  <span class="c1">// 输出：1 2.5 Hello</span>
</code></pre></div></div>

<h3 id="12-stdtuple">12. <strong><code class="language-plaintext highlighter-rouge">std::tuple</code></strong></h3>

<p>C++11 引入了 <code class="language-plaintext highlighter-rouge">std::tuple</code>，它是一个固定大小的异构集合，允许存储不同类型的对象。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;tuple&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="s">"Hello"</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 输出 1</span>
</code></pre></div></div>

<h3 id="13-enum-class">13. <strong><code class="language-plaintext highlighter-rouge">enum class</code></strong></h3>

<p>C++11 引入了强类型枚举 <code class="language-plaintext highlighter-rouge">enum class</code>，它比传统的 <code class="language-plaintext highlighter-rouge">enum</code> 更安全，因为它不会隐式转换为整型。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">Color</span> <span class="p">{</span> <span class="n">Red</span><span class="p">,</span> <span class="n">Green</span><span class="p">,</span> <span class="n">Blue</span> <span class="p">};</span>
<span class="n">Color</span> <span class="n">c</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">Red</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="14-stdarray">14. <strong><code class="language-plaintext highlighter-rouge">std::array</code></strong></h3>

<p>C++11 提供了 <code class="language-plaintext highlighter-rouge">std::array</code>，它是 C++ STL 的静态数组，具有固定大小，并且提供了与 STL 容器相同的接口。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 输出 2</span>
</code></pre></div></div>

<h3 id="15-初始化列表initializer-lists">15. <strong>初始化列表（Initializer Lists）</strong></h3>

<p>C++11 引入了初始化列表语法，允许通过大括号 <code class="language-plaintext highlighter-rouge">{}</code> 直接初始化对象。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>  <span class="c1">// 使用初始化列表</span>
</code></pre></div></div>

<h3 id="16-decltype">16. <strong><code class="language-plaintext highlighter-rouge">decltype</code></strong></h3>

<p>C++11 提供了 <code class="language-plaintext highlighter-rouge">decltype</code>，用于推导表达式的类型，类似于 <code class="language-plaintext highlighter-rouge">auto</code>，但 <code class="language-plaintext highlighter-rouge">decltype</code> 可以用于复杂表达式的类型推导。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>  <span class="c1">// y 的类型与 x 相同，推导为 int</span>
</code></pre></div></div>

<h3 id="17-静态断言static_assert">17. <strong>静态断言（<code class="language-plaintext highlighter-rouge">static_assert</code>）</strong></h3>

<p>C++11 引入了 <code class="language-plaintext highlighter-rouge">static_assert</code>，用于在编译时进行条件检查，如果条件为假，编译器会抛出错误。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">,</span> <span class="s">"int size is not 4 bytes"</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="18-后置返回类型trailing-return-types">18. <strong>后置返回类型（Trailing Return Types）</strong></h3>

<p>C++11 支持在函数定义中使用后置返回类型，特别适用于复杂的返回类型或函数模板。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="19-noexcept">19. <strong><code class="language-plaintext highlighter-rouge">noexcept</code></strong></h3>

<p>C++11 引入了 <code class="language-plaintext highlighter-rouge">noexcept</code>，用于标记函数不抛出异常，有助于编译器优化。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="c1">// 函数不抛出异常</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="20-右值引用与移动构造函数">20. <strong>右值引用与移动构造函数</strong></h3>

<p>C++11 提供了右值引用和移动语义，用于避免不必要的对象拷贝，提高性能。移动构造函数和移动赋值运算符可以通过转移资源来避免深拷贝。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MyClass</span><span class="p">(</span><span class="n">MyClass</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="c1">// 实现移动构造函数</span>
    <span class="p">}</span>
    <span class="n">MyClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">MyClass</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="c1">// 实现移动赋值运算符</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="总结">总结</h3>

<p>C++11 是 C++ 语言的一次重大更新，带来了许多极大增强语言能力的特性。这些特性不仅简化了编写 C++ 代码的过程，还提供了强大的工具用于提高性能和安全性，使得 C++ 在现代开发中更加高效和实用。</p>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="C++" /><summary type="html"><![CDATA[C++11特性]]></summary></entry><entry><title type="html">C++补充</title><link href="http://localhost:4000/2024/10/21/Cpp/" rel="alternate" type="text/html" title="C++补充" /><published>2024-10-21T10:00:00+08:00</published><updated>2024-10-21T10:00:00+08:00</updated><id>http://localhost:4000/2024/10/21/Cpp</id><content type="html" xml:base="http://localhost:4000/2024/10/21/Cpp/"><![CDATA[<h3 id="内存分区">内存分区</h3>

<p>C++内存主要分为以下几个部分：</p>

<p>栈（Stack）：用于存储局部变量、函数参数、返回地址等。栈是自动管理的，数据进入作用域分配空间，离开作用域自动释放。</p>

<p>堆（Heap）：用于动态分配内存，如使用new或malloc分配的内存。堆内存需要手动释放，否则会导致内存泄露。</p>

<p>全局/静态存储区：存储全局变量和静态变量。全局/静态存储区的内存在程序编译时就已经分配好，且在程序整个运行期间都存在。</p>

<p>常量存储区：存储常量字符串等。该区域的内存在程序编译时就已经分配好，并且内容不可更改。</p>

<p>代码区：存储程序的可执行代码。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">function</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">a</code> 对象本身（包括管理指针和其他元数据）存储在栈区。</li>
  <li><code class="language-plaintext highlighter-rouge">std::vector</code> 在内部使用指针和动态分配的内存来管理其元素，当 <code class="language-plaintext highlighter-rouge">a(2)</code> 被构造时，会在堆上分配足够的空间来存储这两个 <code class="language-plaintext highlighter-rouge">int</code> 元素。</li>
</ul>

<h3 id="多态的实现原理实现方式是什么以及多态的优点特点">多态的实现原理（实现方式）是什么？以及多态的优点（特点）？</h3>
<p>实现方式：多态分为动态多态和静态多态（又称编译期多态，即在系统编译期间就可以确定程序将要执行哪个函数）</p>

<p>其中动态多态是通过虚函数实现的，虚函数是类的成员函数，存在存储虚函数指针的表叫做虚函数表，虚函数表是一个存储类成员虚函数的指针，每个指针都指向调用它的地方，当子类调用虚函数时，就会去虚表里面找自己对应的函数指针，从而实现“谁调用、实现谁”从而实现多态。</p>

<p>静态多态则是通过函数重载（函数名相同，参数不同，两个函数在同一作用域），运算符重载，和重定义（又叫隐藏，指的是在继承关系中，子类实现了一个和父类名字一样的函数，（只关注函数名，和参数与返回值无关）这样的话子类的函数就把父类的同名函数隐藏了。隐藏只与函数名有关，与参数没有关系）来实现的。</p>

<p>优点：加强代码的可扩展性，可替换性，增强程序的灵活性，提高使用效率，简化对应用代码的编写和修改过程。</p>

<h3 id="final标识符的作用">final标识符的作用</h3>
<p>放在类的后面表示该类无法被继承，也就是阻止了从类的继承，放在虚函数后面该虚函数无法被重写，表示阻止虚函数的重载</p>

<h3 id="explicit关键字">explicit关键字</h3>
<p>只能用于修饰只有一个参数的类构造函数（有一个例外就是，当除了第一个参数以外的其他参数都有默认值的时候此关键字依然有效），它的作用是表明该构造函数是显示的，而非隐式的，跟它对应的另一个关键字是implicit，意思是隐藏的，类构造函数默认情况下声明为implicit。作用是防止类构造函数的隐式自动转换。</p>

<p>在<code class="language-plaintext highlighter-rouge">std::vector</code>中，<code class="language-plaintext highlighter-rouge">push_back()</code>和<code class="language-plaintext highlighter-rouge">emplace_back()</code>都用于在末尾添加元素，但它们的实现和适用场景有所不同。</p>

<h3 id="push_back"><code class="language-plaintext highlighter-rouge">push_back()</code></h3>

<ul>
  <li><strong>功能</strong>：将一个元素拷贝或移动到容器的末尾。</li>
  <li><strong>实现方式</strong>：<code class="language-plaintext highlighter-rouge">push_back()</code>会创建一个临时对象（如果传入的是构造参数），然后将该对象拷贝或移动到<code class="language-plaintext highlighter-rouge">vector</code>的末尾。对于已存在的对象传递，是直接拷贝或移动的。</li>
  <li><strong>适用场景</strong>：在需要添加一个已经创建好的对象（例如一个临时变量或函数返回的对象）时使用<code class="language-plaintext highlighter-rouge">push_back()</code>更直观。</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>           <span class="c1">// 拷贝 str</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"world"</span><span class="p">);</span>        <span class="c1">// 创建临时对象并拷贝</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">str</span><span class="p">));</span> <span class="c1">// 移动 str</span>
</code></pre></div></div>

<h3 id="emplace_back"><code class="language-plaintext highlighter-rouge">emplace_back()</code></h3>

<ul>
  <li><strong>功能</strong>：直接在<code class="language-plaintext highlighter-rouge">vector</code>的末尾构造对象，避免不必要的拷贝或移动操作。</li>
  <li><strong>实现方式</strong>：<code class="language-plaintext highlighter-rouge">emplace_back()</code>会将传入的参数直接用于调用对象的构造函数，因此不会额外创建临时对象。这在效率上更高，特别是对于复杂对象来说。</li>
  <li><strong>适用场景</strong>：在需要添加新对象且不希望额外拷贝时，使用<code class="language-plaintext highlighter-rouge">emplace_back()</code>更合适，尤其在构造的过程中可以直接传入参数。</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>    <span class="c1">// 直接构造字符串，无需拷贝</span>
<span class="n">vec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">);</span>    <span class="c1">// 调用 std::string(10, 'a') 构造字符串</span>
</code></pre></div></div>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">push_back()</code></strong>适用于已有对象或简单对象的插入，能更直观表达意图。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">emplace_back()</code></strong>适合在需要构造复杂对象时使用，因为它可以避免临时对象的创建，提高效率。</li>
</ul>

<h3 id="类中static函数是否能声明为虚函数">类中static函数是否能声明为虚函数？</h3>
<p>不能，因为类中的static函数是所有类实例化对象所共有的，没有this指针，而虚函数依靠vptr和vtable来处理，vptr是一个指针，在类中的构造函数中生成，并且只能通过this指针访问，对于静态成员函数来说，他没有this指针，无法访问vptr，因此static函数无法声明为虚函数</p>

<h3 id="为什么存在this指针">为什么存在this指针？</h3>
<p>类和对象中的成员函数存储在公共的代码段，不同的对象调用成员函数时编译器为了知道具体操作的是哪一个对象给每个“非静态的成员函数”增加了一个隐藏的指针参数，让该指针指向当前对象，在函数体中所有成员变量的操作，都是通过这个指针来完成的由编译器自动完成。</p>

<p>C++ 中有四种主要的强制类型转换方式：<code class="language-plaintext highlighter-rouge">static_cast</code>、<code class="language-plaintext highlighter-rouge">dynamic_cast</code>、<code class="language-plaintext highlighter-rouge">const_cast</code> 和 <code class="language-plaintext highlighter-rouge">reinterpret_cast</code>，它们各自有不同的功能和适用场景。以下是每种类型转换的特点和实现原理：</p>

<h3 id="四个类型强制转换">四个类型强制转换</h3>
<h5 id="1-static_cast">1. <code class="language-plaintext highlighter-rouge">static_cast</code></h5>

<ul>
  <li><strong>特点</strong>：用于在编译时执行显式的类型转换。它可以在已知不会引发错误的情况下，用于安全类型转换。
    <ul>
      <li>支持基本数据类型之间的转换，如<code class="language-plaintext highlighter-rouge">int</code>到<code class="language-plaintext highlighter-rouge">float</code>。</li>
      <li>支持指针或引用在类层次结构中的转换，但只能用于已知类型的上下层关系（例如父类到子类的转换）。</li>
      <li>支持 void* 到其他指针类型的转换。</li>
    </ul>
  </li>
  <li><strong>原理</strong>：在编译时执行，转换过程中不会进行运行时检查，因此效率较高，但不适用于多态类型的安全转换。</li>
  <li>
    <p><strong>适用场景</strong>：当确定转换是合法且安全时，如基本类型之间转换、类层次结构中父类指针转换为子类指针（前提是确知转换有效）。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">);</span> <span class="c1">// 浮点转为整数</span>
</code></pre></div>    </div>
  </li>
</ul>

<h5 id="2-dynamic_cast">2. <code class="language-plaintext highlighter-rouge">dynamic_cast</code></h5>

<ul>
  <li><strong>特点</strong>：用于在运行时执行安全的类型转换，主要用于指针或引用之间的转换。只能用于带有虚函数的多态类（即 RTTI，运行时类型识别）。
    <ul>
      <li>如果转换失败，指针类型会返回 <code class="language-plaintext highlighter-rouge">nullptr</code>，引用类型会抛出 <code class="language-plaintext highlighter-rouge">bad_cast</code> 异常。</li>
      <li>只能用于类层次结构中基类和派生类之间的转换。</li>
    </ul>
  </li>
  <li><strong>原理</strong>：依赖于 RTTI 机制，在运行时检查类型安全性，适用于基类指针向派生类指针的转换（即向下转型）。</li>
  <li>
    <p><strong>适用场景</strong>：当需要在类层次结构中安全地进行向下转换，并且类是多态类（带有虚函数表）时。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="p">{}</span> <span class="p">};</span> <span class="c1">// 必须是多态类</span>
<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{};</span>

<span class="n">Base</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">;</span>
<span class="n">Derived</span><span class="o">*</span> <span class="n">d</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="c1">// 转换成功</span>
</code></pre></div>    </div>
  </li>
</ul>

<h5 id="3-const_cast">3. <code class="language-plaintext highlighter-rouge">const_cast</code></h5>

<ul>
  <li><strong>特点</strong>：用于去掉或添加 <code class="language-plaintext highlighter-rouge">const</code> 或 <code class="language-plaintext highlighter-rouge">volatile</code> 修饰符，通常用于处理需要修改 <code class="language-plaintext highlighter-rouge">const</code> 对象的场景。
    <ul>
      <li>只能更改对象的<code class="language-plaintext highlighter-rouge">const</code>或<code class="language-plaintext highlighter-rouge">volatile</code>属性，不能用于其他类型的转换。</li>
    </ul>
  </li>
  <li><strong>原理</strong>：编译时直接更改类型的<code class="language-plaintext highlighter-rouge">const</code>或<code class="language-plaintext highlighter-rouge">volatile</code>修饰，不影响数据在内存中的布局。</li>
  <li>
    <p><strong>适用场景</strong>：当需要在调用接口时移除<code class="language-plaintext highlighter-rouge">const</code>属性，如需要对<code class="language-plaintext highlighter-rouge">const</code>对象进行某些不可更改操作，或需要传递<code class="language-plaintext highlighter-rouge">const</code>对象给非<code class="language-plaintext highlighter-rouge">const</code>函数。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span> <span class="c1">// 去掉 const 修饰</span>
</code></pre></div>    </div>
  </li>
</ul>

<h5 id="4-reinterpret_cast">4. <code class="language-plaintext highlighter-rouge">reinterpret_cast</code></h5>

<ul>
  <li><strong>特点</strong>：用于进行极为底层的、类型上不安全的强制转换。它可以将任何指针类型转换为其他指针类型，或将整数转换为指针类型。
    <ul>
      <li>不同类型的指针之间、整数和指针之间可以相互转换。</li>
      <li>该转换并不更改数据的底层二进制表示。</li>
    </ul>
  </li>
  <li><strong>原理</strong>：直接重新解释内存中的二进制内容，将指针或数据的类型重新解释为目标类型。转换后数据的行为可能无法预测，因此需慎重使用。</li>
  <li>
    <p><strong>适用场景</strong>：当需要进行底层数据操作（如位操作或字节处理）时，或者需要将指针类型和整数类型之间转换时。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">65</span><span class="p">;</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 将 int* 转为 char*</span>
</code></pre></div>    </div>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th>转换类型</th>
      <th>适用范围</th>
      <th>运行时检查</th>
      <th>主要功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">static_cast</code></td>
      <td>编译时可确定的安全转换</td>
      <td>否</td>
      <td>基本类型转换、类层次结构的向上转换</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">dynamic_cast</code></td>
      <td>类层次结构中的向下转换，适用于多态类型</td>
      <td>是</td>
      <td>多态类的运行时类型检查，确保转换安全</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">const_cast</code></td>
      <td>去掉或添加<code class="language-plaintext highlighter-rouge">const</code>或<code class="language-plaintext highlighter-rouge">volatile</code>修饰</td>
      <td>否</td>
      <td>改变<code class="language-plaintext highlighter-rouge">const</code>或<code class="language-plaintext highlighter-rouge">volatile</code>修饰，主要用于修改<code class="language-plaintext highlighter-rouge">const</code>对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">reinterpret_cast</code></td>
      <td>低层次、不安全的类型转换</td>
      <td>否</td>
      <td>直接重新解释数据的二进制表示，适用于指针和整数之间的转换</td>
    </tr>
  </tbody>
</table>

<h5 id="使用建议">使用建议</h5>

<ul>
  <li>优先选择 <strong><code class="language-plaintext highlighter-rouge">static_cast</code></strong> 和 <strong><code class="language-plaintext highlighter-rouge">dynamic_cast</code></strong>，因为它们更安全、用途更清晰。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">const_cast</code></strong> 仅在必要时使用（如函数接口限制）。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">reinterpret_cast</code></strong> 应慎用，避免带来不易预期的错误和不稳定因素。</li>
</ul>

<h3 id="string实现">string实现</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="c1"> // for strlen, strcpy</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">MyString</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">capacity</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="c1">// 默认构造函数</span>
    <span class="n">MyString</span><span class="p">()</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">),</span> <span class="n">len</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">capacity</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

    <span class="c1">// 带参数构造函数</span>
    <span class="n">MyString</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
        <span class="n">capacity</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">capacity</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 拷贝构造函数（深拷贝）</span>
    <span class="n">MyString</span><span class="p">(</span><span class="k">const</span> <span class="n">MyString</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
        <span class="n">capacity</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">capacity</span><span class="p">;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">capacity</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 移动构造函数</span>
    <span class="n">MyString</span><span class="p">(</span><span class="n">MyString</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">),</span> <span class="n">len</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">len</span><span class="p">),</span> <span class="n">capacity</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">other</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">other</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">other</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 析构函数</span>
    <span class="o">~</span><span class="n">MyString</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 赋值运算符重载</span>
    <span class="n">MyString</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">MyString</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">delete</span><span class="p">[]</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// 释放旧的内存</span>

            <span class="n">len</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
            <span class="n">capacity</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">capacity</span><span class="p">;</span>
            <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">capacity</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
            <span class="n">strcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 移动赋值运算符</span>
    <span class="n">MyString</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">MyString</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">delete</span><span class="p">[]</span> <span class="n">data</span><span class="p">;</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
            <span class="n">len</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
            <span class="n">capacity</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">capacity</span><span class="p">;</span>

            <span class="n">other</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
            <span class="n">other</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">other</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 获取字符串长度</span>
    <span class="kt">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 获取容量</span>
    <span class="kt">size_t</span> <span class="n">getCapacity</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">capacity</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 检索字符串中的字符</span>
    <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">"Index out of range"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">"Index out of range"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// 添加字符到末尾</span>
    <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">resize</span><span class="p">(</span><span class="n">capacity</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">capacity</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">data</span><span class="p">[</span><span class="n">len</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
        <span class="n">data</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 追加字符串</span>
    <span class="kt">void</span> <span class="n">append</span><span class="p">(</span><span class="k">const</span> <span class="n">MyString</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">other</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">resize</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">other</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">strcat</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
        <span class="n">len</span> <span class="o">+=</span> <span class="n">other</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 打印字符串</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"(empty)"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="c1">// 重新分配内存</span>
    <span class="kt">void</span> <span class="n">resize</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">new_capacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span><span class="o">*</span> <span class="n">new_data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">new_capacity</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">strcpy</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">data</span><span class="p">;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">new_data</span><span class="p">;</span>
        <span class="n">capacity</span> <span class="o">=</span> <span class="n">new_capacity</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

</code></pre></div></div>

<h3 id="什么是模板的全特化">什么是模板的全特化？</h3>
<p>模板的全特化是在模板的原始定义之外针对某个特定类型，提供模板的特定实现。当我们为一个模板指定了所有模板参数的具体类型时，就是全特化。全特化完全替代了通用模板，对于特定的类型，编译器将使用全特化的版本。</p>

<p>为什么要使用全特化？</p>
<ol>
  <li>定制化特定类型的行为：对于某些特殊类型，需要不同于通用模板的实现。</li>
  <li>优化性能：针对特定类型，提供更高效的实现。</li>
  <li>解决特定类型的特殊需求：处理某些类型无法在通用模板中处理的特殊情况。</li>
</ol>

<h3 id="什么是模板的偏特化">什么是模板的偏特化？</h3>
<p>模板的偏特化是对模板参数进行部分特化，即不需要指定所有模板参数，而是针对某些参数或某些参数特性（如指针、引用、特定的类型模式）进行特化。</p>

<p>为什么要使用偏特化？</p>
<ol>
  <li>更灵活的特化方式：可以针对一类类型进行特化，而不局限于某个具体类型。</li>
  <li>处理类型的某些特征：如指针类型、引用类型、数组类型等。</li>
  <li>提高代码的复用性和可维护性：通过偏特化，可以减少重复代码。</li>
</ol>

<p><strong>偏特化只能用于类模板</strong>，不能直接对函数模板进行偏特化（但可以通过重载实现类似效果）。在偏特化时，需要在模板参数列表和类名中同时体现特化的部分。
编译器会优先选择最匹配的特化版本。如果有多个特化版本可以匹配，可能会导致编译错误，需要避免这种情况。</p>

<h3 id="const关键字">const关键字</h3>

<ol>
  <li>修饰变量：<code class="language-plaintext highlighter-rouge">const</code> 变量的值在初始化后不能被更改。</li>
  <li>修饰指针，可以细分为三种情况：
    <ul>
      <li><strong>指向常量的指针</strong>：指针指向的内容不可更改，但指针本身可以指向其他地址。</li>
      <li><strong>常量指针</strong>：指针本身不可更改，但指向的内容可以更改。</li>
    </ul>
  </li>
  <li>修饰函数参数，可以避免在函数内部修改该参数的值，这在传递引用或指针参数时尤为重要。
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">void</span> <span class="nf">printValue</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
     <span class="c1">// value = 10; // 错误，value 被 const 修饰</span>
     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>修饰类成员函数，表示该函数不会修改类的成员变量。只能在不修改类状态的成员函数上使用 <code class="language-plaintext highlighter-rouge">const</code>，适用于如 get 函数等。</li>
  <li>修饰返回值，在函数返回类型前加 <code class="language-plaintext highlighter-rouge">const</code> 可防止返回值在调用处被修改，例如返回对象的引用时防止被调用方修改。
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">getConstReference</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">static</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
     <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="volatile-关键字">volatile 关键字</h3>
<p><code class="language-plaintext highlighter-rouge">volatile</code> 告知编译器不要对变量进行优化，使程序在每次访问变量时重新从内存中读取数据。这种关键字通常用于特殊情况下，如硬件寄存器访问、多线程共享标志或中断处理程序中，以确保读取到的值是最新的。</p>

<p>例如：在多线程编程中，某些变量可能会被多个线程共享，可能会在一个线程中修改并在另一个线程中读取。如果没有 volatile 关键字，编译器可能会将该变量缓存到寄存器中，导致其他线程无法读取到最新的值。</p>

<h3 id="const-volatile什么意思">const volatile什么意思</h3>
<p><code class="language-plaintext highlighter-rouge">const volatile</code> 修饰的变量是只读的（不能被程序代码修改）并且易变的（编译器不能优化读取操作，必须每次都从内存中读取最新值）。常见于需要频繁读取最新值但不修改的场景，例如硬件寄存器或跨线程共享的只读标志。</p>

<p>例如：在多线程环境中，如果一个共享标志变量仅用于指示某种状态（如停止信号），一个线程可能会设置该标志，而其他线程只能读取该标志的值且不应修改它。将这个变量声明为 <code class="language-plaintext highlighter-rouge">const volatile</code> 可以避免优化，并确保读取到最新的值。</p>

<h3 id="c内存模型堆里面的内部碎片和外部碎片">C++内存模型，堆里面的内部碎片和外部碎片</h3>

<p>在 C++ 中，内存模型描述了程序如何管理和使用内存的布局。通常来说，C++ 内存模型分为以下几个区域：</p>

<ol>
  <li>
    <p><strong>栈区（Stack）</strong>：用于存储局部变量、函数调用时的参数和返回地址等。栈的内存是自动管理的，遵循“后进先出”的原则，即函数结束后栈内的局部变量自动销毁。栈内存分配效率高，但空间有限。</p>
  </li>
  <li>
    <p><strong>堆区（Heap）</strong>：用于动态分配的内存（例如通过 <code class="language-plaintext highlighter-rouge">new</code>、<code class="language-plaintext highlighter-rouge">malloc</code> 等）。堆内存由程序员手动管理，必须显式分配和释放。堆的大小仅受系统内存限制，适用于大数据结构和需要跨函数保留的数据。</p>
  </li>
  <li>
    <p><strong>全局区（静态存储区）</strong>：用于存储全局变量、静态变量和常量字符串，程序在启动时分配，直到程序结束才释放。</p>
  </li>
  <li>
    <p><strong>常量存储区</strong>：存放常量字符串，程序结束后由编译器释放。</p>
  </li>
  <li>
    <p><strong>代码区</strong>：存放程序的机器指令，由操作系统分配，用于存储程序的可执行代码，通常只读。</p>
  </li>
</ol>

<h4 id="堆内存中的内部碎片和外部碎片">堆内存中的内部碎片和外部碎片</h4>

<p>在堆内存中，碎片化是指内存管理系统由于分配和释放不同大小的内存块而导致的空闲内存片段。碎片化分为 <strong>内部碎片</strong> 和 <strong>外部碎片</strong>。</p>

<h5 id="1-内部碎片">1. 内部碎片</h5>

<p><strong>内部碎片</strong>是指分配的内存块中，因分配粒度或对齐的原因，实际使用的内存少于分配的内存，造成内存浪费。例如，当分配一个较小的对象（如 5 字节），但由于内存对齐的要求，分配器可能会为它分配 8 字节，这其中多余的 3 字节就是内部碎片。</p>

<p>内部碎片主要发生在以下情况下：</p>

<ul>
  <li><strong>内存对齐</strong>：为确保内存访问的效率，很多系统要求内存按照特定的字节对齐（如 4 字节、8 字节）。如果请求的内存块不满足对齐要求，分配器会分配比请求更多的内存。</li>
  <li><strong>固定大小的分配单元</strong>：某些分配器使用固定大小的内存块进行分配，如果请求的内存小于这个块的大小，则剩余部分形成内部碎片。</li>
</ul>

<h5 id="2-外部碎片">2. 外部碎片</h5>

<p><strong>外部碎片</strong>是指堆中存在很多小的、相互分散的空闲内存块，但这些内存块彼此不连续，因此无法满足较大的内存分配请求。例如，如果程序频繁分配和释放不同大小的内存块，可能会留下分散的小空闲块。这些空闲块的总和足够大，但因为不连续，导致无法分配较大的内存块。</p>

<p>外部碎片会影响程序性能，降低内存分配效率，可能导致内存不足的假象。堆内存的外部碎片主要通过以下方式产生：</p>

<ul>
  <li><strong>不规则的内存分配与释放</strong>：程序频繁分配和释放不同大小的内存块，导致空闲块分散。</li>
  <li><strong>缺乏内存整理</strong>：一些内存分配器不会自动合并相邻的空闲内存块，从而导致外部碎片。</li>
</ul>

<h3 id="内存碎片的处理方法">内存碎片的处理方法</h3>

<ul>
  <li><strong>内存池</strong>：预分配一定数量的内存块以满足相似大小的内存请求，从而减少内存碎片。</li>
  <li><strong>紧凑分配</strong>：一些内存管理器会自动合并相邻的空闲块，减少外部碎片。</li>
  <li><strong>自定义分配器</strong>：对特定数据结构自定义内存分配器，以便更有效地管理内存分配。</li>
</ul>

<h3 id="一般c的类的memory-layout有哪些成分c的对象在内存上长什么样如果涉及到继承呢">一般C++的类的memory layout有哪些成分，C++的对象在内存上长什么样？如果涉及到继承呢？</h3>
<ol>
  <li><strong>基本类的内存布局</strong>
 一个没有继承关系、虚函数或虚继承的简单 C++ 类的内存布局由以下成分组成：
    <ul>
      <li><strong>成员变量：</strong> 按照声明顺序存储在对象内存布局中，但编译器可能会根据内存对齐要求调整实际顺序。</li>
      <li><strong>对齐填充：</strong> 为了满足内存对齐要求，编译器会在成员变量之间或对象的结尾填充一些字节，以确保对象在内存中对齐。</li>
    </ul>
  </li>
  <li>
    <p><strong>带有虚函数的类的内存布局</strong>
 当一个类包含虚函数时，编译器会在该类的对象布局中添加一个 <strong>虚函数表指针（vptr）</strong>，指向该类的虚函数表（<code class="language-plaintext highlighter-rouge">vtable</code>）。<code class="language-plaintext highlighter-rouge">vtable</code> 是一个指针数组，指向类的虚函数实现。这使得运行时可以通过多态性动态调用不同的函数。在这种情况下，Base 类对象的内存布局会包含以下成分：</p>

    <ul>
      <li>vptr：指向虚函数表的指针，存储在对象的头部或其他位置。</li>
      <li>成员变量：x。
 虚函数表（vtable）则存储在程序的只读区域（常量存储区）中。</li>
    </ul>
  </li>
  <li><strong>带有单继承的类的内存布局</strong>
 在单继承情况下，派生类继承基类的成员变量和 vptr（如果基类有虚函数）。派生类对象的布局如下：
    <ul>
      <li>vptr：如果基类或派生类定义了虚函数，那么 vptr 会在对象中存在。如果基类已有虚函数表，派生类会复用或重写这个 vptr。</li>
      <li>基类成员：继承基类的成员变量，保持基类的布局。</li>
      <li>派生类自己的成员：存储在基类成员之后。</li>
    </ul>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
 <span class="nl">public:</span>
     <span class="kt">double</span> <span class="n">y</span><span class="p">;</span>
     <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func3</span><span class="p">();</span>
 <span class="p">};</span>
</code></pre></div>    </div>
    <p>在这种情况下，Derived 的内存布局包括：</p>

    <ul>
      <li>vptr：指向 Derived 类的 vtable，因为 Derived 覆盖了或增加了虚函数。</li>
      <li>基类成员：继承的 x。</li>
      <li>派生类成员：y。</li>
    </ul>
  </li>
  <li><strong>多重继承的内存布局</strong>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">class</span> <span class="nc">Base1</span> <span class="p">{</span>
 <span class="nl">public:</span>
     <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
     <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func1</span><span class="p">();</span>
 <span class="p">};</span>

 <span class="k">class</span> <span class="nc">Base2</span> <span class="p">{</span>
 <span class="nl">public:</span>
     <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
     <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func2</span><span class="p">();</span>
 <span class="p">};</span>

 <span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base1</span><span class="p">,</span> <span class="k">public</span> <span class="n">Base2</span> <span class="p">{</span>
 <span class="nl">public:</span>
     <span class="kt">double</span> <span class="n">c</span><span class="p">;</span>
 <span class="p">};</span>
</code></pre></div>    </div>
    <p>在这种情况下，Derived 的布局如下：</p>

    <ul>
      <li>Base1 的 vptr：指向 Base1 的 vtable。</li>
      <li>Base1 的成员：a。</li>
      <li>Base2 的 vptr：指向 Base2 的 vtable。</li>
      <li>Base2 的成员：b。</li>
      <li>Derived 的成员：c。</li>
    </ul>
  </li>
  <li><strong>虚继承的内存布局</strong>
 在虚继承中，派生类会共享基类的一个实例，从而避免多重继承中的菱形继承问题。编译器会为虚继承类添加一个 <strong>虚基类指针（vptr）</strong> 或 <strong>虚基类表指针（vbptr）</strong>，用于定位虚基类在对象内存中的位置。
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
 <span class="nl">public:</span>
     <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
 <span class="p">};</span>

 <span class="k">class</span> <span class="nc">Derived1</span> <span class="o">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>

 <span class="k">class</span> <span class="nc">Derived2</span> <span class="o">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>

 <span class="k">class</span> <span class="nc">MostDerived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Derived1</span><span class="p">,</span> <span class="k">public</span> <span class="n">Derived2</span> <span class="p">{</span>
     <span class="c1">// ...</span>
 <span class="p">};</span>
</code></pre></div>    </div>
    <p>在这种情况下，MostDerived 的布局可能包含：</p>

    <ul>
      <li>Derived1的 vfptr</li>
      <li>Derived1 的 vbptr：用于指向 Base 类的虚基类位置。</li>
      <li>Derived1的类成员</li>
      <li>Derived2的 vfptr</li>
      <li>Derived2 的 vbptr：用于指向 Base 类的虚基类位置。</li>
      <li>Derived2的类成员</li>
      <li>Base vfptr</li>
      <li>虚基类 Base：Base 的实例在内存中只有一份，且通过 vbptr 进行定位。</li>
    </ul>
  </li>
</ol>

<h3 id="虚继承">虚继承</h3>
<p>虚继承（Virtual Inheritance）是一种特殊的继承方式，主要用于解决多重继承中的菱形继承（或称钻石继承）问题。菱形继承问题通常会导致重复继承基类成员，造成 <strong>冗余和二义性</strong>，而虚继承可以确保派生类共享基类的唯一实例。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived1</span> <span class="o">:</span> <span class="k">public</span> <span class="k">virtual</span> <span class="n">Base</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">Derived2</span> <span class="o">:</span> <span class="k">public</span> <span class="k">virtual</span> <span class="n">Base</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>

<span class="k">class</span> <span class="nc">MostDerived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Derived1</span><span class="p">,</span> <span class="k">public</span> <span class="n">Derived2</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
</code></pre></div></div>

<p>在启用虚继承后，C++ 编译器会在 Derived1 和 Derived2 中添加一个虚基类表指针（vbptr），指向 Base 的唯一实例位置。在实例化 MostDerived 时，编译器会根据虚基类表找到并共享 Base 的实例。</p>

<p>因此，MostDerived 的内存布局可能如下：</p>

<ul>
  <li>Derived1 的 vbptr：用于指向 Base 的唯一实例。</li>
  <li>Derived2 的 vbptr：用于指向 Base 的唯一实例。</li>
  <li>唯一的 Base 实例。</li>
  <li>MostDerived 自己的成员（如果有）</li>
</ul>

<h3 id="如果一个类继承了有虚函数的类父类会存在在子类中吗">如果一个类继承了有虚函数的类，父类会存在在子类中吗</h3>
<p>会的，派生类对象中包含基类的数据成员，因此在派生类对象中基类的部分会存在。</p>

<h3 id="父类转子类安全吗子类转父类呢">父类转子类安全吗？子类转父类呢？</h3>
<p><strong>基类指针或引用转换为派生类指针或引用通常是不安全的</strong>，因为基类对象不一定包含派生类的所有成员。如果直接将一个基类对象的指针或引用转换为派生类类型，并尝试访问派生类的成员，可能会导致未定义行为。</p>

<p>如果基类指针或引用实际上指向的是一个派生类对象，则可以通过 <code class="language-plaintext highlighter-rouge">dynamic_cast</code> 进行安全的转换。<code class="language-plaintext highlighter-rouge">dynamic_cast</code> 会在运行时检查类型，如果转换失败会返回 <code class="language-plaintext highlighter-rouge">nullptr</code>（对于指针）或抛出 <code class="language-plaintext highlighter-rouge">bad_cast</code> 异常（对于引用）。</p>

<p><strong>将派生类指针或引用转换为基类指针或引用通常是安全的</strong>。因为派生类包含基类的所有成员，因此将派生类对象视为基类对象不会导致内存或成员访问问题。这种转换可以通过 <strong>隐式转换</strong> 或 <strong>static_cast</strong> 安全地完成。</p>
<h3 id="假设是64位的机器一个空的类占多大内存如果这个类包含一个虚函数呢如果有一个类继承了空类大小是多少分类讨论">假设是64位的机器，一个空的类占多大内存，如果这个类包含一个虚函数呢？如果有一个类继承了空类，大小是多少（分类讨论）？</h3>

<ul>
  <li><strong>空类</strong>：通常占 <code class="language-plaintext highlighter-rouge">1</code> 字节。</li>
  <li><strong>含虚函数的空类</strong>：占 <code class="language-plaintext highlighter-rouge">8</code> 字节（在 64 位系统上，为虚函数表指针大小）。</li>
  <li><strong>继承自空类的类</strong>：
    <ul>
      <li>如果没有额外成员，通常应用空基类优化，占 <code class="language-plaintext highlighter-rouge">1</code> 字节。</li>
      <li>如果包含其他成员，则仅占成员的大小（空基类不增加额外空间）。</li>
    </ul>
  </li>
  <li><strong>继承自含虚函数的空类的类</strong>：大小至少为 <code class="language-plaintext highlighter-rouge">8</code> 字节（包含 <code class="language-plaintext highlighter-rouge">vptr</code>），即使派生类本身没有增加成员。</li>
  <li>
    <h3 id="虚表里除了可能有虚函数还可能有什么">虚表里除了可能有虚函数，还可能有什么？</h3>
    <ol>
      <li>虚表通常包含一个指向类型信息的指针，用于支持 typeid 和 dynamic_cast 等操作。这个指针指向的结构包含了当前类的类型信息，以便在运行时能够识别对象的实际类型。</li>
      <li>在涉及 <strong>虚继承</strong> 的多重继承中，虚表还可能包含 虚基类偏移指针，用于支持虚基类的定位。当派生类通过虚继承的方式继承基类时，虚基类在对象布局中的位置并不是固定的，因为不同的派生路径会共享同一个虚基类实例。</li>
    </ol>
  </li>
</ul>

<h3 id="如果一个函数是成员模板函数可以被声明为虚函数吗">如果一个函数是成员模板函数，可以被声明为虚函数吗？</h3>
<p>在 C++ 中，<strong>成员模板函数不能被声明为虚函数</strong>。这是因为模板函数的机制和虚函数的机制在设计和实现上存在冲突。</p>

<ol>
  <li>
    <p><strong>模板函数的编译时多态性</strong>：<br />
模板函数是通过 <strong>编译时多态</strong> 实现的。编译器会在编译期间根据模板的具体类型生成函数的代码，即模板函数的实例化发生在编译时。这意味着，模板函数在编译时会根据使用的类型参数生成特定版本的代码。</p>
  </li>
  <li>
    <p><strong>虚函数的运行时多态性</strong>：<br />
虚函数依赖于 <strong>运行时多态</strong>，通过虚函数表（vtable）在运行时动态绑定函数。这要求在程序执行时通过虚表指针（<code class="language-plaintext highlighter-rouge">vptr</code>）来调用合适的虚函数实现。</p>
  </li>
</ol>

<p>由于模板函数在编译时实例化，其生成的具体函数可能是无限多种类型的组合，无法在虚表中预先创建一个模板函数的实例。因此，C++ 标准不允许将模板成员函数声明为虚函数。</p>

<h3 id="虚函数可以内联吗">虚函数可以内联吗？</h3>
<p>在 C++ 中，<strong>虚函数可以被声明为内联函数</strong>，但是在实际调用中是否会被内联展开，<strong>取决于编译器是否能够在编译时确定具体的调用目标</strong>。虚函数的运行时多态性机制使得它们通常不符合内联的条件，但在特定情况下，虚函数可以被内联。</p>

<ol>
  <li>
    <p><strong>虚函数的运行时多态性</strong>：<br />
虚函数是通过虚函数表（vtable）实现运行时多态性的，在调用时根据对象的实际类型选择具体的函数实现。这种机制通常需要在运行时确定调用的具体实现，因此通常通过基类指针或引用调用虚函数时，编译器在编译期无法确定具体的实现。</p>
  </li>
  <li>
    <p><strong>内联的编译时展开</strong>：<br />
内联函数的目的是在编译时直接用函数体替换函数调用，从而避免函数调用的开销（如栈帧管理和参数传递）。这要求编译器在编译期就知道函数的具体实现，以便将其展开。</p>
  </li>
</ol>

<p>虚函数的运行时多态特性和内联函数的编译时展开机制存在矛盾，因此虚函数通常难以被内联。</p>

<ul>
  <li><strong>虚函数可以声明为内联</strong>，但实际内联展开取决于编译器的判断。</li>
  <li>如果通过具体对象（非指针或引用）调用虚函数，编译器可能会内联。</li>
  <li>非多态调用（例如派生类中直接调用基类的虚函数）也可能被内联。</li>
  <li>典型的多态调用（通过基类指针或引用调用虚函数）通常无法内联，因为编译器在编译期无法确定具体实现。</li>
  <li>
    <h3 id="optional取size是多大">optional<bool>取size是多大？</bool></h3>
    <p>大小通常为 2 个字节，因为需要额外空间来存储“是否包含值”的状态。</p>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">std::optional</code> 是 C++17 引入的一个标准库模板类，定义在 <code class="language-plaintext highlighter-rouge">&lt;optional&gt;</code> 头文件中。它用于表示一个可能包含值、也可能不包含值的对象，通常用于替代返回空指针或特殊值来表示“值缺失”的情况。</p>

<h5 id="stdoptional-的主要特点"><code class="language-plaintext highlighter-rouge">std::optional</code> 的主要特点</h5>

<ul>
  <li><strong>可选值</strong>：<code class="language-plaintext highlighter-rouge">std::optional&lt;T&gt;</code> 是一个包装类型，它可以存储类型 <code class="language-plaintext highlighter-rouge">T</code> 的一个值，或不存储任何值。</li>
  <li><strong>语义明确</strong>：<code class="language-plaintext highlighter-rouge">std::optional</code> 可以更清晰地表达“值可能不存在”这种语义，而不必使用 <code class="language-plaintext highlighter-rouge">nullptr</code> 或特定的标记值（如 <code class="language-plaintext highlighter-rouge">-1</code> 或 <code class="language-plaintext highlighter-rouge">0</code>）来表示。</li>
  <li><strong>安全</strong>：在函数返回类型中使用 <code class="language-plaintext highlighter-rouge">std::optional</code> 可以避免返回裸指针或特定值带来的潜在风险，增强代码的安全性和可读性。</li>
</ul>

<h5 id="stdoptional-的典型用法"><code class="language-plaintext highlighter-rouge">std::optional</code> 的典型用法</h5>

<ol>
  <li>
    <p><strong>替代返回值</strong>：<br />
<code class="language-plaintext highlighter-rouge">std::optional</code> 常用于表示函数的返回值可能为空。例如，一个查找函数可以返回 <code class="language-plaintext highlighter-rouge">std::optional</code> 表示找到的值或未找到的情况。</p>
  </li>
  <li>
    <p><strong>替代指针</strong>：<br />
在某些情况下，<code class="language-plaintext highlighter-rouge">std::optional</code> 可以用来代替指针，从而避免使用空指针（<code class="language-plaintext highlighter-rouge">nullptr</code>）来表示值的缺失。</p>
  </li>
  <li>
    <p><strong>可选参数</strong>：<br />
可以用 <code class="language-plaintext highlighter-rouge">std::optional</code> 来表示函数的可选参数，而不是重载函数或设置默认值。</p>
  </li>
</ol>

<h5 id="主要成员和操作">主要成员和操作</h5>

<ul>
  <li><strong>默认构造函数</strong>：构造一个不包含值的 <code class="language-plaintext highlighter-rouge">std::optional</code>。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">std::nullopt</code></strong>：一个表示空状态的特殊常量，可以赋给 <code class="language-plaintext highlighter-rouge">std::optional</code> 来表示没有值。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">operator bool</code></strong>：可以将 <code class="language-plaintext highlighter-rouge">std::optional</code> 转换为布尔值，以判断是否包含值。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">value()</code></strong>：获取 <code class="language-plaintext highlighter-rouge">optional</code> 中的值。如果没有值，则会抛出 <code class="language-plaintext highlighter-rouge">std::bad_optional_access</code> 异常。</li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">value_or(default_value)</code></strong>：如果有值，返回值；否则返回 <code class="language-plaintext highlighter-rouge">default_value</code>。</p>
  </li>
  <li>提供了更安全、语义更明确的方式来表示“可选值”。</li>
  <li>避免了返回特殊值或空指针的风险。</li>
  <li>增强代码的可读性和维护性。</li>
</ul>

<h3 id="描述一下c编译的整个过程">描述一下C++编译的整个过程</h3>
<p>整个 C++ 编译过程的各个阶段如下：</p>

<ol>
  <li>预处理：处理宏、头文件和条件编译指令，生成纯净的.i代码文件。</li>
  <li>编译：将预处理后的代码编译为.s汇编代码，进行语法检查和优化。</li>
  <li>汇编：将汇编代码转换为机器码，生成.o目标文件。</li>
  <li>链接：将多个目标文件和库文件整合，解析符号，生成可执行文件。</li>
</ol>

<h3 id="如果头文件定义了函数源文件不实现会在哪个环节报错如果构建的是静态库会报错吗">如果头文件定义了函数，源文件不实现，会在哪个环节报错？如果构建的是静态库，会报错吗？</h3>
<p>普通程序（非库）中在 <strong>链接阶段</strong> 会出现报错。这是因为编译器在编译每个源文件时并不会检查函数的实现是否存在，它只检查函数的声明是否存在。当所有源文件编译成目标文件后，链接器会尝试将所有的符号（包括函数和变量）解析到具体的实现位置。</p>

<p>当构建静态库时：</p>
<ul>
  <li>如果头文件中声明的函数没有实现，那么<strong>构建库时不会报错</strong>。</li>
  <li>这是因为静态库的构建过程仅涉及将各个目标文件打包到一个归档文件中（如 .a 文件），<strong>并不会执行链接过程</strong>。</li>
  <li>因此，即使静态库中存在未实现的函数，只要没有实际使用该函数，就不会触发错误。</li>
  <li><strong>即便是库内部调用了该函数也不会报错。（因为静态库只进行编译、汇编生成目标文件，并不会进行链接，这与动态库不同。）</strong></li>
</ul>

<p>但是，<strong>当静态库被其他程序链接并使用到未实现的函数时，链接器会在 链接阶段 报错</strong>，因为它无法在静态库或程序中找到该函数的定义。</p>

<p>对于动态库：</p>
<ul>
  <li>构建动态库时，<strong>如果未实现的函数没有在库内部被调用</strong>，不会报错；但如果<strong>库内部代码引用了未实现的函数</strong>，则在链接阶段会报错。</li>
  <li>在<strong>客户端使用动态库时，编译和链接阶段一般不会报错</strong>，因为动态库的符号解析是在运行时进行的，但运行时若调用了未实现的函数，动态链接器会尝试解析该符号，找不到实现时会导致运行时错误，报出类似“未定义符号”的错误。。</li>
  <li><strong>延迟加载机制</strong> 可能使得未实现的函数仅在被调用时引发运行时错误，而不会在程序加载时立即报错。</li>
</ul>

<h3 id="对静态库和动态库的理解">对静态库和动态库的理解</h3>

<h4 id="1-静态库static-library">1. 静态库（Static Library）</h4>

<p>静态库是在<strong>编译时</strong>被直接链接到程序中的库。它通常是一个归档文件（例如 <code class="language-plaintext highlighter-rouge">.lib</code> 在 Windows 上或 <code class="language-plaintext highlighter-rouge">.a</code> 在 Unix/Linux 上），包含了多个目标文件（编译生成的 <code class="language-plaintext highlighter-rouge">.o</code> 文件），每个目标文件中包含了一组函数或类的实现。</p>

<ul>
  <li><strong>编译时链接</strong>：在程序编译过程中，静态库会被直接嵌入到生成的可执行文件中。链接完成后，库的代码被复制到每个使用它的可执行文件中。</li>
  <li><strong>独立性</strong>：由于静态库的代码在编译时已嵌入可执行文件中，运行时不需要额外的库文件。这使得静态链接的程序可以独立分发，无需依赖外部库。</li>
  <li><strong>占用更多磁盘空间</strong>：因为每个使用静态库的程序都会包含一份库的代码，所以多个程序使用同一个静态库时会有重复的代码拷贝，从而占用更多磁盘空间。</li>
  <li><strong>性能</strong>：在性能上，由于库代码已经嵌入可执行文件，不需要在运行时加载，因此启动速度可能比动态库稍快。</li>
  <li><strong>更新困难</strong>：如果静态库有更新，需要重新编译链接所有使用它的程序，生成新的可执行文件。</li>
</ul>

<h5 id="适用场景">适用场景</h5>

<ul>
  <li><strong>嵌入式系统或独立分发</strong>：当程序需要独立运行，不依赖外部库（如某些嵌入式系统）时，可以使用静态库。</li>
  <li><strong>性能要求高</strong>：在对启动速度要求较高的场景中，由于静态库无需加载，可以减少启动时的开销。</li>
</ul>

<h4 id="2-动态库dynamic-library">2. 动态库（Dynamic Library）</h4>

<p>动态库是在<strong>运行时</strong>被加载到内存中并链接到程序的库。动态库的文件扩展名通常是 <code class="language-plaintext highlighter-rouge">.dll</code>（Windows）或 <code class="language-plaintext highlighter-rouge">.so</code>（Unix/Linux）。在程序运行时，操作系统会将动态库加载到内存中，并将程序中的函数调用链接到动态库中的函数实现。</p>

<ul>
  <li><strong>运行时链接</strong>：程序在启动时或在需要时加载动态库，这种链接方式称为延迟链接或运行时链接。它允许多个程序共享同一个动态库，节省内存空间。</li>
  <li><strong>节省内存</strong>：多个运行中的程序可以共享同一个动态库的内存实例，而不需要每个程序都包含一份库的代码，这样可以显著节省内存资源。</li>
  <li><strong>更新灵活</strong>：因为动态库在程序运行时加载，如果动态库有更新，不需要重新编译程序。只需用新版本的动态库替换旧版本即可实现程序的更新。</li>
  <li><strong>启动时加载或延迟加载</strong>：动态库可以在程序启动时加载，也可以在程序运行期间按需加载，从而提高启动速度并减少不必要的资源消耗。</li>
</ul>

<h5 id="适用场景-1">适用场景</h5>

<ul>
  <li><strong>共享库</strong>：当多个程序需要共享库代码，并且希望尽可能节省内存资源时，动态库是一个好的选择。</li>
  <li><strong>便于更新和维护</strong>：动态库更适合需要频繁更新的系统，尤其是在大型系统中，可以随时替换动态库而不影响程序的其他部分。</li>
</ul>

<table>
  <thead>
    <tr>
      <th>特性</th>
      <th>静态库</th>
      <th>动态库</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>链接时间</strong></td>
      <td>编译时链接</td>
      <td>运行时链接</td>
    </tr>
    <tr>
      <td><strong>文件大小</strong></td>
      <td>更大，代码复制到每个可执行文件中</td>
      <td>更小，多个程序共享同一个库</td>
    </tr>
    <tr>
      <td><strong>内存占用</strong></td>
      <td>每个进程独立占用内存</td>
      <td>多个进程共享内存</td>
    </tr>
    <tr>
      <td><strong>启动速度</strong></td>
      <td>较快（不需要加载库）</td>
      <td>稍慢（需要加载库）</td>
    </tr>
    <tr>
      <td><strong>更新方式</strong></td>
      <td>需要重新编译、链接</td>
      <td>替换库文件即可</td>
    </tr>
    <tr>
      <td><strong>应用场景</strong></td>
      <td>独立分发、嵌入式系统</td>
      <td>共享库、频繁更新的系统</td>
    </tr>
  </tbody>
</table>

<h5 id="总结">总结</h5>

<ul>
  <li><strong>静态库</strong>：适用于不希望程序依赖外部文件的场景，启动速度快，但占用磁盘空间较大，不易更新。</li>
  <li><strong>动态库</strong>：适用于需要多个程序共享库、需要频繁更新库的场景，占用内存少，便于维护和更新，但启动时稍有开销。</li>
</ul>

<p>在实际开发中，选择静态库还是动态库通常取决于应用程序的需求、性能要求、维护方式以及系统架构的设计。</p>

<h3 id="一个shared_ptr大小是多大unique_ptr呢不同智能指针性能上有什么区别如果只是用指针解引用性能上有区别吗">一个shared_ptr大小是多大，unique_ptr呢？不同智能指针性能上有什么区别？如果只是用指针解引用，性能上有区别吗？</h3>

<ol>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">std::unique_ptr</code> 的大小</strong></p>

    <p><code class="language-plaintext highlighter-rouge">std::unique_ptr</code> 的大小通常是 <strong>一个指针的大小</strong>，即 8 字节（在 64 位系统上）。这是因为 <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> 只需要一个指针来管理动态分配的对象。</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">std::unique_ptr</code> 是一个独占所有权的智能指针，意味着同一时刻只能有一个 <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> 指向特定的对象。</li>
      <li>在对象被销毁或 <code class="language-plaintext highlighter-rouge">unique_ptr</code> 被重置时，它会自动释放所管理的资源。</li>
      <li>因为没有额外的引用计数等信息，所以 <code class="language-plaintext highlighter-rouge">unique_ptr</code> 的内存开销较小。</li>
    </ul>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">std::shared_ptr</code> 的大小</strong></p>

    <p><code class="language-plaintext highlighter-rouge">std::shared_ptr</code> 的大小通常是 <strong>两个指针的大小</strong>，即 16 字节（在 64 位系统上）。这两个指针分别指向：</p>

    <ul>
      <li>被管理的对象。</li>
      <li>一个 <strong>控制块</strong>（control block），包含引用计数等信息。</li>
    </ul>
  </li>
</ol>

<h5 id="不同智能指针的性能对比">不同智能指针的性能对比</h5>

<ol>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">std::unique_ptr</code> 的性能</strong></p>

    <ul>
      <li><strong>独占所有权</strong>：<code class="language-plaintext highlighter-rouge">unique_ptr</code> 的独占所有权机制使它不需要引用计数，因此操作非常轻量。</li>
      <li><strong>无额外开销</strong>：由于没有控制块和引用计数，<code class="language-plaintext highlighter-rouge">unique_ptr</code> 在创建、销毁、复制和移动时的开销都非常小。</li>
      <li><strong>适合单线程场景</strong>：<code class="language-plaintext highlighter-rouge">unique_ptr</code> 的独占所有权机制不需要多线程同步，因此在单线程场景中性能非常好。</li>
    </ul>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">std::shared_ptr</code> 的性能</strong></p>

    <ul>
      <li><strong>引用计数</strong>：<code class="language-plaintext highlighter-rouge">shared_ptr</code> 使用控制块来跟踪引用计数，因此在每次创建、复制和销毁时都需要对引用计数进行增减操作。这增加了额外的开销。</li>
      <li><strong>线程安全</strong>：<code class="language-plaintext highlighter-rouge">shared_ptr</code> 的引用计数更新是线程安全的，这意味着在多线程环境中，可以安全地共享 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 对象。然而，为了保证线程安全，<code class="language-plaintext highlighter-rouge">shared_ptr</code> 引用计数的增减通常会使用原子操作，这在多线程环境中会带来额外的开销。</li>
      <li><strong>适合多线程共享资源</strong>：当需要多个对象或多个线程共享同一个动态分配的对象时，<code class="language-plaintext highlighter-rouge">shared_ptr</code> 是合适的选择，但在频繁的创建、销毁、复制操作中，其性能劣于 <code class="language-plaintext highlighter-rouge">unique_ptr</code>。</li>
    </ul>
  </li>
</ol>

<p>在智能指针解引用方面，<code class="language-plaintext highlighter-rouge">std::shared_ptr</code> 和 <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> 的性能几乎是相同的，因为解引用操作只是获取被管理对象的地址，并不涉及控制块或引用计数的更改。</p>

<p>在实际应用中，应该根据需要选择合适的智能指针类型：若对象需要唯一所有权且性能要求高，使用 <code class="language-plaintext highlighter-rouge">unique_ptr</code>；若对象需要共享所有权，特别是在多线程场景下，使用 <code class="language-plaintext highlighter-rouge">shared_ptr</code>。</p>

<h3 id="一个-shared_ptr-指向另一个地址时操作的复杂性和开销主要来源于以下几个因素">一个 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 指向另一个地址时，操作的复杂性和开销主要来源于以下几个因素：</h3>

<h5 id="1-引用计数的递减和递增">1. <strong>引用计数的递减和递增</strong></h5>

<p>当你将 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 重新指向另一个地址时，操作系统会执行以下步骤：</p>

<ul>
  <li><strong>递减旧对象的引用计数</strong>：将 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 从旧对象指向新对象时，会先减少旧对象的引用计数，如果引用计数降为 0，旧对象会被销毁。</li>
  <li><strong>递增新对象的引用计数</strong>：接着，将 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 指向的新对象的引用计数加 1。</li>
</ul>

<p>这些操作是原子操作，在多线程环境中具有一定的开销，尤其当多个线程频繁执行这样的操作时。每次引用计数的增减都会触发缓存同步和内存屏障，增加系统开销。</p>

<h5 id="2-旧对象的销毁若引用计数归零">2. <strong>旧对象的销毁（若引用计数归零）</strong></h5>

<p>如果原来指向的对象在重置后引用计数降为 0，<code class="language-plaintext highlighter-rouge">shared_ptr</code> 会销毁该对象：</p>

<ul>
  <li><strong>析构函数的调用</strong>：当引用计数降为 0 时，<code class="language-plaintext highlighter-rouge">shared_ptr</code> 会调用对象的析构函数。对象的析构可能需要释放资源，如文件句柄、内存等。这会带来一定的额外开销。</li>
  <li><strong>释放控制块</strong>：<code class="language-plaintext highlighter-rouge">shared_ptr</code> 的控制块也会被销毁和释放，这涉及一次堆内存的释放操作。如果频繁重置 <code class="language-plaintext highlighter-rouge">shared_ptr</code>，多次内存分配和释放会增加开销。</li>
</ul>

<h5 id="3-在多线程环境中增减引用计数的竞争">3. <strong>在多线程环境中，增减引用计数的竞争</strong></h5>

<p>当多个线程频繁对同一个 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 进行重置操作时，增减引用计数的竞争会进一步增加性能开销：</p>

<ul>
  <li><strong>竞争条件</strong>：在多线程环境中，如果多个线程频繁地对同一个 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 重置为不同对象，则引用计数的增减操作可能发生竞争，导致性能下降。每次引用计数的更改都会触发原子操作的锁定，影响 CPU 的缓存一致性。</li>
  <li><strong>伪共享</strong>：当多个线程频繁更新同一 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 的引用计数，这些操作可能发生在同一缓存行上，导致伪共享，进一步增加缓存一致性协议的压力。</li>
</ul>

<h5 id="4-内存分配和释放的频率">4. <strong>内存分配和释放的频率</strong></h5>

<p>如果 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 重新指向新地址的操作非常频繁，且每次都是指向不同的对象，会导致以下开销：</p>

<ul>
  <li><strong>频繁的控制块分配和释放</strong>：每次指向一个新对象时，<code class="language-plaintext highlighter-rouge">shared_ptr</code> 会为新对象分配一个控制块。频繁的内存分配和释放会影响程序的内存管理性能，尤其是在堆上进行小块内存分配时，开销较大。</li>
  <li><strong>潜在的内存碎片化</strong>：频繁分配和释放小块内存可能会导致内存碎片化，进一步影响内存分配效率。</li>
</ul>

<h5 id="5-析构和构造的开销">5. <strong>析构和构造的开销</strong></h5>

<p>每次 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 被重置到不同的对象时，如果新的对象和旧对象的生命周期需要被管理，就可能会多次调用构造和析构函数。特别是当指向的对象包含复杂的成员或资源时，这些构造和析构函数的开销也会加大。</p>

<h5 id="6-避免开销的方法">6. <strong>避免开销的方法</strong></h5>

<p>为了减少上述操作带来的开销，可以考虑以下方法：</p>

<ul>
  <li><strong>使用 <code class="language-plaintext highlighter-rouge">weak_ptr</code></strong>：如果只是短暂指向新对象，可以考虑使用 <code class="language-plaintext highlighter-rouge">weak_ptr</code>，因为它不会更改引用计数，减少了原子操作的开销。</li>
  <li><strong>使用 <code class="language-plaintext highlighter-rouge">std::move</code></strong>：如果旧对象不再需要，可以使用 <code class="language-plaintext highlighter-rouge">std::move</code> 将 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 直接转移给另一个 <code class="language-plaintext highlighter-rouge">shared_ptr</code>，避免引用计数的增减。</li>
  <li><strong>使用 <code class="language-plaintext highlighter-rouge">reset()</code> 重置为 nullptr</strong>：如果 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 已经不再需要，可以先使用 <code class="language-plaintext highlighter-rouge">reset()</code> 将其重置为 <code class="language-plaintext highlighter-rouge">nullptr</code>，这样旧对象会立即释放，再赋值新对象，避免频繁的引用计数竞争。</li>
</ul>

<h3 id="手动实现shared_ptr和unique_ptr">手动实现shared_ptr和unique_ptr</h3>
<p>手动实现 <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> 和 <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> 的核心在于理解它们的基本特性：<code class="language-plaintext highlighter-rouge">std::unique_ptr</code> 实现独占所有权，而 <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> 则实现共享所有权。为了实现这两个智能指针类，我们将从管理动态内存的角度来实现这两种指针的基本功能。</p>

<ol>
  <li>
    <p>手动实现 <code class="language-plaintext highlighter-rouge">unique_ptr</code></p>

    <p><code class="language-plaintext highlighter-rouge">unique_ptr</code> 具有独占所有权，因此它只需持有一个指向对象的指针，并在析构时删除它。复制 <code class="language-plaintext highlighter-rouge">unique_ptr</code> 是不允许的，但它可以通过移动语义转移所有权。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
 <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
 <span class="k">class</span> <span class="nc">MyUniquePtr</span> <span class="p">{</span>
 <span class="nl">private:</span>
     <span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">;</span>

 <span class="nl">public:</span>
     <span class="c1">// 构造函数</span>
     <span class="k">explicit</span> <span class="n">MyUniquePtr</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="o">:</span> <span class="n">ptr</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{}</span>

     <span class="c1">// 禁止拷贝构造和赋值</span>
     <span class="n">MyUniquePtr</span><span class="p">(</span><span class="k">const</span> <span class="n">MyUniquePtr</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
     <span class="n">MyUniquePtr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">MyUniquePtr</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

     <span class="c1">// 移动构造函数</span>
     <span class="n">MyUniquePtr</span><span class="p">(</span><span class="n">MyUniquePtr</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">ptr</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">other</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
     <span class="p">}</span>

     <span class="c1">// 移动赋值操作符</span>
     <span class="n">MyUniquePtr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">MyUniquePtr</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
         <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
             <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span>          <span class="c1">// 释放当前对象</span>
             <span class="n">ptr</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>     <span class="c1">// 转移所有权</span>
             <span class="n">other</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="c1">// 清空源对象</span>
         <span class="p">}</span>
         <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
     <span class="p">}</span>

     <span class="c1">// 解引用操作符</span>
     <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="p">}</span>
     <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span> <span class="p">}</span>

     <span class="c1">// 获取原始指针</span>
     <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span> <span class="p">}</span>

     <span class="c1">// 释放所有权</span>
     <span class="n">T</span><span class="o">*</span> <span class="n">release</span><span class="p">()</span> <span class="p">{</span>
         <span class="n">T</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
         <span class="n">ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
         <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
     <span class="p">}</span>

     <span class="c1">// 重置指针</span>
     <span class="kt">void</span> <span class="n">reset</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
         <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span>
         <span class="n">ptr</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
     <span class="p">}</span>

     <span class="c1">// 析构函数</span>
     <span class="o">~</span><span class="n">MyUniquePtr</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span> <span class="p">}</span>
 <span class="p">};</span>

 <span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">MyUniquePtr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

     <span class="n">MyUniquePtr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>  <span class="c1">// 移动所有权</span>
     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p1</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="p">{</span>
         <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"p1 is now empty."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li><strong>禁止拷贝构造和赋值</strong>：通过删除拷贝构造函数和赋值操作符，确保 <code class="language-plaintext highlighter-rouge">unique_ptr</code> 的独占所有权特性。</li>
      <li><strong>移动构造和移动赋值</strong>：实现了移动构造函数和移动赋值操作符，允许所有权的转移。</li>
      <li><strong>析构</strong>：在析构函数中释放所管理的资源。</li>
    </ul>
  </li>
  <li>
    <p>手动实现 <code class="language-plaintext highlighter-rouge">shared_ptr</code></p>

    <p><code class="language-plaintext highlighter-rouge">shared_ptr</code> 允许多个对象共享所有权，因此需要一个引用计数来跟踪有多少个 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 指向同一个对象。当引用计数减为零时才释放资源。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
 <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
 <span class="k">class</span> <span class="nc">MySharedPtr</span> <span class="p">{</span>
 <span class="nl">private:</span>
     <span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">;</span>
     <span class="kt">int</span><span class="o">*</span> <span class="n">ref_count</span><span class="p">;</span>

     <span class="kt">void</span> <span class="n">release</span><span class="p">()</span> <span class="p">{</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">ref_count</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="p">(</span><span class="o">*</span><span class="n">ref_count</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
             <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span>
             <span class="k">delete</span> <span class="n">ref_count</span><span class="p">;</span>
         <span class="p">}</span>
     <span class="p">}</span>

 <span class="nl">public:</span>
     <span class="c1">// 构造函数</span>
     <span class="k">explicit</span> <span class="n">MySharedPtr</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="o">:</span> <span class="n">ptr</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">ref_count</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="p">{}</span>

     <span class="c1">// 拷贝构造函数</span>
     <span class="n">MySharedPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">MySharedPtr</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">:</span> <span class="n">ptr</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">ptr</span><span class="p">),</span> <span class="n">ref_count</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">ref_count</span><span class="p">)</span> <span class="p">{</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">ref_count</span><span class="p">)</span> <span class="p">{</span>
             <span class="o">++</span><span class="p">(</span><span class="o">*</span><span class="n">ref_count</span><span class="p">);</span>
         <span class="p">}</span>
     <span class="p">}</span>

     <span class="c1">// 赋值操作符</span>
     <span class="n">MySharedPtr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">MySharedPtr</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
         <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
             <span class="n">release</span><span class="p">();</span>  <span class="c1">// 释放当前对象</span>

             <span class="n">ptr</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
             <span class="n">ref_count</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">ref_count</span><span class="p">;</span>
             <span class="k">if</span> <span class="p">(</span><span class="n">ref_count</span><span class="p">)</span> <span class="p">{</span>
                 <span class="o">++</span><span class="p">(</span><span class="o">*</span><span class="n">ref_count</span><span class="p">);</span>  <span class="c1">// 增加引用计数</span>
             <span class="p">}</span>
         <span class="p">}</span>
         <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
     <span class="p">}</span>

     <span class="c1">// 移动构造函数</span>
     <span class="n">MySharedPtr</span><span class="p">(</span><span class="n">MySharedPtr</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">ptr</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">ptr</span><span class="p">),</span> <span class="n">ref_count</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">ref_count</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">other</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
         <span class="n">other</span><span class="p">.</span><span class="n">ref_count</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
     <span class="p">}</span>

     <span class="c1">// 移动赋值操作符</span>
     <span class="n">MySharedPtr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">MySharedPtr</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
         <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
             <span class="n">release</span><span class="p">();</span>  <span class="c1">// 释放当前对象</span>

             <span class="n">ptr</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
             <span class="n">ref_count</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">ref_count</span><span class="p">;</span>
             <span class="n">other</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
             <span class="n">other</span><span class="p">.</span><span class="n">ref_count</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
         <span class="p">}</span>
         <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
     <span class="p">}</span>

     <span class="c1">// 解引用操作符</span>
     <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="p">}</span>
     <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span> <span class="p">}</span>

     <span class="c1">// 获取引用计数</span>
     <span class="kt">int</span> <span class="n">use_count</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ref_count</span> <span class="o">?</span> <span class="o">*</span><span class="n">ref_count</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

     <span class="c1">// 析构函数</span>
     <span class="o">~</span><span class="n">MySharedPtr</span><span class="p">()</span> <span class="p">{</span> <span class="n">release</span><span class="p">();</span> <span class="p">}</span>
 <span class="p">};</span>

 <span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">MySharedPtr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"p1 use count: "</span> <span class="o">&lt;&lt;</span> <span class="n">p1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

     <span class="p">{</span>
         <span class="n">MySharedPtr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>  <span class="c1">// 共享所有权</span>
         <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"p1 use count after p2: "</span> <span class="o">&lt;&lt;</span> <span class="n">p1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
         <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"p2 use count: "</span> <span class="o">&lt;&lt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
     <span class="p">}</span>  <span class="c1">// p2 离开作用域，引用计数减 1</span>

     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"p1 use count after p2 goes out of scope: "</span> <span class="o">&lt;&lt;</span> <span class="n">p1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div>    </div>

    <ul>
      <li><strong>引用计数管理</strong>：使用 <code class="language-plaintext highlighter-rouge">int* ref_count</code> 来记录当前对象的引用次数。</li>
      <li><strong>拷贝控制</strong>：拷贝构造和赋值操作符会增加引用计数，确保多个 <code class="language-plaintext highlighter-rouge">MySharedPtr</code> 对象安全地共享同一资源。</li>
      <li><strong>移动控制</strong>：移动构造和移动赋值将指针和引用计数转移到新的 <code class="language-plaintext highlighter-rouge">MySharedPtr</code>，确保资源的唯一所有权。</li>
      <li><strong>析构</strong>：在析构函数中减少引用计数，当引用计数为零时释放资源。</li>
    </ul>
  </li>
</ol>

<h3 id="c多线程中常用的mutex是怎么实现的和自旋锁有什么区别">C++多线程中常用的mutex是怎么实现的，和自旋锁有什么区别？</h3>

<p>在 C++ 中，<code class="language-plaintext highlighter-rouge">std::mutex</code> 是一种常用的同步原语，用于在多线程环境下保护共享资源，防止多个线程同时访问并导致数据不一致。<code class="language-plaintext highlighter-rouge">std::mutex</code> 的实现通常依赖于底层操作系统提供的互斥锁机制，最常见的是 <strong>互斥锁（Mutex）</strong> 和 <strong>自旋锁（Spinlock）</strong>。这两种锁的区别主要在于其锁定和等待的机制不同，适用于不同的场景。下面分别介绍它们的实现原理和区别。</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">std::mutex</code> 的实现原理</p>

    <p><code class="language-plaintext highlighter-rouge">std::mutex</code> 的具体实现取决于编译器和操作系统。例如，在 POSIX 系统（如 Linux）上，<code class="language-plaintext highlighter-rouge">std::mutex</code> 通常封装了 POSIX 的 <code class="language-plaintext highlighter-rouge">pthread_mutex</code>，在 Windows 上则使用 <code class="language-plaintext highlighter-rouge">CRITICAL_SECTION</code> 等 Win32 API。一般情况下，<code class="language-plaintext highlighter-rouge">std::mutex</code> 的实现包含以下机制：</p>

    <ol>
      <li>
        <p><strong>加锁（lock）</strong>：当一个线程调用 <code class="language-plaintext highlighter-rouge">mutex.lock()</code> 时，<code class="language-plaintext highlighter-rouge">mutex</code> 会检查锁是否被占用。如果锁未被占用，则线程获取锁并进入临界区。如果锁已经被占用，线程将进入<strong>阻塞状态</strong>，等待锁的释放。</p>
      </li>
      <li>
        <p><strong>解锁（unlock）</strong>：当一个线程执行完临界区代码后，调用 <code class="language-plaintext highlighter-rouge">mutex.unlock()</code> 释放锁。如果有其他线程在等待该锁，其中一个线程将被唤醒并尝试获取锁。</p>
      </li>
      <li>
        <p><strong>操作系统调度</strong>：对于 <code class="language-plaintext highlighter-rouge">std::mutex</code> 的阻塞线程，操作系统会将这些线程挂起，直到锁被释放。这减少了 CPU 的使用，因为等待线程进入了“睡眠”状态，释放了处理器资源，使其他线程或进程可以继续执行。</p>
      </li>
    </ol>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">std::mutex</code> 和自旋锁的区别</p>

    <p><strong>自旋锁（Spinlock）</strong> 是另一种锁机制，不同于 <code class="language-plaintext highlighter-rouge">std::mutex</code> 的阻塞等待方式，自旋锁在锁被占用时不会使线程进入休眠，而是让线程反复检查锁的状态（即“自旋”），直到锁被释放。</p>

    <p>以下是 <code class="language-plaintext highlighter-rouge">std::mutex</code> 和自旋锁的主要区别：</p>
    <ol>
      <li>等待机制
        <ul>
          <li><strong><code class="language-plaintext highlighter-rouge">std::mutex</code></strong>：当一个线程试图获取被占用的 <code class="language-plaintext highlighter-rouge">std::mutex</code> 时，线程会被挂起，进入阻塞状态，由操作系统负责管理调度。当锁释放时，操作系统唤醒该线程。</li>
          <li><strong>自旋锁</strong>：当一个线程试图获取被占用的自旋锁时，它不会进入阻塞状态，而是不断循环检查锁的状态（即“自旋”），直到锁被释放。自旋锁不会导致线程挂起或切换上下文。</li>
        </ul>
      </li>
      <li>
        <p>性能对比</p>

        <ul>
          <li><strong><code class="language-plaintext highlighter-rouge">std::mutex</code></strong>：适合长时间持有锁的情况。由于阻塞的线程进入休眠状态，不会占用 CPU 资源，因此适合锁定时间较长的场景。</li>
          <li><strong>自旋锁</strong>：适合短时间持有锁的情况。自旋锁不会进入阻塞状态，因此不需要上下文切换的开销，但会占用 CPU 资源。如果锁定时间较短，自旋锁避免了线程切换的开销，可以获得更好的性能。但如果锁持有时间较长，自旋锁的 CPU 开销会迅速增大。</li>
        </ul>
      </li>
      <li>
        <p>上下文切换开销</p>

        <ul>
          <li><strong><code class="language-plaintext highlighter-rouge">std::mutex</code></strong>：阻塞等待涉及线程上下文切换，开销较高。操作系统在管理阻塞线程时需要进行调度，而上下文切换会带来一定的性能开销。</li>
          <li><strong>自旋锁</strong>：没有上下文切换，避免了因阻塞带来的调度开销，但在锁占用较长的情况下，自旋会浪费 CPU 资源，导致性能下降。</li>
        </ul>
      </li>
      <li>
        <p>多核系统的适用性</p>

        <ul>
          <li><strong><code class="language-plaintext highlighter-rouge">std::mutex</code></strong>：适用于单核和多核系统，因为阻塞等待并不依赖 CPU 核心数。</li>
          <li><strong>自旋锁</strong>：在多核系统上更为高效，因为在多核系统中，当一个线程自旋等待时，另一个核心上的线程可以释放锁。单核系统上，自旋锁的线程会一直占用 CPU，导致锁持有线程无法执行，从而产生死锁的风险。</li>
        </ul>
      </li>
    </ol>
  </li>
</ol>

<h5 id="适用场景总结">适用场景总结</h5>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">std::mutex</code></strong>：适用于锁定时间不确定或较长的场景，尤其是在多线程环境下锁需要长时间持有时。操作系统的调度机制能够有效地管理线程，避免 CPU 资源的浪费。</li>
  <li><strong>自旋锁</strong>：适用于锁定时间很短、线程频繁竞争的情况，尤其是在多核系统上效果更佳，避免了不必要的上下文切换开销。</li>
</ul>

<h5 id="小结">小结</h5>

<ul>
  <li><code class="language-plaintext highlighter-rouge">std::mutex</code> 和自旋锁的主要区别在于等待机制：<code class="language-plaintext highlighter-rouge">std::mutex</code> 是阻塞等待，而自旋锁是忙等待。</li>
  <li>在锁持有时间短的情况下，自旋锁性能较好；在锁持有时间长的情况下，<code class="language-plaintext highlighter-rouge">std::mutex</code> 的性能更佳。</li>
  <li>在实际应用中，选择 <code class="language-plaintext highlighter-rouge">std::mutex</code> 还是自旋锁应根据锁的持有时间、系统的核心数量和性能要求来决定。</li>
</ul>

<h3 id="atomic内部实现是有锁还是没锁的所有的原子变量都没锁吗对于原子变量的memory-order有了解吗">atomic内部实现？是有锁还是没锁的？所有的原子变量都没锁吗？对于原子变量的memory order有了解吗？</h3>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">std::atomic</code> 的内部实现：有锁还是无锁？</p>

    <p><code class="language-plaintext highlighter-rouge">std::atomic</code> 变量的实现方式依赖于硬件的原子性支持。在大多数现代 CPU 上，硬件可以直接支持无锁的原子操作，例如使用<strong>原子读-改-写指令</strong>（如 <code class="language-plaintext highlighter-rouge">compare_and_swap</code> 或 <code class="language-plaintext highlighter-rouge">fetch_and_add</code>）实现。以下是主要情况：</p>

    <ul>
      <li><strong>无锁实现</strong>：如果硬件支持无锁的原子指令，那么 <code class="language-plaintext highlighter-rouge">std::atomic</code> 会直接使用这些指令。这种无锁实现的原子操作性能较高，因为它避免了线程上下文切换和锁管理的开销。</li>
      <li><strong>有锁实现</strong>：在某些不支持无锁原子操作的硬件平台上，或对于复杂的操作（如大于硬件支持的整数大小的原子变量），编译器可能会回退到使用互斥锁（如 <code class="language-plaintext highlighter-rouge">std::mutex</code>）来确保线程安全。这种情况下，<code class="language-plaintext highlighter-rouge">std::atomic</code> 会使用锁来保证原子性。</li>
    </ul>

    <p>大多数主流 CPU（如 x86、x64、ARM）都支持原子指令，因此在这些平台上，<code class="language-plaintext highlighter-rouge">std::atomic</code> 通常是<strong>无锁的</strong>。但是，在一些嵌入式平台或不支持原子指令的硬件上，可能会使用锁来模拟原子操作。</p>
  </li>
  <li>
    <p>所有的原子变量都没有锁吗？</p>

    <p>并不是所有的原子变量都在无锁环境下实现。例如：</p>

    <ul>
      <li><strong>小于或等于机器字大小的基本数据类型</strong>（如 <code class="language-plaintext highlighter-rouge">int</code>、<code class="language-plaintext highlighter-rouge">bool</code>、<code class="language-plaintext highlighter-rouge">pointer</code>）在主流硬件上通常可以无锁实现。</li>
      <li><strong>复杂类型</strong>或<strong>大于机器字大小的类型</strong>（如 128 位整数或结构体）可能需要锁。标准库中的 <code class="language-plaintext highlighter-rouge">std::atomic</code> 提供了 <code class="language-plaintext highlighter-rouge">is_lock_free()</code> 方法，允许程序检查特定类型的原子变量是否在无锁环境下实现。</li>
    </ul>

    <p>例如：在支持无锁的环境中，例如 x86 或 ARM 上，32 位和 64 位的整数通常是无锁的，而更大的类型（如 128 位整数）可能会需要锁。</p>
  </li>
  <li>
    <p>原子变量的内存顺序（Memory Order）</p>

    <p>在 C++ 中，<code class="language-plaintext highlighter-rouge">std::atomic</code> 提供了对 <strong>内存顺序</strong>（Memory Order）的控制，使开发者可以指定内存操作的顺序约束。内存顺序控制的是<strong>不同线程之间原子操作的可见性和执行顺序</strong>，这在多线程编程中尤为重要。C++ 标准定义了几种内存顺序：</p>

    <ol>
      <li><strong><code class="language-plaintext highlighter-rouge">memory_order_relaxed</code></strong>：
        <ul>
          <li>放松顺序，仅保证操作是原子的，不会引入任何同步或顺序约束。</li>
          <li>适用于不需要跨线程同步顺序的场景，性能最好，但只能用于极少数的、独立的状态更新场景。</li>
        </ul>
      </li>
      <li><strong><code class="language-plaintext highlighter-rouge">memory_order_consume</code></strong>：
        <ul>
          <li>是 <code class="language-plaintext highlighter-rouge">memory_order_acquire</code> 的一种弱化形式，确保数据依赖关系的操作能看到更新的结果。</li>
          <li>由于在实际编译器支持上存在问题，通常会降级为 <code class="language-plaintext highlighter-rouge">memory_order_acquire</code>。</li>
        </ul>
      </li>
      <li><strong><code class="language-plaintext highlighter-rouge">memory_order_acquire</code></strong>：
        <ul>
          <li>保证从当前操作读取的变量及其之前的所有写入在当前线程中可见。</li>
          <li>通常用于获取操作，以确保获取的数据对当前线程可见。</li>
        </ul>
      </li>
      <li><strong><code class="language-plaintext highlighter-rouge">memory_order_release</code></strong>：
        <ul>
          <li>确保在此操作之前的所有写操作在其他线程中可见。</li>
          <li>通常用于释放操作，以确保当前线程的更改对其他线程可见。</li>
        </ul>
      </li>
      <li><strong><code class="language-plaintext highlighter-rouge">memory_order_acq_rel</code></strong>（Acquire-Release）：
        <ul>
          <li>同时具备 <code class="language-plaintext highlighter-rouge">acquire</code> 和 <code class="language-plaintext highlighter-rouge">release</code> 的效果。</li>
          <li>适用于既要同步读又要同步写的操作，例如 <code class="language-plaintext highlighter-rouge">compare_exchange</code> 操作。</li>
        </ul>
      </li>
      <li><strong><code class="language-plaintext highlighter-rouge">memory_order_seq_cst</code>（Sequentially Consistent Order）</strong>：
        <ul>
          <li>最严格的内存顺序保证，确保所有原子操作都具有全局的顺序。</li>
          <li>提供最强的可见性和顺序性保障，但通常会有更高的性能开销。</li>
        </ul>
      </li>
    </ol>

    <p>以下是一个使用 <code class="language-plaintext highlighter-rouge">memory_order_acquire</code> 和 <code class="language-plaintext highlighter-rouge">memory_order_release</code> 的示例，用于实现线程间的同步：</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span> <span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span> <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
 <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">ready</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
 <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

 <span class="kt">void</span> <span class="nf">producer</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">data</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>  <span class="c1">// 先更新数据</span>
     <span class="n">ready</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>  <span class="c1">// 再通知消费者</span>
 <span class="p">}</span>

 <span class="kt">void</span> <span class="n">consumer</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ready</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">))</span> <span class="p">{</span>
         <span class="c1">// 等待生产者通知</span>
     <span class="p">}</span>
     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Data: "</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 输出数据</span>
 <span class="p">}</span>

 <span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">producer</span><span class="p">);</span>
     <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">consumer</span><span class="p">);</span>

     <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
     <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div>    </div>

    <p>在这个例子中：</p>

    <ul>
      <li><strong>生产者线程</strong>在 <code class="language-plaintext highlighter-rouge">memory_order_release</code> 顺序下将 <code class="language-plaintext highlighter-rouge">ready</code> 设置为 <code class="language-plaintext highlighter-rouge">true</code>，使得之前对 <code class="language-plaintext highlighter-rouge">data</code> 的写操作（存储 42）对消费者线程可见。</li>
      <li><strong>消费者线程</strong>在 <code class="language-plaintext highlighter-rouge">memory_order_acquire</code> 顺序下读取 <code class="language-plaintext highlighter-rouge">ready</code>。如果读取到 <code class="language-plaintext highlighter-rouge">true</code>，可以确保此时 <code class="language-plaintext highlighter-rouge">data</code> 的值是生产者线程已经更新过的。</li>
    </ul>
  </li>
</ol>

<h5 id="总结-1">总结</h5>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">std::atomic</code> 的实现</strong>：多数情况下是无锁的，依赖于硬件的原子指令；某些平台或较大的数据类型可能使用锁。</li>
  <li><strong>是否使用锁</strong>：小于或等于机器字大小的类型通常是无锁的，而较大的或复杂的数据类型可能需要锁。</li>
  <li><strong>内存顺序</strong>：<code class="language-plaintext highlighter-rouge">std::atomic</code> 提供了不同的内存顺序模型，允许在性能和同步保障之间进行权衡。</li>
</ul>

<h3 id="无锁队列">无锁队列</h3>

<p>无锁队列（Lock-Free Queue）是一种并发数据结构，它允许多个线程安全地进行入队和出队操作，而无需使用传统的互斥锁。这种结构在多线程编程中极为重要，尤其在高并发场景下，可以显著提高性能并减少线程竞争导致的开销。</p>

<h5 id="无锁队列的特点">无锁队列的特点</h5>

<p>无锁队列的核心特点是它使用了<strong>无锁算法</strong>，在进行并发操作时不会阻塞线程，而是依赖于<strong>原子操作</strong>（如 <code class="language-plaintext highlighter-rouge">compare_and_swap</code>、<code class="language-plaintext highlighter-rouge">fetch_add</code> 等）来实现线程安全。这种方式通常能提供更高的性能和更低的延迟。</p>

<p>具体特点包括：</p>

<ol>
  <li><strong>无锁操作</strong>：通过无锁算法来实现操作的原子性，避免线程阻塞。</li>
  <li><strong>线程安全</strong>：多个线程可以同时对队列进行操作，且不会破坏队列的状态。</li>
  <li><strong>高并发</strong>：由于避免了锁的竞争和上下文切换的开销，无锁队列在高并发场景下性能优于传统的锁队列。</li>
</ol>

<h5 id="无锁队列的实现原理">无锁队列的实现原理</h5>

<p>无锁队列的实现主要依赖以下几个技术：</p>

<ol>
  <li><strong>原子操作</strong>：如 <code class="language-plaintext highlighter-rouge">compare_and_swap</code>（CAS），它允许线程以原子方式比较并设置变量。这种操作可以确保在多线程环境下不需要加锁而安全地修改变量。</li>
  <li><strong>ABA 问题</strong>：在无锁队列中，可能会出现 ABA 问题，即某个变量的值从 A 变为 B，再变回 A，使得 CAS 操作以为变量没有变化。解决方法包括使用<strong>带有版本号的指针</strong>（如 <code class="language-plaintext highlighter-rouge">std::atomic&lt;std::uintptr_t&gt;</code>）或者<strong>引用计数</strong>。</li>
  <li><strong>两指针结构</strong>：无锁队列通常使用<strong>两个指针</strong>，一个指向队列的头（<code class="language-plaintext highlighter-rouge">head</code>），一个指向队列的尾（<code class="language-plaintext highlighter-rouge">tail</code>）。这样可以允许并发的入队和出队操作，分别操作 <code class="language-plaintext highlighter-rouge">head</code> 和 <code class="language-plaintext highlighter-rouge">tail</code> 指针。</li>
</ol>

<h5 id="典型实现michael--scott-队列算法">典型实现：Michael &amp; Scott 队列算法</h5>

<p>Michael 和 Scott 提出的无锁队列算法是一个典型的无锁队列实现，通常用于支持多生产者、多消费者的场景。该算法的基本思路如下：</p>

<ol>
  <li>
    <p><strong>数据结构</strong>：队列中的每个节点包含一个值和一个指向下一个节点的指针。队列头指针 <code class="language-plaintext highlighter-rouge">head</code> 指向队列的第一个元素，而尾指针 <code class="language-plaintext highlighter-rouge">tail</code> 指向最后一个元素。</p>
  </li>
  <li><strong>入队操作（Enqueue）</strong>：
    <ul>
      <li>创建一个新节点，指向 <code class="language-plaintext highlighter-rouge">nullptr</code>。</li>
      <li>使用 CAS 操作将 <code class="language-plaintext highlighter-rouge">tail</code> 指针更新为新节点。</li>
      <li>如果其他线程也在更新 <code class="language-plaintext highlighter-rouge">tail</code>，可能会出现冲突；但是 CAS 操作确保只有一个线程可以成功。</li>
    </ul>
  </li>
  <li><strong>出队操作（Dequeue）</strong>：
    <ul>
      <li>获取 <code class="language-plaintext highlighter-rouge">head</code> 指向的节点。</li>
      <li>使用 CAS 操作将 <code class="language-plaintext highlighter-rouge">head</code> 更新为下一个节点。</li>
      <li>如果 <code class="language-plaintext highlighter-rouge">head</code> 和 <code class="language-plaintext highlighter-rouge">tail</code> 指向同一个节点且该节点的 <code class="language-plaintext highlighter-rouge">next</code> 为空，则队列为空。</li>
    </ul>
  </li>
</ol>

<p>下面是一个简单的无锁队列的示例代码：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">LockFreeQueue</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
        <span class="n">Node</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">)),</span> <span class="n">next</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="p">{}</span>
    <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">tail</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="n">LockFreeQueue</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">T</span><span class="p">());</span>  <span class="c1">// 创建哨兵节点</span>
        <span class="n">head</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span>
        <span class="n">tail</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="o">~</span><span class="n">LockFreeQueue</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">head</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
            <span class="k">delete</span> <span class="n">node</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">enqueue</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">oldTail</span> <span class="o">=</span> <span class="n">tail</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>

        <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Node</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">oldTail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 尝试将 oldTail-&gt;next 设置为新节点</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">atomic_compare_exchange_weak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldTail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">newNode</span><span class="p">))</span> <span class="p">{</span>
                    <span class="c1">// 更新 tail 指向新节点</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">atomic_compare_exchange_weak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tail</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldTail</span><span class="p">,</span> <span class="n">newNode</span><span class="p">);</span>
                    <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 如果其他线程正在入队，推进 tail 指针</span>
                <span class="n">std</span><span class="o">::</span><span class="n">atomic_compare_exchange_weak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tail</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldTail</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">dequeue</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">oldHead</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>

        <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Node</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">oldHead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>  <span class="c1">// 队列为空</span>
            <span class="p">}</span>

            <span class="c1">// 尝试更新 head 指针</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">atomic_compare_exchange_weak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oldHead</span><span class="p">,</span> <span class="n">temp</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
                <span class="k">delete</span> <span class="n">oldHead</span><span class="p">;</span>  <span class="c1">// 删除旧的头节点</span>
                <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h5 id="代码解释">代码解释</h5>

<ul>
  <li><strong>哨兵节点</strong>：在初始化时，创建一个哨兵节点。<code class="language-plaintext highlighter-rouge">head</code> 和 <code class="language-plaintext highlighter-rouge">tail</code> 都指向这个哨兵节点，以确保队列最初为空，并使得入队和出队操作更加简洁。</li>
  <li><strong>入队操作</strong>：新节点通过 <code class="language-plaintext highlighter-rouge">tail</code> 指针入队。CAS 操作确保多个线程不会将 <code class="language-plaintext highlighter-rouge">tail-&gt;next</code> 指向同一个节点。</li>
  <li><strong>出队操作</strong>：通过移动 <code class="language-plaintext highlighter-rouge">head</code> 指针从队列中移除节点。CAS 操作保证 <code class="language-plaintext highlighter-rouge">head</code> 被更新到下一个节点。</li>
</ul>

<h5 id="自旋等待和性能">自旋等待和性能</h5>

<p>在无锁队列中，线程在 CAS 操作失败时会<strong>自旋等待</strong>，即反复尝试直到成功。这种忙等待在短期锁定中效率很高，因为它避免了线程上下文切换的开销，但如果操作时间过长，自旋可能会导致性能下降。因此，无锁队列适合高并发和短期锁定的场景。</p>

<h3 id="stl容器的线程安全">STL容器的线程安全</h3>

<p>在 C++ 标准库（STL）中，大多数容器（如 <code class="language-plaintext highlighter-rouge">vector</code>、<code class="language-plaintext highlighter-rouge">list</code>、<code class="language-plaintext highlighter-rouge">map</code> 等）本身并不保证线程安全性。这意味着在多线程环境下，使用这些容器时需要遵循一定的规则，或者通过适当的同步机制（如互斥锁 <code class="language-plaintext highlighter-rouge">std::mutex</code>）来确保线程安全。</p>

<p>以下是 STL 容器在多线程环境下的线程安全规则及一些常见的处理方式：</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">std::vector</code>、<code class="language-plaintext highlighter-rouge">std::deque</code> 和 <code class="language-plaintext highlighter-rouge">std::list</code></p>

    <ul>
      <li>这些容器在结构上是动态调整大小的（如 <code class="language-plaintext highlighter-rouge">vector</code> 会动态分配和释放内存），因此在多线程环境中修改其内容是非线程安全的。</li>
      <li>如果一个线程修改这些容器的内容，另一个线程尝试访问容器（无论是读或写），则会导致数据竞争，需要使用互斥锁来保证线程安全。</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">std::map</code> 和 <code class="language-plaintext highlighter-rouge">std::unordered_map</code></p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">std::map</code> 和 <code class="language-plaintext highlighter-rouge">std::unordered_map</code> 是键值对容器，内部实现相对复杂，尤其是 <code class="language-plaintext highlighter-rouge">unordered_map</code>，其元素位置可能会随插入或删除而重排。</li>
      <li>如果多个线程同时访问 <code class="language-plaintext highlighter-rouge">map</code> 或 <code class="language-plaintext highlighter-rouge">unordered_map</code>，则只读操作是安全的，但一旦有线程进行写操作（插入或删除），就需要同步。</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">std::set</code> 和 <code class="language-plaintext highlighter-rouge">std::unordered_set</code></p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">set</code> 和 <code class="language-plaintext highlighter-rouge">unordered_set</code> 是集合类型的容器，具有类似于 <code class="language-plaintext highlighter-rouge">map</code> 和 <code class="language-plaintext highlighter-rouge">unordered_map</code> 的特性。</li>
      <li>只读操作是线程安全的，多个线程同时进行读取不需要额外的同步。但是，一旦有写操作（插入或删除），就需要使用同步机制。</li>
    </ul>
  </li>
</ol>

<p>在需要保证线程安全的多线程环境下，可以使用以下方式确保安全访问 STL 容器：</p>

<ol>
  <li>
    <p><strong>互斥锁保护</strong>：使用 <code class="language-plaintext highlighter-rouge">std::mutex</code> 或 <code class="language-plaintext highlighter-rouge">std::shared_mutex</code> 对容器的访问进行同步。</p>

    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">std::mutex</code></strong>：如果容器既有读操作又有写操作，可以使用 <code class="language-plaintext highlighter-rouge">std::mutex</code>，确保只有一个线程可以访问容器。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">std::shared_mutex</code></strong>（C++17 引入）：如果大多数操作都是读取，可以使用 <code class="language-plaintext highlighter-rouge">std::shared_mutex</code>，允许多个线程同时读取，而写操作仍然需要独占锁。</li>
    </ul>
  </li>
  <li>
    <p><strong>线程安全容器</strong>：C++ 标准库没有提供线程安全的容器实现，但有些第三方库（如 <code class="language-plaintext highlighter-rouge">TBB</code>、<code class="language-plaintext highlighter-rouge">Boost</code>、<code class="language-plaintext highlighter-rouge">Folly</code> 等）提供了线程安全的容器，可以根据需求使用。例如：</p>

    <ul>
      <li><strong>Intel TBB（Threading Building Blocks）</strong> 提供的线程安全容器。</li>
      <li><strong>Boost</strong> 库提供的多线程工具也有线程安全的结构支持。</li>
    </ul>
  </li>
  <li>
    <p><strong>使用原子操作</strong>：如果容器只需要存储简单的计数或标志，可以使用 <code class="language-plaintext highlighter-rouge">std::atomic</code> 变量来存储，而不是整个容器锁定。<code class="language-plaintext highlighter-rouge">std::atomic</code> 允许无锁访问，提高了性能。</p>
  </li>
</ol>

<h3 id="红黑树和哈希表的区别时间和空间的性能上">红黑树和哈希表的区别（时间和空间的性能上）</h3>

<p>红黑树在最坏情况下的操作时间复杂度如下：</p>

<ul>
  <li><strong>查找</strong>：<code class="language-plaintext highlighter-rouge">O(log n)</code></li>
  <li><strong>插入</strong>：<code class="language-plaintext highlighter-rouge">O(log n)</code></li>
  <li><strong>删除</strong>：<code class="language-plaintext highlighter-rouge">O(log n)</code></li>
  <li><strong>空间复杂度</strong>：红黑树在每个节点上需要额外存储一些平衡信息（如颜色），因此相较于其他二叉树类型会占用稍多的空间。但总体上，红黑树的空间复杂度是 <code class="language-plaintext highlighter-rouge">O(n)</code>。</li>
</ul>

<p>在平均情况下，哈希表的时间复杂度如下：</p>

<ul>
  <li><strong>查找</strong>：<code class="language-plaintext highlighter-rouge">O(1)</code>（平均情况下），最坏情况下可能退化为 <code class="language-plaintext highlighter-rouge">O(n)</code>（当所有键都映射到同一个位置时）。</li>
  <li><strong>插入</strong>：<code class="language-plaintext highlighter-rouge">O(1)</code>（平均情况下），最坏情况下可能退化为 <code class="language-plaintext highlighter-rouge">O(n)</code>。</li>
  <li><strong>删除</strong>：<code class="language-plaintext highlighter-rouge">O(1)</code>（平均情况下），最坏情况下可能退化为 <code class="language-plaintext highlighter-rouge">O(n)</code>。</li>
</ul>

<p>在大多数情况下，哈希表的查找、插入和删除操作都是 <code class="language-plaintext highlighter-rouge">O(1)</code> 的，但在发生<strong>哈希冲突</strong>或负载因子（元素数与哈希桶数的比值）过高时，性能可能退化为 <code class="language-plaintext highlighter-rouge">O(n)</code>。</p>

<ul>
  <li><strong>空间复杂度</strong>：哈希表在数组中存储元素，并且随着元素的增多，哈希表会进行<strong>动态扩容</strong>（例如 <code class="language-plaintext highlighter-rouge">std::unordered_map</code> 会在达到一定负载因子后自动增加桶的数量）。因此，哈希表的空间复杂度通常是 <code class="language-plaintext highlighter-rouge">O(n)</code>，但会随着动态扩容而多占用一些空间。</li>
  <li><strong>内存浪费</strong>：哈希表通常会预留额外的空间以降低冲突率，从而实现 <code class="language-plaintext highlighter-rouge">O(1)</code> 的平均时间复杂度。相比红黑树，哈希表的空间开销会更大。</li>
</ul>

<p>红黑树和哈希表的适用场景如下：</p>
<ul>
  <li><strong>红黑树的适用场景</strong>：
    <ul>
      <li>需要有序访问数据时（如按键排序、区间查询）。</li>
      <li>需要频繁的插入和删除操作，同时需要有序性保障。</li>
      <li>需要高效的范围查询（如找到范围内的所有键值对）。</li>
    </ul>
  </li>
  <li><strong>哈希表的适用场景</strong>：
    <ul>
      <li>需要快速查找和插入，但不关心数据顺序时。</li>
      <li>需要频繁的查找和更新操作，如缓存、字典、集合等。</li>
      <li>当空间开销不是关键考虑因素时，哈希表提供了更高效的查找和插入性能。</li>
    </ul>
  </li>
</ul>

<h3 id="在交易场景中哈希表和红黑树各自应当在什么时候使用">在交易场景中，哈希表和红黑树各自应当在什么时候使用？</h3>
<p>在交易系统中，数据结构的选择非常重要，不同的数据结构在效率、性能以及适用场景上各不相同。下面是哈希表和红黑树在交易场景中的适用场景分析，之后再讨论 <code class="language-plaintext highlighter-rouge">deque</code> 和 <code class="language-plaintext highlighter-rouge">vector</code> 的应用场景。</p>

<h5 id="1-哈希表在交易场景中的使用场景">1. 哈希表在交易场景中的使用场景</h5>

<p>哈希表（如 <code class="language-plaintext highlighter-rouge">std::unordered_map</code>）在交易场景中的适用场景主要是快速查找和更新操作，无需关心顺序性。常见的使用场景包括：</p>

<ul>
  <li>
    <p><strong>按订单 ID 查找订单</strong>：在交易系统中，每个订单通常有一个唯一的订单 ID。通过哈希表可以快速根据订单 ID 查找到特定的订单，以便于查询、取消或更新订单。哈希表的 <code class="language-plaintext highlighter-rouge">O(1)</code> 平均查找复杂度在这种情况下具有很大优势。</p>
  </li>
  <li>
    <p><strong>按客户 ID 查找客户信息</strong>：在订单系统中，经常需要通过客户 ID 查找客户的订单历史、账户余额等信息。哈希表可以提供快速的查找，使得能够在海量的客户数据中高效获取目标客户的详细信息。</p>
  </li>
  <li>
    <p><strong>缓存数据</strong>：哈希表适合缓存常用的数据，比如缓存最新的市场行情信息、交易对信息、配置信息等。通过键值对的形式，可以实现快速查找和更新，尤其是在需要频繁读写的场景中，哈希表提供了很好的性能。</p>
  </li>
</ul>

<h5 id="适用场景总结-1">适用场景总结</h5>

<ul>
  <li>哈希表适合在交易场景中快速查找特定对象、缓存高频读写的数据、管理和查找基于 ID 的信息（如订单 ID、客户 ID 等），并且不需要保持数据的有序性。</li>
</ul>

<h5 id="2-红黑树在交易场景中的使用场景">2. 红黑树在交易场景中的使用场景</h5>

<p>红黑树（如 <code class="language-plaintext highlighter-rouge">std::map</code>）在交易场景中的适用场景主要是需要顺序性、范围查找等操作的场合。常见的使用场景包括：</p>

<ul>
  <li>
    <p><strong>订单簿（Order Book）</strong>：在订单簿中，通常会根据价格对买卖订单进行排序，以实现撮合交易（如寻找最优的买价和卖价）。红黑树的有序性保证了订单能够按照价格排序，便于快速查找、插入和删除。例如，撮合引擎可以快速找到价格最低的卖单和价格最高的买单。</p>
  </li>
  <li>
    <p><strong>价格范围查询</strong>：在交易中，可能需要查询某一价格范围内的订单。例如，找到某价格区间内所有待处理的订单。红黑树支持范围查询操作，可以通过 <code class="language-plaintext highlighter-rouge">lower_bound</code> 和 <code class="language-plaintext highlighter-rouge">upper_bound</code> 方法快速查找特定区间内的订单。</p>
  </li>
  <li>
    <p><strong>时间排序的订单列表</strong>：在某些交易系统中，可能需要按时间戳排序的订单列表，方便按顺序处理订单。红黑树可以在插入时维持时间戳的顺序，便于顺序性处理。</p>
  </li>
</ul>

<h5 id="适用场景总结-2">适用场景总结</h5>

<ul>
  <li>红黑树适合在交易系统中维护有序的订单簿、支持价格范围查询的订单管理、以及按时间或价格排序的需求。其 <code class="language-plaintext highlighter-rouge">O(log n)</code> 的复杂度在这些场景中具有较好的性能表现。</li>
</ul>

<h3 id="deque和vector有哪些使用场景">deque和vector有哪些使用场景</h3>

<p><code class="language-plaintext highlighter-rouge">deque</code> 和 <code class="language-plaintext highlighter-rouge">vector</code> 都是线性容器，但在某些特性上存在差异，适用的场景也有所不同。</p>

<h5 id="vector-的使用场景"><code class="language-plaintext highlighter-rouge">vector</code> 的使用场景</h5>

<ul>
  <li>
    <p><strong>顺序数据存储</strong>：<code class="language-plaintext highlighter-rouge">vector</code> 适合存储顺序性数据，并且大多数情况下可以连续访问元素。对于随机访问需求较高的数据，<code class="language-plaintext highlighter-rouge">vector</code> 是不错的选择，因为 <code class="language-plaintext highlighter-rouge">vector</code> 的元素在内存中是连续存储的，因此可以使用索引快速访问。</p>
  </li>
  <li>
    <p><strong>只在尾部插入或删除</strong>：<code class="language-plaintext highlighter-rouge">vector</code> 在尾部插入和删除的性能较好，具有 <code class="language-plaintext highlighter-rouge">O(1)</code> 的时间复杂度。但在中间或头部插入和删除元素的性能较差，因为需要移动元素，时间复杂度为 <code class="language-plaintext highlighter-rouge">O(n)</code>。</p>
  </li>
  <li>
    <p><strong>内存占用较小</strong>：由于 <code class="language-plaintext highlighter-rouge">vector</code> 元素连续存储，内存分配相对紧凑。它不需要额外的指针来连接元素，因此相比 <code class="language-plaintext highlighter-rouge">deque</code>，在相同的容量下 <code class="language-plaintext highlighter-rouge">vector</code> 更节省内存。</p>
  </li>
</ul>

<h5 id="适用场景示例">适用场景示例</h5>

<ul>
  <li><strong>交易记录缓存</strong>：<code class="language-plaintext highlighter-rouge">vector</code> 可用于存储顺序排列的交易记录，尤其是只需要在尾部追加新记录的情况。</li>
  <li><strong>历史行情数据</strong>：存储市场的历史价格等数据，可以直接按索引快速访问，并在尾部追加新数据。</li>
</ul>

<h5 id="deque-的使用场景"><code class="language-plaintext highlighter-rouge">deque</code> 的使用场景</h5>

<ul>
  <li>
    <p><strong>双端插入和删除</strong>：<code class="language-plaintext highlighter-rouge">deque</code> 允许在头部和尾部进行高效的插入和删除，时间复杂度是 <code class="language-plaintext highlighter-rouge">O(1)</code>。这使得它非常适合需要双端插入删除的场景。</p>
  </li>
  <li>
    <p><strong>动态调整长度</strong>：<code class="language-plaintext highlighter-rouge">deque</code> 的内存分配方式允许在首尾插入删除元素而不会频繁进行内存重分配，适合长度动态变化频繁的场景。相比 <code class="language-plaintext highlighter-rouge">vector</code>，<code class="language-plaintext highlighter-rouge">deque</code> 的结构更加灵活。</p>
  </li>
  <li>
    <p><strong>队列或栈</strong>：由于支持双端操作，<code class="language-plaintext highlighter-rouge">deque</code> 适合实现双端队列、双向栈等结构。<code class="language-plaintext highlighter-rouge">deque</code> 的设计适合 FIFO（先进先出）和 LIFO（后进先出）模型。</p>
  </li>
</ul>

<h6 id="适用场景示例-1">适用场景示例</h6>

<ul>
  <li><strong>实时行情窗口</strong>：<code class="language-plaintext highlighter-rouge">deque</code> 适合用于存储实时行情数据的滑动窗口，比如只保留最近几秒的价格数据，在数据进来时添加到尾部，最旧的数据从头部删除。</li>
  <li><strong>订单处理队列</strong>：如果订单需要在队列的首部和尾部进行频繁操作（如撤销最早的订单），<code class="language-plaintext highlighter-rouge">deque</code> 提供更高效的处理。</li>
</ul>

<h3 id="实现一个订单簿系统有挂单吃单撤单的功能">实现一个订单簿系统，有挂单吃单撤单的功能</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp">
</span>
<span class="k">enum</span> <span class="n">OrderType</span> <span class="p">{</span> <span class="n">BUY</span><span class="p">,</span> <span class="n">SELL</span> <span class="p">};</span>

<span class="c1">// 订单结构体</span>
<span class="k">struct</span> <span class="nc">Order</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">order_id</span><span class="p">;</span>
    <span class="n">OrderType</span> <span class="n">type</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">price</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">quantity</span><span class="p">;</span>

    <span class="n">Order</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">OrderType</span> <span class="n">t</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">q</span><span class="p">)</span> <span class="o">:</span> <span class="n">order_id</span><span class="p">(</span><span class="n">id</span><span class="p">),</span> <span class="n">type</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">price</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">quantity</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">// 订单簿类</span>
<span class="k">class</span> <span class="nc">OrderBook</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="c1">// 买单按降序排列（价格从高到低）</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">Order</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">buy_orders</span><span class="p">;</span>
    <span class="c1">// 卖单按升序排列（价格从低到高）</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">Order</span><span class="o">&gt;&gt;</span> <span class="n">sell_orders</span><span class="p">;</span>
    <span class="c1">// 存储订单 ID 到订单的映射，方便撤单</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">Order</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="o">&gt;</span> <span class="n">order_map</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="c1">// 挂单</span>
    <span class="kt">void</span> <span class="n">add_order</span><span class="p">(</span><span class="kt">int</span> <span class="n">order_id</span><span class="p">,</span> <span class="n">OrderType</span> <span class="n">type</span><span class="p">,</span> <span class="kt">double</span> <span class="n">price</span><span class="p">,</span> <span class="kt">int</span> <span class="n">quantity</span><span class="p">);</span>

    <span class="c1">// 吃单</span>
    <span class="kt">void</span> <span class="n">execute_market_order</span><span class="p">(</span><span class="n">OrderType</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">quantity</span><span class="p">);</span>

    <span class="c1">// 撤单</span>
    <span class="kt">void</span> <span class="n">cancel_order</span><span class="p">(</span><span class="kt">int</span> <span class="n">order_id</span><span class="p">);</span>
<span class="p">};</span>


</code></pre></div></div>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="C++" /><summary type="html"><![CDATA[内存分区]]></summary></entry><entry><title type="html">计算机系统、网络面经</title><link href="http://localhost:4000/2024/10/21/CS/" rel="alternate" type="text/html" title="计算机系统、网络面经" /><published>2024-10-21T10:00:00+08:00</published><updated>2024-10-21T10:00:00+08:00</updated><id>http://localhost:4000/2024/10/21/CS</id><content type="html" xml:base="http://localhost:4000/2024/10/21/CS/"><![CDATA[<h3 id="描述一下cpu怎么从内存中获取数据的要经过哪些模块">描述一下cpu怎么从内存中获取数据的，要经过哪些模块？</h3>

<h3 id="介绍一下cpu中的cache">介绍一下cpu中的cache</h3>

<h3 id="不同层级的cache现实中常见的速度">不同层级的cache现实中常见的速度</h3>

<h3 id="通过什么方式写出对cache更友好的代码对于数组某些特定的长度会使读取变慢吗">通过什么方式写出对cache更友好的代码？对于数组，某些特定的长度会使读取变慢吗？</h3>

<h3 id="虚拟内存是什么好处是什么每个页的大小一般是多少">虚拟内存是什么？好处是什么？每个页的大小一般是多少？</h3>

<h3 id="线程和进程的区别-它们在linux的实现上的区别">线程和进程的区别？ 它们在Linux的实现上的区别？</h3>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="C++" /><summary type="html"><![CDATA[描述一下cpu怎么从内存中获取数据的，要经过哪些模块？]]></summary></entry><entry><title type="html">其他面经</title><link href="http://localhost:4000/2024/10/21/other/" rel="alternate" type="text/html" title="其他面经" /><published>2024-10-21T10:00:00+08:00</published><updated>2024-10-21T10:00:00+08:00</updated><id>http://localhost:4000/2024/10/21/other</id><content type="html" xml:base="http://localhost:4000/2024/10/21/other/"><![CDATA[<h3 id="设计模式">设计模式</h3>

<p><a href="https://refactoringguru.cn/design-patterns/catalog">设计模式详解</a></p>

<h3 id="c性能检测用过什么工具">C++性能检测用过什么工具</h3>

<h3 id="gdb看backtrace和切换线程">gdb看backtrace和切换线程</h3>

<p>以下是一些常用的多线程调试方法：</p>

<h5 id="1-查看线程">1. 查看线程</h5>
<ul>
  <li><strong>显示所有线程</strong>：
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>info threads
</code></pre></div>    </div>
    <p>这个命令会显示当前所有线程的编号、线程ID（TID）、状态以及当前的执行位置。每个线程都有一个 <code class="language-plaintext highlighter-rouge">gdb</code> 编号，可以用来切换到指定线程。</p>
  </li>
</ul>

<h5 id="2-切换线程">2. 切换线程</h5>
<ul>
  <li><strong>切换到指定线程</strong>：
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>thread THREAD_NUM
</code></pre></div>    </div>
    <p>这里的 <code class="language-plaintext highlighter-rouge">THREAD_NUM</code> 是 <code class="language-plaintext highlighter-rouge">info threads</code> 命令输出中线程的编号。切换到指定线程后，可以使用正常的调试命令，比如 <code class="language-plaintext highlighter-rouge">backtrace</code> 查看调用栈，<code class="language-plaintext highlighter-rouge">print</code> 查看变量等。</p>
  </li>
</ul>

<h5 id="3-设置线程断点">3. 设置线程断点</h5>
<ul>
  <li><strong>对特定线程设置断点</strong>：
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">break </span>function_name thread THREAD_NUM
</code></pre></div>    </div>
    <p>在指定线程上设置断点。这样只有当指定线程执行到该断点时，程序才会暂停。</p>
  </li>
  <li><strong>对所有线程设置断点</strong>：
正常的断点会影响所有线程，因此可以直接使用 <code class="language-plaintext highlighter-rouge">break</code> 命令，而无需特别指定线程。</li>
</ul>

<h5 id="4-控制线程">4. 控制线程</h5>
<ul>
  <li><strong>暂停/继续特定线程</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">continue</code>: 继续当前线程的执行。</li>
      <li><code class="language-plaintext highlighter-rouge">thread THREAD_NUM</code>: 切换到特定线程后，可以继续执行该线程的调试流程。</li>
    </ul>

    <p><strong>注意</strong>：<code class="language-plaintext highlighter-rouge">continue</code> 命令会让所有线程继续运行，想要单步调试特定线程时可以结合 <code class="language-plaintext highlighter-rouge">next</code> 和 <code class="language-plaintext highlighter-rouge">step</code> 命令操作。</p>
  </li>
</ul>

<h5 id="5-锁和竞态调试">5. 锁和竞态调试</h5>
<ul>
  <li><strong>设置断点和观察变量</strong>：
可以在临界区或共享资源访问代码处设置断点，使用 <code class="language-plaintext highlighter-rouge">watch</code> 命令观察共享变量的值变化，帮助发现竞争条件或死锁情况。
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>watch var
</code></pre></div>    </div>
  </li>
  <li><strong>死锁调试</strong>：
使用 <code class="language-plaintext highlighter-rouge">thread apply all backtrace</code> 查看所有线程的调用栈，确定是否有线程卡在锁等待或死锁状态。</li>
</ul>

<h3 id="6-常用命令总结">6. 常用命令总结</h3>
<ul>
  <li><strong>列出所有线程</strong>：
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>info threads
</code></pre></div>    </div>
  </li>
  <li><strong>切换线程</strong>：
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>thread THREAD_NUM
</code></pre></div>    </div>
  </li>
  <li><strong>对指定线程设置断点</strong>：
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">break </span>func_name thread THREAD_NUM
</code></pre></div>    </div>
  </li>
  <li><strong>查看所有线程的调用栈</strong>：
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>thread apply all backtrace
</code></pre></div>    </div>
  </li>
  <li><strong>查看特定线程的调用栈</strong>：
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>backtrace
</code></pre></div>    </div>
  </li>
  <li><strong>继续执行所有线程</strong>：
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">continue</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="全部加载到内存太大了怎么办">全部加载到内存太大了怎么办</h3>

<h3 id="数据迁移怎么保证一致性">数据迁移怎么保证一致性</h3>

<h3 id="新旧数据不兼容怎么办">新旧数据不兼容怎么办</h3>

<h3 id="有哪些加速计算的方法">有哪些加速计算的方法</h3>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="C++" /><summary type="html"><![CDATA[设计模式]]></summary></entry><entry><title type="html">C++多线程</title><link href="http://localhost:4000/2024/10/20/Thread/" rel="alternate" type="text/html" title="C++多线程" /><published>2024-10-20T10:00:00+08:00</published><updated>2024-10-20T10:00:00+08:00</updated><id>http://localhost:4000/2024/10/20/Thread</id><content type="html" xml:base="http://localhost:4000/2024/10/20/Thread/"><![CDATA[<p>C++的<code class="language-plaintext highlighter-rouge">atomic</code>库和<code class="language-plaintext highlighter-rouge">thread</code>库是多线程编程中常用的库，提供了安全的并发操作支持。</p>

<h3 id="1-thread库">1. <code class="language-plaintext highlighter-rouge">thread</code>库</h3>

<p><a href="https://blog.csdn.net/QLeelq/article/details/115747717">This link</a></p>

<h3 id="2-atomic库">2. <code class="language-plaintext highlighter-rouge">atomic</code>库</h3>

<p><code class="language-plaintext highlighter-rouge">&lt;atomic&gt;</code>库主要提供了原子操作（atomic operations），即无需锁机制即可实现的线程安全操作。这对提高多线程环境下的数据一致性和性能很有帮助。</p>

<h4 id="常见的原子类型">常见的原子类型</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">std::atomic&lt;T&gt;</code></strong>：提供一种基础原子类型，<code class="language-plaintext highlighter-rouge">T</code>可以是整型、指针等。常见类型如<code class="language-plaintext highlighter-rouge">std::atomic&lt;int&gt;</code>、<code class="language-plaintext highlighter-rouge">std::atomic&lt;bool&gt;</code>等。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">std::atomic_flag</code></strong>：最简单的原子布尔类型，适用于实现简单的锁（如自旋锁）。</li>
</ul>

<h4 id="原子操作的基本方法">原子操作的基本方法</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">store(value)</code></strong>：原子地存储一个值。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">load()</code></strong>：原子地加载一个值。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">exchange(value)</code></strong>：原子地将变量的值设置为<code class="language-plaintext highlighter-rouge">value</code>，并返回先前的值。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">compare_exchange_strong(expected, desired)</code></strong> 和 <strong><code class="language-plaintext highlighter-rouge">compare_exchange_weak(expected, desired)</code></strong>：原子比较并交换操作，根据当前值与<code class="language-plaintext highlighter-rouge">expected</code>是否相等决定是否替换为<code class="language-plaintext highlighter-rouge">desired</code>。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">fetch_add(value)</code></strong>、<strong><code class="language-plaintext highlighter-rouge">fetch_sub(value)</code></strong>、<strong><code class="language-plaintext highlighter-rouge">fetch_or(value)</code></strong>等：执行加、减、或等操作并返回旧值。</li>
</ul>

<h4 id="原子变量的示例">原子变量的示例</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">counter</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">increment</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">counter</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 原子增加操作</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">increment</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">increment</span><span class="p">);</span>

    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Final counter value: "</span> <span class="o">&lt;&lt;</span> <span class="n">counter</span><span class="p">.</span><span class="n">load</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="多线程" /><summary type="html"><![CDATA[C++的atomic库和thread库是多线程编程中常用的库，提供了安全的并发操作支持。]]></summary></entry><entry><title type="html">算法和c++类面经</title><link href="http://localhost:4000/2024/10/11/Problem/" rel="alternate" type="text/html" title="算法和c++类面经" /><published>2024-10-11T10:00:00+08:00</published><updated>2024-10-11T10:00:00+08:00</updated><id>http://localhost:4000/2024/10/11/Problem</id><content type="html" xml:base="http://localhost:4000/2024/10/11/Problem/"><![CDATA[<h3 id="改进以下类">改进以下类</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">MyStruct</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">MyClass</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MyStruct</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">_val</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">_val</span><span class="p">)</span> <span class="p">{};</span>
<span class="nl">protected:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MyStruct</span><span class="o">&gt;</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>有两处要修改，一个内存对齐，把b放最前面；另外一个是<code class="language-plaintext highlighter-rouge">val(_val)</code>改为<code class="language-plaintext highlighter-rouge">val(std::move(_val))</code></p>

<h3 id="vector的resize和reserve的区别">vector的resize和reserve的区别</h3>

<ol>
  <li>reserve() 函数用于预先分配一定数量的内存空间，以容纳指定数量的元素，但并不改变 vector 的实际大小（即元素数量）。
 仅影响容量（capacity），不影响大小（size）。不会初始化元素，也不会调用元素的构造函数。
 如果 new_cap 小于等于当前容量，则 reserve() 不做任何操作。主要用于优化性能，减少因多次动态分配内存导致的开销。</li>
  <li>resize() 函数用于改变 vector 的大小（size），即元素的数量。根据新的大小，vector 会增加或减少元素。
 当新的大小大于当前大小时：vector 会增加新的元素，并对新元素进行默认初始化（或使用提供的 value 初始化）。如果新的大小超过当前容量（capacity），vector 会重新分配内存。
 当新的大小小于当前大小时：vector 会删除多余的元素，调用它们的析构函数。
 可能会改变容量，如果新的大小超过当前容量，vector 会自动扩容：如果 vector 之前已经包含元素，需要将这些元素从旧的内存区域移动或复制到新的内存区域。对于支持移动语义的元素类型（即具有移动构造函数），元素将被移动到新内存区域。如果元素类型不支持移动构造函数，但支持复制构造函数，元素将被复制到新内存区域。在成功分配新内存并移动/复制元素后，vector 会释放旧的内存空间。</li>
</ol>

<h3 id="题1">题1</h3>

<p>Point是两个浮点数pnl,drawdown的tuple，A是一个包含N个Point的List，求出所有处于efficient frontier上的Point， Point x处于efficient frontier上当且仅当A中不存在其他的Point y使得y.pnl &gt; x.pnl 并且 y.drawdown &lt; x.drawdown.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">pnl</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">drawdown</span><span class="p">;</span>
    <span class="n">Point</span><span class="p">(</span><span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="kt">double</span> <span class="n">d</span><span class="p">)</span> <span class="o">:</span> <span class="n">pnl</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">drawdown</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">// 比较函数，用于排序</span>
<span class="kt">bool</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">pnl</span> <span class="o">!=</span> <span class="n">b</span><span class="p">.</span><span class="n">pnl</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">pnl</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">pnl</span><span class="p">;</span> <span class="c1">// pnl 从大到小排序</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">drawdown</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">drawdown</span><span class="p">;</span> <span class="c1">// drawdown 从小到大排序</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">findEfficientFrontier</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;&amp;</span> <span class="n">points</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 复制一份数据，避免修改原始数据</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">sorted_points</span> <span class="o">=</span> <span class="n">points</span><span class="p">;</span>

    <span class="c1">// 按照定义的规则排序</span>
    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">sorted_points</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">sorted_points</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">compare</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">efficient_frontier</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">min_drawdown</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">infinity</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">point</span> <span class="o">:</span> <span class="n">sorted_points</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">point</span><span class="p">.</span><span class="n">drawdown</span> <span class="o">&lt;</span> <span class="n">min_drawdown</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">efficient_frontier</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">point</span><span class="p">);</span>
            <span class="n">min_drawdown</span> <span class="o">=</span> <span class="n">point</span><span class="p">.</span><span class="n">drawdown</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">efficient_frontier</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="最小子序和">最小子序和</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">MaxSubsequenceSum</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ThisSum</span><span class="p">,</span> <span class="n">MaxSum</span><span class="p">;</span>
    <span class="n">ThisSum</span> <span class="o">=</span> <span class="n">MaxSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span> 
        <span class="n">ThisSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="n">MaxSum</span> <span class="o">&gt;</span> <span class="n">ThisSum</span><span class="p">)</span>
            <span class="n">MaxSum</span> <span class="o">=</span> <span class="n">ThisSum</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">ThisSum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">ThisSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">MaxSum</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<h3 id="最大子序列乘积">最大子序列乘积</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span> <span class="nf">maxProduct</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">max_ending_here</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">min_ending_here</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">max_so_far</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">temp_max</span> <span class="o">=</span> <span class="n">max_ending_here</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">temp_min</span> <span class="o">=</span> <span class="n">min_ending_here</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">temp_max</span><span class="p">,</span> <span class="n">temp_min</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">max_ending_here</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">temp_max</span> <span class="o">*</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">min_ending_here</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">temp_min</span> <span class="o">*</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

        <span class="n">max_so_far</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max_so_far</span><span class="p">,</span> <span class="n">max_ending_here</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">max_so_far</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="面经" /><summary type="html"><![CDATA[改进以下类]]></summary></entry><entry><title type="html">数学题目类面经</title><link href="http://localhost:4000/2024/10/10/Problem2/" rel="alternate" type="text/html" title="数学题目类面经" /><published>2024-10-10T10:00:00+08:00</published><updated>2024-10-10T10:00:00+08:00</updated><id>http://localhost:4000/2024/10/10/Problem2</id><content type="html" xml:base="http://localhost:4000/2024/10/10/Problem2/"><![CDATA[<h3 id="题1">题1</h3>
<p>两个人抛硬币，正面为H，反面为T每个人可以选择一个长度为3的序列，如果抛到该序列则胜利，如果A选择了HTH序列，B该选择什么序列保证自己的胜率最高。</p>

<p>看绿皮书Markov链</p>

<h3 id="题2">题2</h3>

<p>n个学生围成一圈，每个人有若干个糖果，接下来按照以下步骤重复分配：</p>
<ol>
  <li>如果有人有奇数个糖果，则会从老师那里额外拿到一个糖果；</li>
  <li>然后所有人将自己一半数量的糖果给左侧的人；
证明：有限步之后每个人的糖果数量是相同的。</li>
</ol>

<h3 id="题3">题3</h3>

<p>有10000个硬币，全部抛起来后，记正面朝上的个数为X，求X=5000的概率（一位有效数字即可）</p>

<p>这是一个二项分布n=10000,p=0.5
当n很大时可以近似于正态分布，$\mu = np = 5000, \sigma^2 = np(1-p) = 2500.$</p>

<p>再将X标准化$Z= \frac{X-\mu}{\sigma} \sim N(0,1)$
$P(4999.5&lt; X&lt; 5000.5) = \Phi(0.01)-\Phi(-0.01) = 0.5040−0.4960=0.0080$</p>

<h3 id="题4">题4</h3>
<p>给出以下问题的解析解：</p>
<ol>
  <li>一个n位线性字符串，每一位都是0或1，求不存在相邻的1的字符串的个数。</li>
  <li>一个n为环形字符串，每一位都是0或1，求不存在相邻的1的字符串的个数。</li>
</ol>

<h3 id="题5">题5</h3>
<p>有N个石头，每个人可以拿若干个石头，第一个人不能全拿光，后面的人不能拿的比前面的人多，请问N什么时候先手必胜，什么时候后手必胜。</p>

<p>分为奇数，2m,4m,其中m为奇数，还有2的幂次。</p>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="面经" /><summary type="html"><![CDATA[题1 两个人抛硬币，正面为H，反面为T每个人可以选择一个长度为3的序列，如果抛到该序列则胜利，如果A选择了HTH序列，B该选择什么序列保证自己的胜率最高。]]></summary></entry><entry><title type="html">概率论:随机变量（绿皮书+额外补充）</title><link href="http://localhost:4000/2024/09/26/Probability2/" rel="alternate" type="text/html" title="概率论:随机变量（绿皮书+额外补充）" /><published>2024-09-26T10:00:00+08:00</published><updated>2024-09-26T10:00:00+08:00</updated><id>http://localhost:4000/2024/09/26/Probability2</id><content type="html" xml:base="http://localhost:4000/2024/09/26/Probability2/"><![CDATA[<h1 id="一元随机变量与分布函数">一元随机变量与分布函数</h1>

<h2 id="离散型随机变量">离散型随机变量</h2>

<ol>
  <li>0-1分布：$P(X=0)=p,P(X=1)=1-p$.</li>
  <li>二项分布：X可看做n个0-1分布重复独立试验，试验成功的次数，$P(X=k) = C_n^kp^k(1-p)^{n-k}$，记作$X \sim B(n,p).$</li>
  <li>泊松分布：$P(X=k) = \frac{e^{-\lambda}\lambda^k}{k!}$,记作$X \sim P(\lambda)$.</li>
  <li>超几何分布：$P(X=k)=\frac{C_a^kC_b^{n-k}}{C_N^n}$，记作$X\sim H(n,a,N)$，就是N个球，a个红球b个白球，不放回取n个，X为红球的个数。</li>
  <li>几何分布：$P(X=k)=p(1-p)^{k-1}$，独立重复Bernoulli试验，第k次首次成功的概率。</li>
  <li>负二项分布：$P(X=k)=C_{k-1}^{r-1}(1-p)^{kr}p^r$，试验进行到出现r次成功才停止，X为饰演的次数。</li>
</ol>

<p>可以证明当n足够大，p足够小，且np保持适当大小时，$B(n,p)$可以用$P(np)$近似表述。</p>

<h2 id="概率分布函数">概率分布函数</h2>

<p>概率分布函数定义为$F(x) = P(X\leq x)$，具有以下性质：</p>
<ol>
  <li>$P(x_1\leq X \leq x_2) = F(x_2) - F(x_1) + P(X=x_1)$</li>
  <li>$F(x)$单调不减</li>
  <li>$0\leq F(x) \leq 1, \lim_{a\rightarrow -\infty}F(a) = 0, \lim_{a\rightarrow \infty}F(a) = 1.$</li>
  <li>$F(x)$右连续，离散型的$F(x)$没有左连续。</li>
</ol>

<h2 id="连续型随机变量">连续型随机变量</h2>

<p>如果存在一个非负实函数$f(x)$满足$F(x)=\int_{-\infty}^x f(t)dt$，则称X为连续型随机变量，$f(x)$为概率密度函数，具有以下性质：</p>
<ol>
  <li>$f(x)\geq 0$</li>
  <li>$\int_{-\infty}^{\infty}f(t)dt = 1$</li>
  <li>$\forall x_1&lt;x_2, P(x_1\leq X\leq x_2) = \int_{x_1}^{x_2} f(t)dt$</li>
  <li>在$f(x)$的连续点处，$F’(x)=f(x)$</li>
  <li>$\forall a, P(X=a) = 0.$</li>
</ol>

<p>常见的连续型随机变量：</p>
<ol>
  <li>均匀分布：$f(x)=\begin{cases}
 \frac{1}{b-a}, x\in(a,b) <br />
 0, 其他
 \end{cases}$，记作$X\sim U(a,b).$
 $P(c&lt;X&lt;c+l) = \frac{l}{b-a}, F(x)=\begin{cases}
     0, x&lt;a \ \frac{x-a}{b-a}, a\leq x &lt; b <br />
     1, x\geq b
 \end{cases}$</li>
  <li>
    <p>指数分布：$f(x)= \begin{cases}
 \lambda e^{-\lambda x}, x&gt; 0 <br />
 0, x\leq 0
 \end{cases}$，记作$X\sim E(\lambda).$
 $F(x) =\int_{-\infty}^x f(t)dt = \begin{cases}
     1-e^{-\lambda x}, x&gt;0 \ 0, x\leq 0
 \end{cases}$</p>

    <p>指数分布最重要的性质是无记忆性：$P(X&gt;t_0+t|X&gt;t_0) = \frac{P(X&gt;t_0+t)}{P(X&gt;t_0)} = e^{-\lambda t} = P(X&gt;t)$,即$P(X&gt;t_0+t) = P(X&gt;t_0)P(X&gt;t)$.可以联想到某产品的正常使用时长。
 类似的无记忆性还有几何分布：$P(X-m=n)=P(X=m)P(X=n)$，可以联想到抛硬币。</p>
  </li>
  <li>正态分布：$f(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{\frac{-(x-\mu)^2}{2\sigma^2}}, |x| &lt; +\infty,\sigma&gt;0,|\mu|&lt;+\infty$，记作$X\sim N(\mu,\sigma^2)$服从参数为$(\mu,\sigma)$的正态分布。
 （补充：$\int_{-\infty}^{+\infty}e^{-x^2}dx=\sqrt{\pi}.$）
 正态分布具有以下性质：
    <ol>
      <li>$f(x)$关于$x=\mu$对称</li>
      <li>$ \max f(x) = f(\mu) = \frac{1}{\sqrt{2\pi}\sigma}$</li>
      <li>$ \lim_{|x-\mu|\rightarrow \infty} f(x) = 0$</li>
    </ol>

    <p>当$\mu=0,\sigma=1$的时候称为标准正态分布，密度函数为$\varphi(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}$,分布函数为$\varPhi(x) = \int_{-\infty}^x \frac{1}{\sqrt{2\pi}}e^{-\frac{t^2}{2}}dt$，具有性质：</p>
    <ol>
      <li>$\varPhi(-x) = 1-\varPhi(x)$</li>
      <li>当$X\sim N(\mu,\sigma^2)$时，$\frac{X-\mu}{\sigma} \sim N(0,1) \Rightarrow P(a&lt;x&lt;b) = \varPhi(\frac{b-\mu}{\sigma})-\varPhi(\frac{a-\mu}{\sigma})$</li>
    </ol>
  </li>
</ol>

<h2 id="一维随机变量函数的分布">一维随机变量函数的分布</h2>

<p>若X分布已知，Y=g(X).</p>
<ol>
  <li>当Y是离散型时，找到${Y=y_k}$的等价事件${X\in D_k}$，则有$P(Y=y_k) = P(X\in D_k)$.</li>
  <li>当Y是连续型时同样可以求出分布函数$F_Y$，求导获得$f_Y$.</li>
</ol>

<p><strong>如果$X$为连续型，密度函数为$f_X(x),\ y=g(X)$，如果$y=g(X)$严格单增(减)，记$y=g(x)$的反函数为$x=h(y)$，则有</strong></p>

\[f_Y(y) = \begin{cases}
    f_X(h(y))\|h'(y)\|, y\in D \\
    0, y\notin D
\end{cases}, D为y=g(x)的值域.\]

<p><strong>1. $X\sim N(\mu,\sigma)$，求$aX+b$的密度函数：</strong>
$y=g(X)=aX+b \Rightarrow x = h(y) = \frac{y-b}{a}$,
$h’(y)=\frac{1}{a} \Rightarrow f_Y(y) = \frac{1}{|a|}f_X(\frac{y-b}{a}).$</p>

<p><strong>2. $X\sim U(0,\pi),Y=\sin(x)$，求$f_Y(y)$：</strong>
 当$0&lt; y \leq 1, F_Y(y)=P(Y\leq y) = P(X\in[0,\arcsin y]\cup [\pi-\arcsin y,\pi]) = \frac{2\arcsin y}{\pi}$
 因此$f_Y(y)=\begin{cases}
    \frac{2}{\pi} \frac{1}{\sqrt{1-y^2}}, 0 &lt; y \leq 1<br />
    0, 其他
 \end{cases}$
（补充：$(\arccos x)’ = -\frac{1}{\sqrt{1-x^2}}, (\arctan x)’ = \frac{1}{1+x^2}.$）</p>

<p><strong>有了连续型随机变量后可以去证明$P(AB)=0$并不能证明AB互斥，比如在$(0,1)$上取值，A为(0,0.5],B为[0.5,1).</strong></p>

<h1 id="多元随机变量及其分布">多元随机变量及其分布</h1>

<h2 id="二元离散型随机变量">二元离散型随机变量</h2>

<ol>
  <li>联合分布律：$P(X=x_i,Y=y_j) = p_{ij}, \sum_{i,j}p_{ij}=1, p_{ij}\geq 0.$</li>
  <li>
    <p>边际分布：$p_{i\cdot}=\sum_{j}p_{ij} = P(X=x_i), p_{\cdot j} = \sum_i p_{ij} = P(Y=y_j).$</p>
  </li>
  <li>条件分布：$P(X=x_i | Y=y_j) = \frac{p_{ij}}{p_{\cdot j}}$,
 P(Y=y_j | X=x_i) = \frac{p_{ij}}{p_{i\cdot}}.$</li>
</ol>

<h2 id="分布函数">分布函数</h2>

<ol>
  <li>联合分布函数：$F(x,y) = P(X\leq x, Y \leq y)$，有性质：
    <ol>
      <li>$F(x,y)$单调不减</li>
      <li>$0\leq F(x,y) \leq 1, F(x,-\infty) = F(-\infty,y) = 0, F(+\infty,+\infty) = 1.$</li>
      <li>$F(x,y)$关于x或y右连续</li>
      <li>$P(x_1&lt;X\leq x_2, y_1 &lt; Y \leq y_2) = F(x_2,y_2)- F(x_1,y_2) -F(x_2,y_1)+F(x_1,y_1).$</li>
    </ol>
  </li>
  <li>边际分布函数：$F_X(x) = P(X\leq x) = F(x,+\infty), F_Y(y)= F(+\infty,y).</li>
  <li>条件分布函数：
    <ol>
      <li>离散型：$F_{Y|X}(y|x_i) = P(Y\leq y| X=x_i)$</li>
      <li>连续型：$F_{Y|X}(y|x) = \lim_{\delta\rightarrow 0^+} P(Y\leq y| x &lt; X \leq x+\delta)$</li>
    </ol>
  </li>
</ol>

<h2 id="连续型随机变量-1">连续型随机变量</h2>

<ol>
  <li>$F(x,y) =\int_{-\infty}^x\int_{-\infty}^y f(u,v) dudv$，$f(x,y)$称为联合概率密度函数，性质有：
    <ol>
      <li>$f(x,y)\geq 0$</li>
      <li>$\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty} f(x,y) dxdy = F(+\infty,+\infty) =1$</li>
      <li>在$f(x,y)$连续点上有$\frac{\partial^2F}{\partial x\partial y} = f(x,y).$</li>
      <li>$P((X,Y)\in D) = \int\int_D f(x,y) dxdy.$</li>
    </ol>
  </li>
  <li>边际概率密度函数：$F_X(x) = P(X\leq x) = \int_{-\infty}^x[\int_{-\infty}^{+\infty}f(x,y)dy]dx \Rightarrow f_X(x) = \int_{-\infty}^{\infty}f(x,y)dy.$
 同理 $f_Y(y) = \int_{-\infty}^{+\infty}f(x,y)dx.$</li>
  <li>条件分布：$F_{Y|X}(y|x) = \lim_{\delta\rightarrow 0^+} P(Y\leq y| x &lt; X \leq x+\delta) = \lim_{\delta\rightarrow 0^+}\frac{F(x+\delta,y)-F(x,y)}{F_X(x+\delta) - F_X(x)} = \int_{-\infty}^y \frac{f(x,v)}{f_X(x)}dv.$
 因此条件概率密度函数$f_{Y|X}(y|x)=\frac{f(x,y)}{f_X(x)}.$
二元均匀分布：$f(x,y) = \begin{cases}
 \frac{1}{S(D)}, (x,y)\in D <br />
 0, 其他
\end{cases}$</li>
</ol>

<p>二元正态分布：$f(x,y) = \frac{1}{2\pi\sigma_1\sigma_2\sqrt{1-\rho^2}}\exp{-\frac{1}{2(1-\rho^2)}[\frac{(x-\mu_1)^2}{\sigma_1^2} - 2\rho\frac{(x-\mu_1)(y-\mu_2)}{\sigma_1\sigma_2} + \frac{(y-\mu_2)^2}{\sigma_2^2}]}$，有以下性质：</p>
<ol>
  <li>$X\sim N(\mu_1,\sigma_1^2), Y\sim N(\mu_2,\sigma_2^2).$</li>
  <li>给定$X=x, Y \sim N(\mu_2+\rho\frac{\sigma_2}{\sigma_1}(x-\mu_1), (1-\rho^2)\sigma_2^2)$</li>
  <li>给定$Y=y, X \sim N(\mu_1+\rho\frac{\sigma_1}{\sigma_2}(y-\mu_2), (1-\rho^2)\sigma_1^2)$</li>
</ol>

<p><strong>如果X为离散型随机变量，概率分布为p_X(x_i)，由全概率公式有\(P(A)=\sum_iP(A\|X=x_i)P(X=x_i)\)</strong>
<strong>如果X为连续型，其密度函数为$p_X(x)$，则\(P(A) = \int_{-\infty}^{+\infty}P(A\|X=x)p_X(x).\)</strong></p>

<p>例子：设$U_1,\cdots,U_n$独立同分布于$(0,1]$上的均匀分布，令$\xi = \min{n\geq 1: U_1+\cdots+U_n &gt; 1}$，求$\xi$的概率分布。</p>

<p>令$\xi(x)=\min{n\geq 1: U_1+\cdots+U_n &gt; x}$，则有
$P(\xi(x)&gt; 1) = P(U_1\leq x) = x$，进而有递推关系
\(\begin{align*}
    P(\xi(x)&gt;n+1) &amp;= P(U_1+\cdots+U_{n+1} \leq x) \\
    &amp;= \int_{-\infty}^{+\infty}P(U_1+\cdots+U_{n+1} \leq x \| U_1 = y)p_{U_1}(y)dy \\
    &amp;= \int_0^1 P(U_2+\cdots+U_{n+1} \leq x-y)dy \\
    &amp;= \int_0^x P(\xi(u)&gt;n)du
\end{align*}\)
由归纳法可以得到$P(\xi(x)&gt;n) = \frac{x^n}{n!}$，因此可以得到$P(\xi&gt;n)=\frac{1}{n!}\Rightarrow P(\xi = n) = \frac{1}{(n-1)!} - \frac{1}{n!}.$</p>

<h2 id="随机变量的独立性">随机变量的独立性</h2>

<p>离散型：$p_{ij} = p_{i\cdot}p_{\cdot j}, i,j=1,2,\ldots$
连续型：$f(x,y) = f_X(x)f_Y(y), a.e. \Leftrightarrow f(x,y)$几乎处处可以写为$m(x)$与$n(y)$的乘积，<strong>注意f的取值范围，y不能与x有关</strong></p>

<p>例：二元正态分布中，XY相互独立$\Leftrightarrow \rho = 0.$</p>

<h2 id="二元随机变量函数的分布">二元随机变量函数的分布</h2>

<h4 id="zxy的分布">$Z=X+Y$的分布</h4>

<p>离散型：\(P(Z=z_k) = \sum_{i=1}^{\infty}P(X=x_i, Y=z_k-x_i), k=1,2,\ldots.\)</p>

<p>连续型：
\(\begin{align*}
    F_Z(z) &amp;= \int\int_{x+y\leq z} f(x,y)dxdy \ \int_{-\infty}^{+\infty}dx\int_{-\infty}^{z-x} f(x,y)dy \\
    &amp;= \int_{-\infty}^z dv \int_{-\infty}^{+\infty} f(u,v-u)du\quad(u=x,v=x+y) \\
    f_Z(z) &amp;= \int_{-\infty}^{+\infty} f(x,z-x)dx = \int_{-\infty}^{+\infty}f(z-y,y)dy
\end{align*}\)
特别地，当XY相互独立时，\(f_Z(x) = \int_{-\infty}^{+\infty}f_X(x)f_Y(z-x)dx = \int_{-\infty}^{+\infty} f_X(z-y)f_Y(y)dy.\)</p>

<p>例：</p>
<ol>
  <li>$X,Y$相互独立，$X\sim P(\lambda_1), Y\sim P(\lambda_2) \Rightarrow X+Y \sim P(\lambda_1+\lambda_2)$</li>
  <li>${X_i}$相互独立，$X_i\sim N(\mu_i,\sigma_i^2) \Rightarrow \sum_iX_i \sim N(\sum_i\mu_i, \sum_i \sigma_i^2).$</li>
</ol>

<h4 id="zfracxy的分布">$Z=\frac{X}{Y}$的分布</h4>

\[\begin{align*}
    F_Z(z) &amp;= P(\frac{X}{Y}\leq z) = \int\int_{x/y\leq z}f(x,y)dxdy \\
    &amp;= \int_0^{\infty}dy\int_{-\infty}^{yz}f(x,y)dx + \int_{-\infty}^0dy\int_{yz}^{+\infty}f(x,y)dx \\
    &amp;= \int_{-\infty}^z \left[ \int_0^{\infty}p(ay,y)ydy -\int_{-\infty}^0 p(ay,y)ydy\right]da\quad (这里令x=ay) \\
    &amp;= \int_{-\infty}^zp_Z(a)da \\
    p_Z(z) &amp;= \int_{-\infty}^{\infty}p(zx,x)\|x\|dx.
\end{align*}\]

<h4 id="次序统计量的分布">次序统计量的分布</h4>

<p>设$X_1,\ldots, X_n$独立同分布，分布函数均为$F(x)$，令$\xi_1 = \min(X_1,\ldots,X_n), \xi_2 = \max(X_1,\ldots,X_n).$</p>

\[\begin{align*}
    P(\xi_2 \leq x) &amp;= P(X_1\leq x,\ldots, X_n\leq x) \\
    &amp;= P(X_1\leq x)\cdots P(X_n\leq x) \\
    &amp;= [F(x)]^n \\
    p(x) &amp;= nf(x)(F(x))^{n-1}
\end{align*}\]

\[\begin{align*}
    P(\xi_1 &gt; x) &amp;= P(X_1 &gt; x, \ldots, X_n &gt; x) \\
    &amp;= [1-F(x)]^n \\
    P(\xi_1 \leq x) &amp;= 1-[1-F(x)]^n. \\
    p(x) &amp;= nf(x)[1-F(x)]^{n-1}
\end{align*}\]

<p>$(\xi_1,\xi_2)$的联合分布函数
\(\begin{align*}
    F(x,y) &amp;= P(\xi_1\leq x, \xi_2 \leq y) \\
    &amp;= P(\xi_2 \leq y) - P(\xi_1 &gt; x, \xi_2\leq y) \\
    &amp;= [F(y)]^n - P(\bigcap_{i=1}^n(x &lt; \xi_i \leq y)) \\
    &amp;=\begin{cases}
        [F(y)]^n - [F(y) - F(x)]^n , x&lt;y \\
        [F(y)]^n, x\geq y
    \end{cases}
\end{align*}\)</p>

<h3 id="最大值和最小值的相关系数">最大值和最小值的相关系数</h3>

<p>$X_1,X_2$独立同分布于$U(0,1), Y=\min(X_1,X_2), Z+\max(X_1,X_2)$，请问给定$Z\leq z$时$Y\geq y$的概率是多少？ Y和Z的相关系数是多少？</p>

<p>通过画图可以看出来$P(Y\geq y | Z\leq z) = \begin{cases}
    (z-y)^2 / z^2, 0\leq y \leq z \leq 1,
    0, 其他
\end{cases}$</p>

<p>$\rho_{YZ} = \frac{Cov(Y,Z)}{\sqrt{Var(Y)Var(Z)}}$</p>

<p>首先求$Var(Y),Var(Z),f_Y(x)=2(1-x),f_Z(z)=2z$，可以去计算$E(Y)=\frac{1}{3},E(Z)=\frac{2}{3},E(Y^2)=\frac{1}{6},E(Z^2)=\frac{1}{2}\Rightarrow Var(Y)=E(Y^2)-E(Y)^2 = \frac{1}{18}, Var(Z)=\frac{1}{18}.$</p>

<p>紧接着要计算$E(YZ)=\int_0^1\int_0^zyzf(y,z)dydz$，因此要求$Y,Z$的联合密度函数，先计算联合分布函数：
$F(y,z)=P(Y\leq y, Z\leq z) = P(Z\leq z) - P(Y\geq y,Z\leq z) = z^2-(z-y)^2 = 2zy-y^2 \Rightarrow f(y,z) = \frac{\partial F(y,z)}{\partial y\partial z} = 2.$</p>

<p>因此$E(YZ)=\int_0^1 \int_0^z 2yzdydz = \frac{1}{4}\Rightarrow Cov(Y,Z) =E(YZ)-E(Y)E(Z)=\frac{1}{36} \Rightarrow \rho_{YZ}=\frac{1}{2}.$</p>

<h2 id="随机向量的变换">随机向量的变换</h2>

<p>$(\xi_1,\ldots,\xi_n)$密度函数为$p(x_1,\ldots,x_n)$，现有$m$个函数$\eta_i = f_i(\xi_1,\ldots,\xi_n)$，其联合分布函数为\(G(y_1,\ldots,y_m)=P(\eta_1\leq y_1,\ldots, \eta_m\leq y_m) = \int_\cdots\int_D p(x_1,\ldots,x_n) dx_1\cdots dx_n.\)
其中$D ={(x_1,\ldots,x_n : \eta_1\leq y_1,\ldots, \eta_n \leq y_n)}$</p>

<p>如果$m=n$并且$f_i$有唯一反函数组$x_i = x_i(y_1,\ldots,y_n)$并且$J = \frac{\partial(x_1,\ldots,x_n)}{\partial(y_1,\ldots,y_n)}\neq 0$，那么有
\(q(y_1,\ldots,y_n) = \begin{cases}
    p(x_1(y_1,\ldots,y_n),\ldots)\|J\|, (y_1,\ldots,y_n)\in (\eta_1,\ldots,\eta_n)的值域 \\
    0, 其他
\end{cases}\)</p>

<h1 id="数字特征">数字特征</h1>

<h2 id="数学期望">数学期望</h2>

<p>离散型：$EX=\sum_k x_kp_k$
连续型：$EX=\int_{-\infty}^{\infty}xp(x)dx$</p>

<p>有以下性质：</p>
<ol>
  <li>$E(g(X)) = \int g(x)p(x)dx$</li>
  <li>可加性</li>
  <li>有限个独立的随机变量乘积的期望等于乘积的期望</li>
</ol>

<h2 id="条件期望">条件期望</h2>

<p>$E(\eta|\xi =x) = \int_{-\infty}^{\infty} ydF_{\eta|\xi}(y|x)$</p>

<p>离散型：$E(\eta|\xi =x) = \sum_j y_jp_{\eta|\xi}(y_j|x)$
连续型：$E(\eta|\xi =x) = \int_{-\infty}^{\infty} y p_{\eta|\xi}(y|x)dy$</p>

<h2 id="全期望公式">全期望公式</h2>

<p>$E(X) = E(E(X|Y)) = \begin{cases}
    \sum_y E(X|Y=y)p(Y=y), Y为离散型 <br />
    \int_{-\infty}^{\infty} E(X|Y=y)f_Y(y)dy, Y为连续型
\end{cases}$</p>

<h2 id="方差协方差相关系数">方差、协方差、相关系数</h2>

<p><strong>方差</strong>$Var\xi = E(\xi-E\xi)^2 = E(\xi^2) - E(\xi)^2$
方差性质：</p>
<ol>
  <li>$Var(c\xi+b) = c^2Var(\xi)$</li>
  <li>$Var\xi \leq E(\xi-c)^2$，等号成立当且仅当$c=E\xi$</li>
  <li>$Var(\sum_{i=1}^n \xi_i) = \sum_{i=1}^nVar\xi_i + 2\sum_{1\leq i,j\leq n}E(\xi_i-E\xi_i)(\xi_j-E\xi_j)$，特别地，如果它们两两独立，则有$Var(\sum_{i=1}^n \xi_i) = \sum_{i=1}^nVar\xi_i$</li>
</ol>

<p>称$\xi^* = \frac{\xi-E\xi}{\sqrt{Var\xi}}$为$\xi$的标准化，期望为0，方差为1.</p>

<p>例：两两独立的n个正态分布的和仍服从正态分布:$c_0+c_1X_1+\cdots+c_nX_n \sim N(c_0+c_1\mu_1+\cdots+c_n\mu_n,c_1^2\sigma_1^2+\cdots+c_n^2\sigma_n^2)$</p>

<p><strong>协方差</strong>$Cov(X,Y)=E(X-EX)(Y-EY) = E(XY)-E(X)E(Y)$
协方差性质：</p>
<ol>
  <li>$Cov(X,Y)=Cov(Y,X), Cov(X,a)=0$</li>
  <li>$Cov(X,X)=Var(X)$</li>
  <li>$Cov(aX,bY)=abCov(X,Y)$</li>
  <li>$Cov(X_1+X_2,Y) =Cov(X_1,Y)+Cov(X_2,Y)$</li>
  <li>$X,Y$独立可以推出$Cov(X,Y)=0$，反过来不一定</li>
  <li>$Var(X)Var(Y)\neq 0$的时候$(Cov(X,Y))^2 \leq Var(X)Var(Y)$，等号成立当且仅当$\exists c_1,c_2, s.t. P(Y=c_1+c_2X) = 1$(严格线性关系)</li>
</ol>

<p><strong>相关系数</strong>$\rho_{XY} = \frac{Cov(X,Y)}{\sqrt{Var(X)Var(Y)}}, |\rho_{XY}| \leq 1.$
相关系数性质：</p>
<ol>
  <li>$X,Y$相互独立可以推出$\rho_{XY}=0$，反之不一定</li>
  <li>$|\rho_{XY}|\leq 1$，等号成立当且仅当X和Y有严格线性关系，也就是说$|\rho_{XY}|$反映的是$X$和$Y$的线性关系密切程度</li>
  <li>$\rho_{XY}&gt;0$称为正相关，反之为负相关</li>
  <li>若$\rho_{XY}=0$，称X和Y不相关</li>
  <li>$\rho_{XY} = 0 \Leftrightarrow E(XY)=E(X)E(Y) \Leftrightarrow Var(X+Y)=Var(X)+Var(Y)$</li>
</ol>

<div align="center"> <img src="/pic/QuantGuideBook/Discrete.jpeg" width="600" /> </div>

<div align="center"> <img src="/pic/QuantGuideBook/Continuous.jpeg" width="600" /> </div>

<h2 id="例题">例题</h2>

<h3 id="相遇概率">相遇概率</h3>

<p><strong>两个人会在五点到六点的任意时间到达车站，他们会呆五分钟然后离开，他们每天遇到的概率是多少？</strong></p>

<p>这道题画图最直接，最终概率就是$\frac{60<em>60-2</em>(0.5<em>55</em>55)}{60*60} = \frac{23}{144}.$</p>

<h3 id="三角形概率">三角形概率</h3>

<p><strong>将一个棍子切成三段，能组成一个正方形的概率是多少？</strong></p>

<p>记两次切的位置分别为$x,y, x&lt;y$，则有
\(\begin{align*}
    x+(y-x) &gt; 1-y &amp;\Rightarrow y&gt;1/2 \\
    x+(1-y) &gt; y-x &amp;\Rightarrow y&lt;1/2+x \\
    (y-x)+(1-y) &gt; x \Rightarrow x &lt; 1/2
\end{align*}\)</p>

<p>因此概率为$2\times \frac{1}{8} = \frac{1}{4}$，因为$x&gt;y$是完全对称的情况。</p>

<h3 id="矩生成函数">矩生成函数</h3>

<p><strong>令$M(t) = E(e^{tX})$，则有$M^{n}(0)=E(X^n)$.</strong></p>

<p>若$X \sim N(0,1)$，则
$M(t) = \int_{-\infty}^{\infty}e^{tx}\frac{1}{\sqrt{2\pi}}e^{-x^2/2}dx = e^{t^2/2}\int_{-\infty}^{\infty}\frac{1}{\sqrt{2\pi}}e^{-(x-t)^2/2}dx = e^{t^2/2}$</p>

<p>因此$M’(0) = 0, M’‘(0)=1, M^3(0)=0, M^4(0)=3.$</p>

<h3 id="数面条">数面条</h3>

<p><strong>如果碗里面有100个面条，你拿起面条的两个端点将他们连在一起，持续做这件事直到没有端点，请计算圆圈的期望数量。</strong></p>

<p>如果只有一根那就是1，两根的话有4个端点，有$C_4^2=6$种拿法，其中有两种是直接将各自圈起来，因此圆圈的期望数量为$E(f(2))=\frac{2}{6}\times (1+E(f(1))) + \frac{4}{6} \times E(f(1)) = \frac{1}{3} + E(f(1)) = 1 + \frac{1}{3}$</p>

<p>以此类推，可以发现$E(f(n)) = 1+\frac{1}{3}+\cdots+\frac{1}{2n-1}.$ 再用归纳法进行证明。</p>

<h3 id="最优对冲比例">最优对冲比例</h3>

<p><strong>你买了一份A股票，现在你想卖出一些B股票来对冲，你应该卖多少来使得你的利润方差最小化？假设A、B股票回报方差为$\sigma_A^2,\sigma_B^2$，它们的相关系数为$\rho$.</strong></p>

<p>我们要最小化$Var(r_A-hr_B) = \sigma_A^2 + h^2\sigma_B^2 - 2h\rho\sigma_A\sigma_B \Rightarrow h = \rho\frac{\sigma_A}{\sigma_B}.$</p>

<h3 id="骰子游戏">骰子游戏</h3>

<p><strong>每次掷骰子，你都要支付那个面的数值，如果转到4\5\6则可以再投一次，否则游戏停止，请问游戏的花费期望是多少。</strong></p>

<p>$Y$记为第一次掷骰子的点数，$X$为花费，则有$E(X|Y\in{1,2,3}) = 2, E(X|Y\in{4,5,6}) = 5 + E(X)$，因此$E(X) =\frac{1}{2}(7+E(X)) \Rightarrow E(X)=7.$</p>

<h3 id="卡牌游戏">卡牌游戏</h3>

<p><strong>你在一张一张翻扑克牌，翻到第一张Ace所需要翻的牌数期望是多少？</strong></p>

<p>令$X_i=1$如果卡牌$i$在Ace之前被翻，否则为0，那么$E(X)=1+\sum_{i=1}^48E(X_i)$</p>

<p><strong>注意$P(X_i=1)=\frac{1}{5}$，这里可以考虑是第i个牌随机插入到由4个Ace构成的队列中，只有放在队首才能够满足。</strong></p>

<p>因此$E(X) = 1+ \frac{48}{5}$</p>

<h3 id="随机变量的和">随机变量的和</h3>

<p><strong>假设$X_1,\ldots,X_n$独立同分布于$(0,1)$上的均匀分布，$S_n=X_1+\cdots+X_n \leq 1$的概率是多少？</strong></p>

<p>用归纳法证明$P(S_n\leq 1) = \frac{1}{n!}.$</p>

<p>$P(S_{n+1}\leq 1) = \int_{0}^1 f(X_{n+1})P(S_n\leq 1-X_{n+1})dX_{n+1}=\int_0^1 \frac{(1-X_{n+1})^n}{n!} =\frac{1}{(n+1)!}$</p>

<h3 id="收集优惠券">收集优惠券</h3>

<p><strong>现在盒子里有N种不同的优惠券。（每种有很多张，相当于抽取后又放回）</strong></p>
<ol>
  <li><strong>如果一个孩子想要集齐所有的优惠券，平均需要多少个？</strong>
 令$X_i$为收集到$(i-1)$个不同类型后收集到第$i$种优惠券所需优惠券的数量，因此$X=X_1+\cdots+X_N$
 对于任意的$i$，已收集$i-1$种类型，获得一个新类型的概率为$1-\frac{i-1}{N}$，这就相当于一个概率为$1-\frac{i-1}{N}$的几何分布，因此$E(X_i)=\frac{N}{N-i+1}$，
 可以得到$E(X)=\sum_{i=1}^NE(X_i)=\sum_{i=1}^N \frac{N}{N-i+1}.$</li>
  <li><strong>如果已经收集到n个优惠券，优惠券种类数的期望是多少？</strong>
 这里引入 <strong>indicator random variables</strong> $I_i$，其中$I_i=1$如果第$i$个类型在这$n$个优惠券中，否则为0，
 由此可以得到$Y=\sum_{i=1}^NI_i,$对于任意一个优惠券，它不是第$i$种优惠券的概率为$\frac{N-1}{N}$，
 可以得到$P(I_i=0) = (\frac{N-1}{N})^n\Rightarrow E(I_i)=P(I_i=1) = 1-(\frac{N-1}{N})^n.$
 可以得到$E(Y)=\sum_{i=1}^NE(I_i)=N(1-(\frac{N-1}{N})^n).$</li>
</ol>

<h3 id="违约概率">违约概率</h3>

<p><strong>合同A明年违约概率为50%，合同B为30%，请问至少一个合同违约的概率在什么范围内以及它们之间的相关系数在什么范围内？</strong></p>

<p>至少一个合同违约的概率最大为80%（A违约B就不违约），最小为50%（A违约B就一定违约）
$I_A=1$表示A会违约，则有$E(I_A)=0.5,Var(I_A)=0.25,E(I_B)=0.3, Var(I_B)=0.21$
\(\begin{align}
    P(I_A=1 \|\| I_B=1) &amp;= E(I_A)+E(I_B)-E(I_AI_B) \\
    &amp;= E(I_A) + E(I_B) -(E(I_A)E(I_B)-Cov(I_A,I_B)) \\
    &amp;= 0.8-(0.15-\rho_{AB}\sigma_A\sigma_B) \\
    &amp;= 0.65 - \sqrt{0.21}/2 \rho_{AB}
\end{align}\)
$0.5 \leq 0.65-\sqrt{0.21}/2 \rho_{AB} \leq 0.8 \Rightarrow -\sqrt{3/7}\leq \rho_{AB} \leq \sqrt{3/7}.$</p>

<h3 id="随机蚂蚁">随机蚂蚁</h3>

<p>略，记住蚂蚁相遇只需调换标签即可。</p>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="量化绿皮书" /><summary type="html"><![CDATA[一元随机变量与分布函数]]></summary></entry><entry><title type="html">概率论:事件及其概率（绿皮书+额外补充）</title><link href="http://localhost:4000/2024/09/25/Probability/" rel="alternate" type="text/html" title="概率论:事件及其概率（绿皮书+额外补充）" /><published>2024-09-25T10:00:00+08:00</published><updated>2024-09-25T10:00:00+08:00</updated><id>http://localhost:4000/2024/09/25/Probability</id><content type="html" xml:base="http://localhost:4000/2024/09/25/Probability/"><![CDATA[<h1 id="事件及其概率">事件及其概率</h1>

<h2 id="基础的概率定义和集合操作">基础的概率定义和集合操作</h2>

<h3 id="掷硬币游戏">掷硬币游戏</h3>

<p><strong>A有$(n+1)$个公平的硬币而B有$n$个，如果他们将所有的硬币抛掷，A能有更多正面朝上硬币的概率是多少？</strong></p>

<p>可以从A的硬币中取走一个，那么此时A和B是对称的，此时有三种情况：</p>
<ol>
  <li>A的n个硬币正面朝上的更多，概率记作$P(E_1)=x$.</li>
  <li>一样多，概率记作$P(E_2)=y$.</li>
  <li>B的更多，概率记作$P(E_3)=x$.</li>
</ol>

<p>此时再考虑最后一枚硬币，对于第一个情况，A始终有更多的正面朝上的硬币；对于第二种情况，最后一枚硬币需要朝上；第三种情况则A不可能有更多的正面朝上的硬币，因此概率为$x+0.5y = 0.5.$</p>

<h3 id="扑克游戏">扑克游戏</h3>

<p><strong>现在有52张牌，你拿一张然后荷官拿一张，如果你的数字大你才赢，那么你赢的概率是多少？</strong></p>

<p>可以直接去计算概率$P=\frac{1}{13} \times \left( \frac{0}{51} + \frac{4}{51} + \cdots \frac{48}{51}\right) = \frac{8}{17}$.</p>

<p>但是也可以换一个方法，把情况分为三种：你的牌大、相等、小于荷官的牌，此时$P(E_1) = P(E_3) = \frac{1}{2}(1-P(E_2)) = \frac{1}{2}(1-\frac{3}{51}) = \frac{8}{17}.$</p>

<h3 id="喝醉的乘客">喝醉的乘客</h3>

<p><strong>有100个乘客在排队上飞机，每个人都有自己的位置，但是第一个人喝多了，随便找个位置就坐了，假设其他人如果能坐自己的位置的话就会坐自己的，如果自己的位置被坐了就会随机坐一个，假如你是第100个登机的，请问你能坐在自己位置的概率是多少？</strong></p>

<p>只要有人坐在第一个位置上，后面的乘客都将坐在自己对应的位置上，因此实际上就是计算第一个位置比第100个位置先被坐下的概率，因为两个座位是同等对称的，所以就是50%.</p>

<h3 id="圆上的n个点">圆上的n个点</h3>

<p><strong>N个点随机扔在一个圆周上，它们能在同一个半圆内的概率是多少？</strong></p>

<p>$1,\cdots, i-1,i+1,\cdots, N$个点都在从第$i$个点开始顺时针的半圆上记为事件$E_i$，可以看出$E_1,\cdots,E_N$都是彼此互斥的，
因此$P(E) = P(\cup_{i=1}^N E_i) = \sum_{i=1}^N P(E_i) = \sum_{i=1}^N \frac{1}{2^{N-1}} = \frac{N}{2^{N-1}}.$</p>

<p>类似的如果弧长为$x$弧度的话概率就是$N\times x^{N-1}$.</p>

<h2 id="组合分析">组合分析</h2>

<h3 id="扑克牌">扑克牌</h3>

<p><strong>52张牌，每个人拿五张，请问拿到four-of-a-kind的概率是多少？拿到葫芦的概率是多少？双对的概率是多少？</strong></p>

<ol>
  <li>$P(E_1) = \frac{C_{13}^1 \times 48}{C_{52}^{5}}$</li>
  <li>$P(E_2) = \frac{C_{13}^1 \times C_4^3 \times C_{12}^1 \times C_4^2}{C_{52}^5}$</li>
  <li>$P(E_3) = \frac{C_{13}^2 \times C_4^2 \times C_4^2}{C_{52}^5}$</li>
</ol>

<h3 id="古怪的海盗ii">古怪的海盗II</h3>

<p><strong>有11个海盗，为了保护财宝，决定至少要大于等于6个人才能开锁，人数足够的任意小组都可以打开锁，每个锁可以有多把钥匙但每把钥匙只能开一个锁，请问最少要对财宝上多少个锁？每个海盗有几个钥匙？</strong></p>

<p>任意五个人都不能打开锁，那就要对每个五人组合都有一个特殊的打不开的锁，那就是${11 \choose 5 } = 462$个锁，每个锁有6把钥匙，并且都给独特的一个6人组，也就是说不能有一个六人组每个人都有两个锁的钥匙。因此每个海盗有$462 * 6 / 11 = 252$个钥匙。</p>

<h3 id="象棋比赛">象棋比赛</h3>

<p><strong>一个比赛有$2^n$个选手，实力排名从高到低，$1&gt;2&gt;\cdots&gt;2^n$，比赛实行淘汰制，每轮胜者才能进入下一轮，除决赛外每一轮的对手对局都是随机的，请问1、2名选手能在决赛遇见的概率是多少？</strong></p>

<p>记$E_i$为第$i$轮二人没有碰见，则
$P(E) = P(E_1)\times P(E_2|E_1) \times \cdots \times P(E_{n-1}|E_1E_2\ldots E_{n-2}) = 
\frac{2^n-2}{2^n-1} \times \frac{2^{n-1}-2}{2^{n-1}-1} \times \cdots \frac{2}{3} = \frac{2^{n-1}}{2^n-1}$</p>

<h3 id="申请信">申请信</h3>

<p><strong>你准备投五家公司，有五个信封，每个都对应一个独特的简历，但你的孩子随便将简历放进去了，请问五个简历都装错的概率是多少？</strong></p>

<p>记$E_i$为第$i$个简历装入正确的信封，因此
$P(\cup_{i=1}^5 E_i) = \sum_{i=1}^5P(E_i) - \sum_{i_1&lt;i_2}P(E_iE_j) + \cdots + (-1)^6P(E_1\ldots E_5)$</p>

<p>$P(E_{i_1}\ldots E_{i_k}) = \frac{(5-k)!}{5!} \Rightarrow \sum P(E_{i_1}\ldots E_{i_k}) = \frac{1}{k!}$</p>

<p>因此$P(\cup_{i=1}^5 E_i)= 1 - \frac{1}{2!} + \frac{1}{3!} - \frac{1}{4!} + \frac{1}{5!} = \frac{19}{30} \Rightarrow P(E) = \frac{11}{30}.$</p>

<h3 id="生日问题">生日问题</h3>

<p><strong>需要多少个人才能做到有两个人同一天生日的概率大于0.5?</strong></p>

<p>假设有$n$个人，那么没有两个人同一天生日的概率为$P(\overline{E}) = \frac{A_{365}^n}{365^n} &lt; \frac{1}{2}$,可计算得到$n$最少为23.
<strong>分母表示每个人都不相同，因此分子是排列数而不是组合数。类似的问题有n个球放入N个盒子里，恰好有n个盒子里面有球的概率即为$\frac{A_N^n}{N^n}$.</strong></p>

<h3 id="100位小数">100位小数</h3>

<p><strong>请问$(1+\sqrt{2})^{3000}$的第100位小数是多少？</strong></p>

<p>$(1+\sqrt{2})^{3000} + (1-\sqrt{2})^{3000} = 2\sum_{k=2j, 0\leq j\leq 2/n} {n \choose k}\sqrt{2}^{k}$始终为整数，然而$(1-\sqrt{2})^{3000}$远小于$10^{-100}$，因此第100位小数为9.</p>

<h3 id="以11结尾的整数的三次方">以11结尾的整数的三次方</h3>
<p><strong>$x$为1到$10^{12}$中间的一个整数，请问x的三次方以11结尾的概率是多少？</strong></p>

<p>$x = a+10b \Rightarrow x^3 = a^3 + 30a^2b + 300ab^2 + 1000b^3.$
$x^3$的末尾只由$a^3$决定，因此$a=1$，此时又要保证$3b$是1为结尾，那么$b$的末尾数字必须是7，也就是说$x$的末尾两位数必须是71，因此概率为0.01.</p>

<h3 id="抽签问题">抽签问题</h3>

<p><strong>52张牌有a张红牌b张黑牌，放回或不放回抽n张的话，恰好有k张红牌的概率是多少？</strong></p>

<ol>
  <li>不放回的话概率为$\frac{C_a^k C_b^{n-k}}{C_N^n}.$</li>
  <li>放回的话可以考虑为一个二项分布，试验成功即为抓到红牌，则概率为${n \choose k}p^k(1-p)^{n-k}, p = \frac{a}{N}, 1-p = \frac{b}{N}.$</li>
</ol>

<h3 id="抽签问题ii">抽签问题II</h3>

<p><strong>编号为1到n的球，a个红球b个白球，每次摸一个不放回，摸n次，求第k次摸到红球的概率。</strong></p>

<p>将每次摸的球做一个排列，视为一个样本点，那么概率为$\frac{a(n-1)!}{n!} = \frac{a}{n}.$</p>

<h2 id="条件分布和贝叶斯公式">条件分布和贝叶斯公式</h2>

<table>
  <tbody>
    <tr>
      <td><strong>全概率公式</strong>：对于两两互斥的事件${F_i}$，他们的并集是整个样本空间，那么有$$ P(E) = \sum_{i=1}^n P(E</td>
      <td>F_i)P(F_i).$$</td>
    </tr>
  </tbody>
</table>

<p><strong>A、B事件相互独立</strong> $\Leftrightarrow P(AB)=P(A)P(B) \rightarrow P(AB^c)=P(A)P(B^c).$</p>

<p><strong>ABC事件两两独立</strong> $\Leftrightarrow P(AB)=P(A)P(B), P(AC)=P(A)P(C), P(BC)=P(B)P(C).$</p>

<p><strong>ABC事件相互独立</strong> $\Leftrightarrow P(ABC)=P(A)P(B)P(C) +$ABC两两独立.</p>

<table>
  <tbody>
    <tr>
      <td><strong>贝叶斯公式</strong>：$P(F_j</td>
      <td>E) = \frac{P(E</td>
      <td>F_j)P(F_j)}{\sum_{i=1}^n P(E</td>
      <td>F_i)P(F_i)}.$</td>
    </tr>
  </tbody>
</table>

<h3 id="男女孩">男女孩</h3>

<p><strong>公司为每个有至少一个儿子的妈妈准备晚宴，有两个孩子的Jack女士被邀请参加，她有两个儿子的概率是多少？</strong></p>

<table>
  <tbody>
    <tr>
      <td>$P(A</td>
      <td>B) = \frac{P(AB)}{P(B)} = \frac{1/4}{3/4} = \frac{1}{3}.$</td>
    </tr>
  </tbody>
</table>

<p><strong>当你在路上看到Jack女士带着一个男孩在路上走，她有两个儿子的概率是多少？</strong></p>

<p>此时概率即为$\frac{1}{2}.$</p>

<p>这两个问题给的前提是不一样的，一个是至少有一个儿子，一个是其中一个是男孩。</p>

<h3 id="全是女孩的世界">全是女孩的世界？</h3>
<p><strong>在原始社会，每个夫妻都想有一个女儿，他们会一直要孩子直到生了一个女儿，他们就不再生孩子了，请问社会上女孩的比例最终会是多少？</strong></p>

<p>始终都会是50%，因为每生一个孩子是男是女的概率都是50%，这与夫妻行为无关。</p>

<h3 id="不公平的硬币">不公平的硬币</h3>

<p><strong>给你1000个硬币，有一个两边都是正面，你任意选一个硬币扔10次，每次都是正面向上，请问你这个硬币是不公平的硬币的概率是多少？</strong></p>

<p>记A为该硬币不公平，B为十次投掷均为正面向上，则有：
\(P(A|B) = \frac{P(B|A)P(A)}{P(B|A)P(A)+P(B|A^c)P(A^c)} 
\approx 0.5\)</p>

<h3 id="不公平硬币中寻找公平概率">不公平硬币中寻找公平概率</h3>

<p><strong>给你一个不公平硬币，正面朝上的概率是未知的，请问你可以用这个硬币得到50%概率的事件吗？</strong></p>

<p>投掷两次，先正后反记为输，先反后正记为赢，如果没出现这两种情况则重新再投掷两次。</p>

<h3 id="飞镖游戏">飞镖游戏</h3>

<p><strong>Jason扔两次飞镖，第二次比第一次偏离得多，请问第三次比第一次更远的概率为多少？</strong></p>

<p>三次从近到远记为A\B\C三个等级，枚举一下即可得到概率为$\frac{2}{3}$</p>

<p><strong>假如扔n次，后n-1次都比第一次远，那么他扔第n+1次比第一次也远的概率是多少？</strong></p>

<p>实际上就相当于n个人排列好了，第n+1个人随机站一个位置，他站到第一个位置的概率是多少，就是$\frac{n}{n+1}.$</p>

<h3 id="生日队列">生日队列</h3>

<p><strong>电影院管理说他会送排队的人中第一个生日与前面买过票的人生日一致的人一张票，请问你站在什么位置得到票的概率最高？</strong></p>

<p>p(n) = p(前n-1个人生日不同)*p(你的生日在前n-1个中) = $\frac{365\times\cdots\times (365-n+2)}{365^{n-1}}\times \frac{n-1}{365}.$ 求解不等式组$P(n)&gt;P(n-1), P(n) &gt; P(n+1)$可以得到$n=20.$</p>

<h3 id="骰子顺序">骰子顺序</h3>

<p><strong>你依次掷骰子三次，得到一个递增数列的概率是多少？</strong></p>

<table>
  <tbody>
    <tr>
      <td>当掷的三个数不同时，是一个递增数列的概率是$1/6$，这个与飞镖问题的道理一致，因此最终概率为$P(三个数不同)P(递增</td>
      <td>三个数不同) = (1\times \frac{5}{6} \times \frac{4}{6})\times \frac{1}{6} = \frac{5}{54}.$</td>
    </tr>
  </tbody>
</table>

<h3 id="monty-hall问题">Monty Hall问题</h3>

<p><strong>有三个门，其中一个是车，另外两个是羊，你现在选了一个门，Monty开了另外两个中有羊的一个，现在他给你机会换一个门，你要换吗，换门后赢的概率是多少？</strong></p>

<p>记A为不换门赢，C为主持人打开一个有羊的门。<strong>注意P(C)==1！</strong>
$P(A|C) = \frac{P(C|A)P(A)}{P(C|A)P(A)+P(C|A^c)P(A^c)} = \frac{1/3}{1/3+2/3} = \frac{1}{3}.$也就是说不换门赢当且仅当你最初选的就是有车的门，概率为$\frac{1}{3}$，那么换门赢的概率则为$\frac{2}{3}.$</p>

<h3 id="amoeba人口数">Amoeba人口数</h3>

<p><strong>池塘里有一个amoeba，每分钟它可能死，可能不变，可能分裂成两个或者三个，每个情况概率相同，请问最后amoeba死光的概率是多少？</strong></p>

<table>
  <tbody>
    <tr>
      <td>$P(E) = P(E</td>
      <td>F_1)P(F_1) + \cdots + P(E</td>
      <td>F_4)P(F_4)$</td>
    </tr>
    <tr>
      <td>1. 对于事件1，$P(E</td>
      <td>F_1) = 1.$</td>
      <td> </td>
    </tr>
    <tr>
      <td>2. 对于事件2，$P(E</td>
      <td>F_2) = P(E).$</td>
      <td> </td>
    </tr>
    <tr>
      <td>3. 对于事件3，$P(E</td>
      <td>F_3) = P(E)^2.$</td>
      <td> </td>
    </tr>
    <tr>
      <td>4. 对于事件4，$P(E</td>
      <td>F_4) = P(E)^3.$</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>因此$p = \frac{1}{4}(1+p+p^2+p^3) \Rightarrow p = \sqrt{2}-1.$</p>

<h3 id="盒子中的蜡烛">盒子中的蜡烛</h3>

<p><strong>盒子中有10个红蜡烛，20个蓝色，30个绿色的，你一个一个拿出来，请问当你拿出所有红蜡烛之后里面还至少有一个蓝色和一个绿色蜡烛的概率是多少？</strong></p>

<p>记最后一个红色、蓝色、绿色是在$T_r,T_b,T_g$次被拿出来，那么
$P(E) = P(T_r&lt;T_b \cap T_r&lt;T_g) = P(T_r&lt;T_b&lt;T_g) + P(T_r&lt;T_g&lt;T_b) = P(T_r&lt;T_b|T_g=60)P(T_g=60) + P(T_r&lt;T_g|T_b=60)P(T_b=60) = \frac{30}{60}\times\frac{20}{30} + \frac{20}{60}\times\frac{30}{40} = \frac{7}{12}.$</p>

<h3 id="投掷硬币游戏">投掷硬币游戏</h3>

<p><strong>AB轮流掷硬币，假如背面朝上的下一次为正面朝上则游戏结束，掷出背面的人赢，请问A赢的概率为多少？</strong></p>

<p>$P(A) = \frac{1}{2}P(A|H) + \frac{1}{2}P(A|T)$
$P(A|H) = \frac{1}{2} + \frac{1}{2}(1-P(A|H)) \Rightarrow P(A|H) = \frac{1}{3}.$
$P(A|T) = P(B) = 1-P(A)$
因此$P(A) = \frac{1}{6}+\frac{1}{2}(1-P(A)) \Rightarrow P(A)=\frac{4}{9}.$</p>

<h3 id="俄罗斯转盘">俄罗斯转盘</h3>

<p><strong>一发子弹装在容量为6的手枪内，两个人轮流开枪，你可以选择第一个来还是第二个来，你该怎么选择？</strong></p>

<p>注意，当游戏开始，谁死就已经固定了，如果子弹在1、3、5管内则第一个人死，2、4、6则第二个人死，因此概率就是$\frac{1}{2}$.</p>

<p><strong>如果每次开枪都重新旋转枪管呢？</strong></p>

<p>设第一个人输的概率为$p$，则$p=\frac{1}{6} + \frac{5}{6}(1-p) \Rightarrow p = \frac{6}{11}.$所以应该选第二个开枪。</p>

<p><strong>如果装了两发子弹，对手第一个开枪并且没事，给你选择是否转动枪管再开枪，你该怎么选择？</strong></p>

<p>转了的话这轮活的那就是$\frac{2}{3}$，不转的话这轮活的概率是$\frac{2}{5}.$因此需要转。</p>

<p><strong>如果两个子弹被装在了连续的两个位置，对手第一个开枪并且没事，给你选择是否转动枪管再开枪，你该怎么选择？</strong></p>

<p>转的话活的概率还是$\frac{2}{3}$，不转的话，活的概率为$\frac{3}{4}$，因此不要转。</p>

<h3 id="ace">Ace</h3>
<p><strong>52张牌发给4个人，每人13张，他们每个人都有一个A的概率是多少？</strong></p>

<p>给4个人发牌总共有$\frac{52!}{13!13!13!13!}$种情况，如果每人都有一个A，可以先考虑先发A，共有$4!$种可能，再发剩余48张牌，共有$\frac{48!}{12!12!12!12!}$种可能，因此概率为$\frac{52}{52}\times \frac{39}{51} \times \frac{26}{50} \times \frac{13}{49}$.</p>

<p>如果用条件概率的话逻辑会更清晰，第一张A肯定有$\frac{52}{52}$的概率属于一个人，第二张A在另一个人手里的概率为$\frac{39}{51}$，以此类推，即可得到最终概率。</p>

<h3 id="赌博问题">赌博问题</h3>

<p><strong>一个赌博的人初始有$i$元，每一轮游戏，他有p的概率赢1元，有q=1-p的概率输1元，他要么有了N元或者输光才会停止，请问他最后拥有N元的概率为多少？</strong></p>

<p>设$P_i$为初始为$i$元时赢到N的概率，那么有</p>

\[P_i = pP_{i+1}+qP_{i-1} \Rightarrow P_{i+1}-P_i = \frac{q}{p}(P_i-P_{i-1}) = \cdots = (\frac{q}{p})^i(P_1-P_0)\]

<p>我们有$P_0=0,P_N=1$,我们可以开始计算
$P_1 = pP_2 + qP_0 \Rightarrow P_2=(1+\frac{q}{p})P_1$
$P_3 = (1+\frac{q}{p} + (\frac{q}{p})^2)P_1$
以此类推，
$P_N = 1 = [1+\frac{q}{p}+\cdots + (\frac{q}{p})^{N-1}]P_1 =\begin{cases}
    \frac{1-(q/p)^N}{1-q/p}P_1,\ q/p\neq 1 <br />
    NP_1,\ q/p = 1
\end{cases}$
可以求出$P_1$再求出$P_i$.</p>

<h3 id="篮球分数">篮球分数</h3>

<p><strong>运动员投100个球，投进得一分，她又中了第一个，第二个没投中，后续她的命中率是她过去投中的比例，那么她刚好得到50分的概率为多少？</strong></p>

<p>令$P_{n,k}$为投n个球后得到k分的概率，可以观察到$P_{3,1} = \frac{1}{2}, P_{3,2}=\frac{1}{2}.$</p>

\[\begin{cases}
    P_{4,1} = P((4,1)|(3,1))P_{3,1} + P((4,1)|(3,2))P_{3,2} = \frac{1}{3} \\
    P_{4,2} = P((4,2)|(3,1))P_{3,1} + P((4,2)|(3,2))P_{3,2} = \frac{1}{3} \\ 
    P_{4,3} = P((4,3)|(3,1))P_{3,1} + P((4,3)|(3,2))P_{3,2} = \frac{1}{3} 
\end{cases}\]

<p>因此可以用数学归纳法证明$P_{n,k}=\frac{1}{n-1}\Rightarrow P_{100,50} = \frac{1}{99}.$</p>

<h3 id="路上的车">路上的车</h3>

<p>如果在任意20分钟时间段观察到高速上至少有一辆车的概率为$\frac{609}{625}$，那么在任意5分钟时间段观察到至少有一辆车的概率为多少？假设在20分钟内的任意时间观察到一辆车的概率都是一致的。</p>

<p>$1 - \frac{609}{625} = (1-p)^4 \Rightarrow p=\frac{3}{5}.$</p>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="量化绿皮书" /><summary type="html"><![CDATA[事件及其概率]]></summary></entry></feed>