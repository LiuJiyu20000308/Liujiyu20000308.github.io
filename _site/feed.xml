<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2024-08-08T09:28:24+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Liujiyu’s blog</title><subtitle>learn &amp; record</subtitle><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><entry><title type="html">Leetcode记录：KMP算法</title><link href="http://localhost:4000/2024/08/07/KMP/" rel="alternate" type="text/html" title="Leetcode记录：KMP算法" /><published>2024-08-07T14:00:00+08:00</published><updated>2024-08-07T14:00:00+08:00</updated><id>http://localhost:4000/2024/08/07/KMP</id><content type="html" xml:base="http://localhost:4000/2024/08/07/KMP/"><![CDATA[<h3 id="找出字符串中第一个匹配的下标">找出字符串中第一个匹配的下标</h3>
<p>Leetcode 28. 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。</p>

<p>这道题可以暴力枚举：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">strStr</span><span class="p">(</span><span class="n">string</span> <span class="n">haystack</span><span class="p">,</span> <span class="n">string</span> <span class="n">needle</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">hLen</span> <span class="o">=</span> <span class="n">haystack</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">nLen</span> <span class="o">=</span> <span class="n">needle</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">hLen</span> <span class="o">&lt;</span> <span class="n">nLen</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">hLen</span> <span class="o">-</span> <span class="n">nLen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">start</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">haystack</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">==</span> <span class="n">needle</span><span class="p">[</span><span class="mi">0</span><span class="p">]){</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nLen</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">start</span><span class="p">]</span> <span class="o">!=</span> <span class="n">needle</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">nLen</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">start</span><span class="p">]</span> <span class="o">==</span> <span class="n">needle</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">return</span> <span class="n">start</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>但是复杂度为$O(mn),m=hLen,n=nLen$.</p>

<h2 id="kmp算法">KMP算法</h2>

<p>KMP的经典思想就是:<strong>当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。</strong> 所以如何记录已经匹配的文本内容，是KMP的重点，也是后续要讲的next数组肩负的重任。
next数组就是一个前缀表（prefix table）。前缀表是用来<strong>回退</strong>的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</p>

<h3 id="前缀表">前缀表</h3>

<p>为了清楚地了解前缀表的来历，我们来举一个例子：要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。</p>

<div align="center"> <img src="/pic/DS/KMP1.gif" width="400" /> </div>

<p>可以看出，文本串中第六个字符b和模式串的第六个字符f不匹配了。如果暴力匹配，发现不匹配，此时就要从头匹配了。
但如果使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中第三个字符b继续开始匹配。
此时就要问了<strong>前缀表是如何记录的呢</strong>？首先要知道前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。</p>

<p>那么什么是前缀表：<strong>记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。</strong> 其中，字符串的前缀是指<strong>不包含最后一个字符的所有以第一个字符开头的连续子串</strong>。后缀是指<strong>不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。对于字符串”abcab”，它有”a” “ab” “abc” “abca” 这样四个前缀，有”b” “ab” “cab” “bcab” 这样四个后缀。</p>

<p>回顾一下，刚刚匹配的过程在下标5的地方遇到不匹配，模式串是指向f，然后就找到了下标2，指向b，继续匹配：如图：</p>

<div align="center"> <img src="/pic/DS/KMP2.png" width="300" /> </div>

<p><strong>下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。</strong>
所以前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力。</p>

<h3 id="如何计算前缀表">如何计算前缀表</h3>
<p>接下来就要说一说怎么计算前缀表。</p>
<ol>
  <li>长度为前1个字符的子串a，最长相同前后缀的长度为0。（注意字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串；后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。）</li>
  <li>长度为前2个字符的子串aa，最长相同前后缀的长度为1。</li>
  <li>长度为前3个字符的子串aab，最长相同前后缀的长度为0。</li>
  <li>以此类推： 长度为前4个字符的子串aaba，最长相同前后缀的长度为1。 长度为前5个字符的子串aabaa，最长相同前后缀的长度为2。 长度为前6个字符的子串aabaaf，最长相同前后缀的长度为0。</li>
</ol>

<p>那么把求得的最长相同前后缀的长度就是对应前缀表的元素，如图：</p>
<div align="center"> <img src="/pic/DS/KMP3.png" width="400" /> </div>

<p>可以看出模式串与前缀表对应位置的数字表示的就是：下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。
再来看一下如何利用 前缀表找到 当字符不匹配的时候应该指针应该移动的位置。如动画所示：</p>
<div align="center"> <img src="/pic/DS/KMP4.gif" width="400" /> </div>

<p>找到的不匹配的位置， 那么此时我们要看它的前一个字符的前缀表的数值是多少。前一个字符的前缀表的数值是2， 所以把下标移动到下标2的位置继续比配。最后就在文本串中找到了和模式串匹配的子串了。</p>

<h3 id="前缀表与next数组">前缀表与next数组</h3>

<p>很多KMP算法的实现都是使用next数组来做回退操作，那么next数组与前缀表有什么关系呢？next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。</p>

<p>其实这并不涉及到KMP的原理，而是具体实现，next数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。</p>

<h3 id="使用next数组来匹配">使用next数组来匹配</h3>

<p>以下我们以前缀表统一减一之后的next数组来做演示。
有了next数组，就可以根据next数组来 匹配文本串s，和模式串t了。注意next数组是新前缀表（旧前缀表统一减一了）。</p>

<p>匹配过程动画如下：</p>
<div align="center"> <img src="/pic/DS/KMP5.gif" width="400" /> </div>

<h3 id="构造next数组">构造next数组</h3>

<p><strong>next[i] 等于满足下述要求的 x 的最大值：s[0:i] 具有长度为 x+1 的完全相同的前缀和后缀。</strong>
构造next数组其实就是计算模式串s，前缀表的过程。 主要有如下三步：</p>
<ol>
  <li>初始化
 定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。然后还要对next数组进行初始化赋值：
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
 <span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>处理前后缀不相同的情况
 如果 s[i] 与 s[j+1] 不相同，也就是遇到前后缀末尾不相同的情况，就要向前回退，找<code class="language-plaintext highlighter-rouge">s.substr(0,i)</code>更小长度的相同前后缀。因为
 <code class="language-plaintext highlighter-rouge">s.substr(0,j+1) == substr(i-j-1,j+1)</code>，
 <code class="language-plaintext highlighter-rouge">s.substr(0,next[j]+1) = s.substr(j-next[j],next[j]+1)</code>
 <code class="language-plaintext highlighter-rouge">=s.substr(i-next[j]-1,next[j]+1)</code>
 所以，s[i] 与 s[j+1] 不相同，就要找 j+1前一个元素在next数组里的值（就是next[j]）。</li>
  <li>处理前后缀相同的情况
 如果 s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。</li>
</ol>

<p>总体程序如下:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">getNext</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">next</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 注意i从1开始</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// 前后缀不相同了</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">j</span><span class="p">];</span> <span class="c1">// 向前回退</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// 找到相同的前后缀</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="c1">// 将j（前缀的长度）赋给next[i]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="使用next数组来做匹配">使用next数组来做匹配</h3>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 因为next数组里记录的起始位置为-1</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 注意i就从0开始</span>
    <span class="k">while</span><span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">t</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// 不匹配</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">j</span><span class="p">];</span> <span class="c1">// j 寻找之前匹配的位置</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// 匹配，j和i同时向后移动</span>
        <span class="n">j</span><span class="o">++</span><span class="p">;</span> <span class="c1">// i的增加在for循环里</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">// 文本串s里出现了模式串t</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">t</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>总体代码如下：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">getNext</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">next</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 注意i从1开始</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// 前后缀不相同了</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">j</span><span class="p">];</span> <span class="c1">// 向前回退</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// 找到相同的前后缀</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="c1">// 将j（前缀的长度）赋给next[i]</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">strStr</span><span class="p">(</span><span class="n">string</span> <span class="n">haystack</span><span class="p">,</span> <span class="n">string</span> <span class="n">needle</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">needle</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">(</span><span class="n">needle</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">getNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">needle</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// // 因为next数组里记录的起始位置为-1</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">haystack</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 注意i就从0开始</span>
        <span class="k">while</span><span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">needle</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// 不匹配</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">j</span><span class="p">];</span> <span class="c1">// j 寻找之前匹配的位置</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">haystack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">needle</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// 匹配，j和i同时向后移动</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span> <span class="c1">// i的增加在for循环里</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="p">(</span><span class="n">needle</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">// 文本串s里出现了模式串t</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">needle</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="重复的子字符串">重复的子字符串</h2>
<p>Leetcode 459. 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。</p>

<p>除了暴力枚举之外还有一种方法：我们将两个 s 连在一起，并移除第一个和最后一个字符。如果 s 是该字符串的子串，那么 s 就满足题目要求。</p>

<p><strong>证明：</strong>
如果长度为 $n$ 的字符串 <code class="language-plaintext highlighter-rouge">s</code> 是字符串 <code class="language-plaintext highlighter-rouge">t=s+s</code> 的子串，并且 <code class="language-plaintext highlighter-rouge">s</code> 在 <code class="language-plaintext highlighter-rouge">t</code> 中的起始位置不为 $0$ 或 $n$，那么 <code class="language-plaintext highlighter-rouge">s</code> 就满足题目的要求。证明过程如下：</p>

<p>我们设 <code class="language-plaintext highlighter-rouge">s</code> 在 <code class="language-plaintext highlighter-rouge">t</code> 中的起始位置为 $i\in(0,n)$。也就是说，<code class="language-plaintext highlighter-rouge">t</code> 中从位置 $i$ 开始的 $n$ 个连续的字符，恰好就是字符串<code class="language-plaintext highlighter-rouge">s</code>。那么我们有：</p>

\[s[0:n−1]=t[i:n+i−1].\]

<p>由于 <code class="language-plaintext highlighter-rouge">t</code> 是由两个 <code class="language-plaintext highlighter-rouge">s</code> 拼接而成的，我们可以将 $t[i:n+i−1]$ 分成位置 $n−1$ 左侧和右侧两部分：</p>

\[s[0:n−i−1]=t[i:n−1],\]

\[s[n−i:n−1]=t[n:n+i−1]=t[0:i−1]\]

<p>每一部分都可以对应回 <code class="language-plaintext highlighter-rouge">s</code>：</p>

\[s[0:n−i−1]=s[i:n−1],\]

\[s[n−i:n−1]=s[0:i−1]\]

<p>这说明，s 是一个 <strong>可旋转</strong> 的字符串：将 <code class="language-plaintext highlighter-rouge">s</code> 的前 $i$ 个字符保持顺序，移动到 <code class="language-plaintext highlighter-rouge">s</code> 的末尾，得到的新字符串与 <code class="language-plaintext highlighter-rouge">s</code> 相同。也就是说，在模 $n$ 的意义下，$s[j]=s[j+i]$ 对于任意的 $j$ 恒成立。
如果我们不断地连写这个等式：</p>

<p>\(s[j]=s[j+i]=s[j+2i]=s[j+3i]=\ldots\)
那么所有满足 $j_0 =j+ki$ 的位置 $j_0$ 都有 $s[j]=s[j_0]$，$j$ 和 $j_0$ 在模 $i$ 的意义下等价。由于我们已经在模 $n$ 的意义下讨论这个问题，因此 $j$ 和 $j_0$ 在模 $gcd(n,i)$ 的意义下等价，其中 gcd 表示最大公约数。也就是说，字符串 <code class="language-plaintext highlighter-rouge">s</code> 中的两个位置如果在模 $gcd(n,i)$ 的意义下等价，那么它们对应的字符必然是相同的。</p>

<p>由于 $gcd(n,i)$ 一定是 $n$ 的约数，那么字符串 <code class="language-plaintext highlighter-rouge">s</code> 一定可以由其长度为 $gcd(n,i)$ 的前缀重复构成。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">repeatedSubstringPattern</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">s</span><span class="p">).</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>我们也可以采用KMP算法来替换库函数:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">kmp</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">query</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">pattern</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">query</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">pattern</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">fail</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">fail</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">pattern</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pattern</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">fail</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pattern</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">pattern</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">fail</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">match</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">match</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">pattern</span><span class="p">[</span><span class="n">match</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">query</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">match</span> <span class="o">=</span> <span class="n">fail</span><span class="p">[</span><span class="n">match</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pattern</span><span class="p">[</span><span class="n">match</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">query</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="o">++</span><span class="n">match</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">match</span> <span class="o">==</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">repeatedSubstringPattern</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">kmp</span><span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>在正确性证明部分，如果我们设 $i$ 为最小的起始位置，那么一定有 $gcd(n,i)=i$，即 $n$ 是 $i$ 的倍数。这说明字符串 <code class="language-plaintext highlighter-rouge">s</code> 是由长度为 $i$ 的前缀重复构成；</p>

<p>由于 <code class="language-plaintext highlighter-rouge">fail[n−1]</code> 表示 <code class="language-plaintext highlighter-rouge">s</code> 具有长度为<code class="language-plaintext highlighter-rouge">fail[n−1]+1</code>的完全相同的（且最长的）前缀和后缀。那么对于满足题目要求的字符串，一定有 <code class="language-plaintext highlighter-rouge">fail[n−1]=n−i−1</code>，即 <code class="language-plaintext highlighter-rouge">i=n−fail[n−1]−1</code>；
对于不满足题目要求的字符串，$n$ 一定不是 <code class="language-plaintext highlighter-rouge">n−fail[n−1]−1</code> 的倍数。上述所有的结论都可以很容易地使用反证法证出。因此，我们在预处理出 <code class="language-plaintext highlighter-rouge">fail</code> 数组后，只需要判断 $n$ 是否为 <code class="language-plaintext highlighter-rouge">n−fail[n−1]−1</code> 的倍数即可。</p>

<p>更直观的图如下：</p>

<div align="center"> <img src="/pic/DS/Leetcode459.png" width="400" /> </div>

<p>也就是说只要最长相等前后缀有重叠，并且总长度是后缀不包含的子串长度的倍数，就满足题目要求。</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">getNext</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">next</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">){</span>
    <span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">while</span><span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="n">repeatedSubstringPattern</span> <span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">next</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()];</span>
    <span class="n">getNext</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">%</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="p">(</span><span class="n">next</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="数据结构与算法" /><summary type="html"><![CDATA[找出字符串中第一个匹配的下标 Leetcode 28. 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。]]></summary></entry><entry><title type="html">Leetcode记录：字符串例题</title><link href="http://localhost:4000/2024/08/06/DS/" rel="alternate" type="text/html" title="Leetcode记录：字符串例题" /><published>2024-08-06T14:00:00+08:00</published><updated>2024-08-06T14:00:00+08:00</updated><id>http://localhost:4000/2024/08/06/DS</id><content type="html" xml:base="http://localhost:4000/2024/08/06/DS/"><![CDATA[<h3 id="反转字符串">反转字符串</h3>

<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">reverseString</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">;</span> <span class="o">++</span><span class="n">left</span><span class="p">,</span> <span class="o">--</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="反转字符串-1">反转字符串</h3>

<p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。
如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="nf">reverseStr</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">reverse</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">min</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="替换数字">替换数字</h3>

<p>给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">sOldIndex</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 统计数字的个数</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="sc">'0'</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">'9'</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">count</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 扩充字符串s的大小，也就是将每个数字替换成"number"之后的大小</span>
        <span class="n">s</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">count</span> <span class="o">*</span> <span class="mi">5</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">sNewIndex</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="c1">// 从后往前将数字替换为"number"</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">sOldIndex</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">sOldIndex</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="sc">'0'</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">sOldIndex</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">'9'</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">s</span><span class="p">[</span><span class="n">sNewIndex</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'r'</span><span class="p">;</span>
                <span class="n">s</span><span class="p">[</span><span class="n">sNewIndex</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'e'</span><span class="p">;</span>
                <span class="n">s</span><span class="p">[</span><span class="n">sNewIndex</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'b'</span><span class="p">;</span>
                <span class="n">s</span><span class="p">[</span><span class="n">sNewIndex</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'m'</span><span class="p">;</span>
                <span class="n">s</span><span class="p">[</span><span class="n">sNewIndex</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'u'</span><span class="p">;</span>
                <span class="n">s</span><span class="p">[</span><span class="n">sNewIndex</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'n'</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">s</span><span class="p">[</span><span class="n">sNewIndex</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">sOldIndex</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="n">sOldIndex</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>       
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="反转字符串中的字母">反转字符串中的字母</h3>

<p>Leetcode 151. 给你一个字符串 s ，请你反转字符串中 单词 的顺序。</p>

<p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。返回单词顺序颠倒且单词之间用单个空格连接的结果字符串。</p>

<p>注意：输入字符串s中<strong>可能会存在前导空格、尾随空格或者单词间的多个空格。</strong> 返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>

<p>一种最直观的方法是双指针法，从后向前依次寻找每个单词的首和尾：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="nf">reverseWords</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 使用双指针</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">res</span><span class="p">;</span>
    <span class="c1">// 除去尾部空格</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="sc">' '</span> <span class="o">&amp;&amp;</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">m</span><span class="o">--</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span> <span class="c1">// n是另一个指针</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">' '</span><span class="p">)</span> <span class="n">m</span><span class="o">--</span><span class="p">;</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="s">" "</span><span class="p">;</span> <span class="c1">// 获取单词并加上空格</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="sc">' '</span><span class="p">)</span> <span class="n">m</span><span class="o">--</span><span class="p">;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">res</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 忽略最后一位的空格</span>
<span class="p">}</span>
</code></pre></div></div>

<p>也可以原地进行操作，首先先将字符串翻转，再去从头开始填充每个单词：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="nf">reverseWords</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 反转整个字符串</span>
    <span class="n">reverse</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">' '</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 填一个空白字符然后将idx移动到下一个单词的开头位置</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">s</span><span class="p">[</span><span class="n">idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">' '</span><span class="p">;</span>

            <span class="c1">// 循环遍历至单词的末尾</span>
            <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">' '</span><span class="p">)</span> 
                <span class="n">s</span><span class="p">[</span><span class="n">idx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">end</span><span class="o">++</span><span class="p">];</span>
            <span class="c1">// 此时idx和end都指向单词的末尾的后一个位置</span>
            <span class="c1">// 反转整个单词</span>
            <span class="n">reverse</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">idx</span> <span class="o">-</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">),</span> <span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">idx</span><span class="p">);</span>

            <span class="c1">// 更新start，去找下一个单词</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">s</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">idx</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>更直观的写法为：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">){</span> <span class="c1">//翻转，区间写法：左闭右闭 []</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">removeExtraSpaces</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span><span class="c1">//去除所有空格并在相邻单词之间添加空格, 快慢指针。</span>
        <span class="kt">int</span> <span class="n">slow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">//整体思想参考https://programmercarl.com/0027.移除元素.html</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">' '</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//遇到非空格就处理，即删除所有空格。</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">s</span><span class="p">[</span><span class="n">slow</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">' '</span><span class="p">;</span> <span class="c1">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">' '</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//补上该单词，遇到空格说明单词结束。</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">slow</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">s</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">slow</span><span class="p">);</span> <span class="c1">//slow的大小即为去除多余空格后的大小。</span>
    <span class="p">}</span>

    <span class="n">string</span> <span class="n">reverseWords</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">removeExtraSpaces</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="c1">//去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。</span>
        <span class="n">reverse</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//removeExtraSpaces后保证第一个单词的开始下标一定是0。</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">' '</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//到达空格或者串尾，说明一个单词结束。进行翻转。</span>
                <span class="n">reverse</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">//翻转，注意是左闭右闭 []的翻转。</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//更新下一个单词的开始下标start</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>还有一种办法是利用双端队列，由于双端队列支持从队列头部插入的方法，因此我们可以沿着字符串一个一个单词处理，然后将单词压入队列的头部，再将队列转成字符串即可。</p>

<p>这里用的是<code class="language-plaintext highlighter-rouge">std::deque</code>，是一个双端队列，支持<code class="language-plaintext highlighter-rouge">push_back,push_front,pop_back,pop_front</code>.</p>

<p><code class="language-plaintext highlighter-rouge">queue</code>是FIFO，<code class="language-plaintext highlighter-rouge">stack</code>是LIFO,它们只支持<code class="language-plaintext highlighter-rouge">push,pop</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="nf">reverseWords</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">// 去掉字符串开头的空白字符</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">==</span> <span class="sc">' '</span><span class="p">)</span> <span class="o">++</span><span class="n">left</span><span class="p">;</span>

    <span class="c1">// 去掉字符串末尾的空白字符</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">==</span> <span class="sc">' '</span><span class="p">)</span> <span class="o">--</span><span class="n">right</span><span class="p">;</span>

    <span class="n">deque</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">word</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">' '</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 将单词 push 到队列的头部</span>
            <span class="n">d</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">word</span><span class="p">));</span>
            <span class="n">word</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="sc">' '</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">word</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="o">++</span><span class="n">left</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">d</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">word</span><span class="p">));</span>
    
    <span class="n">string</span> <span class="n">ans</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">ans</span> <span class="o">+=</span> <span class="n">d</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">d</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="n">ans</span> <span class="o">+=</span> <span class="sc">' '</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="右旋字符串">右旋字符串</h3>

<p>字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。要求不额外使用空间。</p>

<p>进行三次翻转即可：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span><span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="c1">//获取长度</span>

    <span class="n">reverse</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// 整体反转</span>
    <span class="n">reverse</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span> <span class="c1">// 先反转前一段，长度n</span>
    <span class="n">reverse</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// 再反转后一段</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></div></div>
<p><strong>左旋转和右旋转的思路是一样的。</strong></p>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="数据结构与算法" /><summary type="html"><![CDATA[反转字符串]]></summary></entry><entry><title type="html">Leetcode记录：哈希表例题</title><link href="http://localhost:4000/2024/08/04/DS/" rel="alternate" type="text/html" title="Leetcode记录：哈希表例题" /><published>2024-08-04T14:00:00+08:00</published><updated>2024-08-04T14:00:00+08:00</updated><id>http://localhost:4000/2024/08/04/DS</id><content type="html" xml:base="http://localhost:4000/2024/08/04/DS/"><![CDATA[<h3 id="续哈希表例题">续哈希表例题</h3>

<h4 id="四数之和-i">四数之和 I</h4>
<p>Leetcode 454. 给你四个整数数组 <code class="language-plaintext highlighter-rouge">nums1</code>,<code class="language-plaintext highlighter-rouge">nums2</code>,<code class="language-plaintext highlighter-rouge">nums3</code> 和 <code class="language-plaintext highlighter-rouge">nums4</code> ，数组长度都是 <code class="language-plaintext highlighter-rouge">n</code> ，请你计算有多少个元组 <code class="language-plaintext highlighter-rouge">(i, j, k, l)</code> 能满足：</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">0 &lt;= i, j, k, l &lt; n</code></li>
  <li><code class="language-plaintext highlighter-rouge">nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li>
</ol>

<p>可以将四个数组分成两部分，A 和 B 为一组，C 和 D 为另外一组。
对于 A 和 B，我们使用二重循环对它们进行遍历，得到所有 A[i]+B[j] 的值并存入哈希映射中。对于哈希映射中的每个键值对，每个键表示一种 A[i]+B[j]，对应的值为 A[i]+B[j] 出现的次数。
对于 C 和 D，我们同样使用二重循环对它们进行遍历。当遍历到 C[k]+D[l] 时，如果 −(C[k]+D[l]) 出现在哈希映射中，那么将 −(C[k]+D[l]) 对应的值累加进答案中。最终即可得到满足 A[i]+B[j]+C[k]+D[l]=0 的四元组数目:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">fourSumCount</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">B</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">C</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">D</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">countAB</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="o">:</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">:</span> <span class="n">B</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">++</span><span class="n">countAB</span><span class="p">[</span><span class="n">u</span> <span class="o">+</span> <span class="n">v</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="o">:</span> <span class="n">C</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">:</span> <span class="n">D</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">countAB</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="o">-</span><span class="n">u</span> <span class="o">-</span> <span class="n">v</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">ans</span> <span class="o">+=</span> <span class="n">countAB</span><span class="p">[</span><span class="o">-</span><span class="n">u</span> <span class="o">-</span> <span class="n">v</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>如果是要求不重复的话，利用哈希表将会很困难：</p>

<h4 id="三数之和">三数之和</h4>
<p>Leetcode 15. 给你一个整数数组 <code class="language-plaintext highlighter-rouge">nums</code> ，判断是否存在三元组 <code class="language-plaintext highlighter-rouge">[nums[i], nums[j], nums[k]]</code> 满足 <code class="language-plaintext highlighter-rouge">i != j、i != k</code> 且 <code class="language-plaintext highlighter-rouge">j != k</code> ，同时还满足 <code class="language-plaintext highlighter-rouge">nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code class="language-plaintext highlighter-rouge">0</code> 且<strong>不重复</strong>的三元组.</p>

<p>「不重复」的本质是需要保证：</p>
<ol>
  <li>第二重循环枚举到的元素不小于当前第一重循环枚举到的元素；</li>
  <li>第三重循环枚举到的元素不小于当前第二重循环枚举到的元素。</li>
</ol>

<p>也就是说，我们枚举的三元组 <code class="language-plaintext highlighter-rouge">(a,b,c)</code> 满足 <code class="language-plaintext highlighter-rouge">a≤b≤c</code>，保证了只有 <code class="language-plaintext highlighter-rouge">(a,b,c)</code> 这个顺序会被枚举到，而 <code class="language-plaintext highlighter-rouge">(b,a,c)、(c,b,a)</code> 等等这些不会，这样就减少了重复。要实现这一点，我们可以将数组中的元素从小到大进行排序，随后使用普通的三重循环就可以满足上面的要求。
同时，对于每一重循环而言，相邻两次枚举的元素不能相同，否则也会造成重复。</p>

<p>如果我们固定了前两重循环枚举到的元素 a 和 b，那么只有唯一的 c 满足 a+b+c=0。当第二重循环往后枚举一个元素 b’时，由于 b’&gt;b，那么满足 a+b’+c‘=0 的 c’一定有 c’&lt; c，即 c’在数组中一定出现在 c 的左侧。也就是说，我们可以从小到大枚举 b，同时从大到小枚举 c，也就是<strong>双指针</strong>的思想，这样就将三重循环降低为二重循环了。</p>

<p><strong>在代码实现中一定要注意需要在哪里去重，否则可能会出现一些算例不会ac的情况。</strong></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">threeSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">!=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
                <span class="n">left</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
                <span class="n">right</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
                <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">],</span><span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]});</span>
                <span class="n">left</span><span class="o">++</span><span class="p">;</span>
                <span class="k">while</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span>
                    <span class="n">left</span><span class="o">++</span><span class="p">;</span>
                <span class="n">right</span><span class="o">--</span><span class="p">;</span>
                <span class="k">while</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">&gt;</span> <span class="n">left</span><span class="p">)</span>
                    <span class="n">right</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="四数之和">四数之和</h4>

<p>给你一个由 n 个整数组成的数组 <code class="language-plaintext highlighter-rouge">nums</code> ，和一个目标值 <code class="language-plaintext highlighter-rouge">target</code> 。请你找出并返回满足下述全部条件且不重复的四元组 <code class="language-plaintext highlighter-rouge">[nums[a], nums[b], nums[c], nums[d]]</code>（若两个四元组元素一一对应，则认为两个四元组重复）：</p>

<ol>
  <li>0 &lt;= a, b, c, d &lt; n</li>
  <li>a、b、c 和 d 互不相同</li>
  <li>nums[a] + nums[b] + nums[c] + nums[d] == target</li>
</ol>

<p>求解思路和三数之和一模一样：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">fourSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">)</span> 
        <span class="k">return</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">{};</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">){</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">&gt;</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="k">while</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">){</span>
                <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
                <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
                <span class="k">if</span><span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="n">target</span><span class="p">)</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="k">if</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="o">+</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span>
                    <span class="n">left</span><span class="o">++</span><span class="p">;</span>
                <span class="k">else</span> <span class="k">if</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="o">+</span><span class="n">d</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span>
                    <span class="n">right</span><span class="o">--</span><span class="p">;</span>
                <span class="k">else</span><span class="p">{</span>
                    <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">});</span>
                    <span class="n">right</span><span class="o">--</span><span class="p">;</span>
                    <span class="n">left</span><span class="o">++</span><span class="p">;</span>
                    <span class="k">while</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">right</span><span class="o">--</span><span class="p">;</span>
                    <span class="k">while</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">left</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="数据结构与算法" /><summary type="html"><![CDATA[续哈希表例题]]></summary></entry><entry><title type="html">Leetcode记录：哈希表</title><link href="http://localhost:4000/2024/08/03/DS/" rel="alternate" type="text/html" title="Leetcode记录：哈希表" /><published>2024-08-03T14:00:00+08:00</published><updated>2024-08-03T14:00:00+08:00</updated><id>http://localhost:4000/2024/08/03/DS</id><content type="html" xml:base="http://localhost:4000/2024/08/03/DS/"><![CDATA[<h2 id="哈希表-hash-table">哈希表 (Hash Table)</h2>

<h3 id="理论基础">理论基础</h3>

<p>哈希表是一种根据关键字key来访问值value的一种数据结构。它通过把key值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做哈希函数，存放记录的数组叫做哈希表。因为本质上是通过索引来访问数组，所以哈希表的插入和查找的效率非常高，时间复杂度都是O(1)。相比于直接寻址法，它将全域缩小到可接受的范围。但存在一个问题：不同的key可能会计算出相同的索引，这就是<strong>哈希冲突(collision)</strong></p>

<p>一个最简单的冲突解决方法是<strong>链接法(chaining)</strong>，在这种方法中，数组索引对应的空间并不直接存储数据，而是存储一个链表的地址，而数据存在链表中。这样发生冲突时，就可将冲突的key对应的数据存在同一个链表上，当需要取数据时，就先找到key对应的链表，然后遍历链表。</p>

<p>还有一种思想为<strong>开放寻址法</strong>：如果通过哈希函数计算出的索引所对应的空间已经被占用了，就再找一个还没被占用的空间将数据存进去。常见的体现开放寻址思想的方法有:</p>
<ol>
  <li><strong>线性探测法:</strong> 简单来说就是从当前被占用的空间的索引开始，向下遍历整个数组，直到找到空闲空间为止。</li>
  <li><strong>双重哈希法:</strong> 使用多个哈希函数来计算索引，如果第一个哈希函数计算得到的索引所对应的空间已被占用，就用第二个，第二个被占用就用第三个，以此类推，直到计数出没被占用的空间对应的索引。</li>
</ol>

<p>上面说的方法只能在一定程度上解决哈希冲突，因为毕竟数组的容量有限，当频繁插入数据时，因为数组的容量有限，所以就会使哈希冲突加剧，进而使链表的长度增加，链表的长度增加，就会使得查找的性能降低，这不是我们想看到的结果，所以要<strong>对数组扩容</strong>。一般装载因子（<strong>已插入元素的数量除以数组容量</strong>）超过某一阈值时就进行扩容。</p>

<p>因为之前插入的元素都是按照原数组的长度来计算索引的，所以一旦数组扩容后，长度改变，就要重新进行计算，然后将已插入的元素移动到新的位置上，所以数组扩容不仅仅只是将容量增大而已。</p>

<p>另外，我们不难发现哈希函数是整个哈希表的关键。一个好的哈希函数应该近似地满足简单均匀散列假设：每个关键字都被等可能的散列到槽位中的任何一个，并与其他关键字散列到哪个槽位无关。遗憾的是一般无法检查这一条件是否成立。但是有时如果我们知道关键字的概率分布，例如都是随机的实数并且独立均匀分布在$[0,1]$区间，那么哈希函数$h(k) = \lfloor km \rfloor$就能满足简单均匀散列条件。在实际应用中则要根据不同的情况要求来设计好的散列函数。</p>

<p>常见的哈希函数有以下几种：</p>
<ol>
  <li>除法散列法：通过取$k$除以$m$的余数，将关键字$k$映射到$m$个槽位中的某一个。当应用该方法时，应避免$m$取某些值，例如2的幂次，因为如果$m=2^p$的话，$h(k)$就是$k$的$p$个最低位有效数字。通常一个不太接近2的整数幂的素数是比较好的选择。</li>
  <li>乘法散列法：先用关键字$k$乘上常数$A\in(0,1)$，并提取其小数部分；再用$m$乘上该小数并向下取整，即为$h(k)=\lfloor m(kA \space mod1)\rfloor$。该方法的优点是对$m$的选择不是很关键</li>
</ol>

<h3 id="对应stl数据结构">对应STL数据结构</h3>

<p>当我们想使用哈希法来解决问题的时候，我们一般会选择vector, set或者map数据结构。在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p>

<table>
  <thead>
    <tr>
      <th>集合</th>
      <th>底层实现</th>
      <th>是否有序</th>
      <th>数值是否可以重复</th>
      <th>能否更改数值</th>
      <th>查询效率</th>
      <th>增删效率</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>std::set</td>
      <td>红黑树</td>
      <td>有序</td>
      <td>否</td>
      <td>否</td>
      <td>O(log n)</td>
      <td>O(log n)</td>
    </tr>
    <tr>
      <td>std::multiset</td>
      <td>红黑树</td>
      <td>有序</td>
      <td>是</td>
      <td>否</td>
      <td>O(logn)</td>
      <td>O(logn)</td>
    </tr>
    <tr>
      <td>std::unordered_set</td>
      <td>哈希表</td>
      <td>无序</td>
      <td>否</td>
      <td>否</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
  </tbody>
</table>

<p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p>

<table>
  <thead>
    <tr>
      <th>映射</th>
      <th>底层实现</th>
      <th>key是否有序</th>
      <th>key是否可以重复</th>
      <th>能否更改key</th>
      <th>查询效率</th>
      <th>增删效率</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>std::map</td>
      <td>红黑树</td>
      <td>有序</td>
      <td>否</td>
      <td>否</td>
      <td>O(log n)</td>
      <td>O(log n)</td>
    </tr>
    <tr>
      <td>std::multimap</td>
      <td>红黑树</td>
      <td>有序</td>
      <td>是</td>
      <td>否</td>
      <td>O(logn)</td>
      <td>O(logn)</td>
    </tr>
    <tr>
      <td>std::unordered_map</td>
      <td>哈希表</td>
      <td>无序</td>
      <td>否</td>
      <td>否</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
  </tbody>
</table>

<p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p>

<p>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</p>

<h3 id="例题">例题</h3>

<h4 id="有效的字符异位词">有效的字符异位词</h4>

<p>Leetcode 242. 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>

<p>使用一个哈希表记录字母出现频数即可：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">isAnagram</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">string</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">!=</span> <span class="n">t</span><span class="p">.</span><span class="n">length</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sMap</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="p">){</span>
        <span class="n">sMap</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">c</span> <span class="o">:</span><span class="n">t</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">sMap</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">){</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="n">sMap</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="两个数组的交集">两个数组的交集</h4>

<p>Leetcode 349. 给定两个数组 nums1 和 nums2 ，返回它们的交集。输出结果中的每个元素一定是 唯一 的。我们可以不考虑输出结果的顺序。</p>

<p>一种方法是用两个集合，思路简单不详细写了，另一种就是排序+双指针，空间复杂度降低为 <code class="language-plaintext highlighter-rouge">O(logm + logn)</code>，时间复杂度上升为<code class="language-plaintext highlighter-rouge">O(mlogm + nlogn)</code>，该方法要注意的是要确保加入元素的唯一性，由于已经进行了排序，也就是要额外判断要加入的元素和最终数组的末尾元素是否相同:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intersection</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">nums1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums1</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">nums2</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums2</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="kt">int</span> <span class="n">length1</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">length2</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">index1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">index2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intersection</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">index1</span> <span class="o">&lt;</span> <span class="n">length1</span> <span class="o">&amp;&amp;</span> <span class="n">index2</span> <span class="o">&lt;</span> <span class="n">length2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">num1</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">[</span><span class="n">index1</span><span class="p">],</span> <span class="n">num2</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">[</span><span class="n">index2</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">num1</span> <span class="o">==</span> <span class="n">num2</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 保证加入元素的唯一性</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">intersection</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="n">num1</span> <span class="o">!=</span> <span class="n">intersection</span><span class="p">.</span><span class="n">back</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">intersection</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">num1</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">index1</span><span class="o">++</span><span class="p">;</span>
            <span class="n">index2</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">num1</span> <span class="o">&lt;</span> <span class="n">num2</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">index1</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">index2</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">intersection</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="快乐数">快乐数</h4>

<p>Leetcode 202. 编写一个算法来判断一个数 $n$ 是不是快乐数。「快乐数」 定义为：</p>
<ol>
  <li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li>
  <li>然后重复这个过程直到这个数变为1，也可能是无限循环但始终变不到1。</li>
  <li>如果这个过程结果为1，那么这个数就是快乐数。</li>
</ol>

<p>一种方法是利用哈希集合检测循环：对于一个数，我们猜测会有以下三种可能：</p>
<ol>
  <li>最终会得到 1。</li>
  <li>最终会进入循环。</li>
  <li>值会越来越大，最后接近无穷大。</li>
</ol>

<p>对于第三种情况，我们考虑对于 3 位数的数字，它不可能大于 243。这意味着它要么被困在 243 以下的循环内，要么跌到 1。4 位或 4 位以上的数字在每一步都会丢失一位，直到降到 3 位为止。所以我们知道，最坏的情况下，算法可能会在 243 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 1。但它不会无限期地进行下去，所以我们排除第三种选择。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">isHappy</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numSet</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">numSet</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">n</span><span class="p">)){</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">numSet</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="o">!=</span><span class="mi">0</span><span class="p">){</span>
            <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">n</span><span class="o">%</span><span class="mi">10</span><span class="p">;</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="p">;</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="mi">10</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">n</span><span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>既然会构成一个循环，那么我们就可以将这个过程看作是一个隐式的链表，我们要做的就是判断这个链表是否存在环路，那么我们利用快慢指针即可实现：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">getNext</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="o">!=</span><span class="mi">0</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">n</span><span class="o">%</span><span class="mi">10</span><span class="p">;</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="p">;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="n">isHappy</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">getNext</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">slow</span> <span class="o">!=</span> <span class="n">fast</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">getNext</span><span class="p">(</span><span class="n">fast</span><span class="p">);</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">getNext</span><span class="p">(</span><span class="n">fast</span><span class="p">);</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">getNext</span><span class="p">(</span><span class="n">slow</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">fast</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="两数之和">两数之和</h4>

<p>Leetcode 1. 给定一个整数数组 <code class="language-plaintext highlighter-rouge">nums</code> 和一个整数目标值 <code class="language-plaintext highlighter-rouge">target</code>，请你在该数组中找出和为目标值 <code class="language-plaintext highlighter-rouge">target</code>  的那两个整数，并返回它们的数组下标。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">twoSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">hashtable</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">hashtable</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">hashtable</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">,</span> <span class="n">i</span><span class="p">};</span>
        <span class="p">}</span>
        <span class="n">hashtable</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="数据结构与算法" /><summary type="html"><![CDATA[哈希表 (Hash Table)]]></summary></entry><entry><title type="html">Leetcode记录：链表</title><link href="http://localhost:4000/2024/08/01/DS/" rel="alternate" type="text/html" title="Leetcode记录：链表" /><published>2024-08-01T14:00:00+08:00</published><updated>2024-08-01T14:00:00+08:00</updated><id>http://localhost:4000/2024/08/01/DS</id><content type="html" xml:base="http://localhost:4000/2024/08/01/DS/"><![CDATA[<h3 id="理解虚拟头结点">理解虚拟头结点</h3>

<p>考虑单链表删除某一结点的操作，在单链表中移除头结点和移除其他节点的操作方式是不一样的，需要单独写一段逻辑来处理移除头结点的情况。此时就要使用到虚拟头结点，可以保证逻辑的一致性：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ListNode</span><span class="o">*</span> <span class="nf">removeElements</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">dummyHead</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 设置一个虚拟头结点</span>
    <span class="n">dummyHead</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span> <span class="c1">// 将虚拟头结点指向head，这样方便后面做删除操作</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">dummyHead</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ListNode</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="k">delete</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">dummyHead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">dummyHead</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="设计链表">设计链表</h3>

<p>Leetcode 707.
在链表类中实现这些功能：</p>

<ol>
  <li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li>
  <li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li>
  <li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li>
  <li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li>
  <li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li>
</ol>

<p>可以发现，使用虚拟头结点之后可以减少逻辑判断.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyLinkedList</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// 定义链表节点结构体</span>
    <span class="k">struct</span> <span class="nc">LinkedNode</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
        <span class="n">LinkedNode</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
        <span class="n">LinkedNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span><span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">next</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">){}</span>
    <span class="p">};</span>

    <span class="c1">// 初始化链表</span>
    <span class="n">MyLinkedList</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">_dummyHead</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点</span>
        <span class="n">_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点</span>
    <span class="kt">int</span> <span class="n">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">LinkedNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">_dummyHead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">index</span><span class="o">--</span><span class="p">){</span> <span class="c1">// 如果--index 就会陷入死循环</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点</span>
    <span class="kt">void</span> <span class="n">addAtHead</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LinkedNode</span><span class="o">*</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedNode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
        <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">_dummyHead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">_dummyHead</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
        <span class="n">_size</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 在链表最后面添加一个节点</span>
    <span class="kt">void</span> <span class="n">addAtTail</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LinkedNode</span><span class="o">*</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedNode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
        <span class="n">LinkedNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">_dummyHead</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">){</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
        <span class="n">_size</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span>
    <span class="c1">// 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span>
    <span class="c1">// 如果index大于链表的长度，则返回空</span>
    <span class="c1">// 如果index小于0，则在头部插入节点</span>
    <span class="kt">void</span> <span class="n">addAtIndex</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>

        <span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">_size</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>        
        <span class="n">LinkedNode</span><span class="o">*</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedNode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
        <span class="n">LinkedNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">_dummyHead</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">index</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
        <span class="n">_size</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的</span>
    <span class="kt">void</span> <span class="n">deleteAtIndex</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">_size</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">LinkedNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">_dummyHead</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">index</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span> <span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">LinkedNode</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="c1">//delete命令指示释放了tmp指针原本所指的那部分内存，</span>
        <span class="c1">//被delete后的指针tmp的值（地址）并非就是NULL，而是随机值。也就是被delete后，</span>
        <span class="c1">//如果不再加上一句tmp=nullptr,tmp会成为乱指的野指针</span>
        <span class="c1">//如果之后的程序不小心使用了tmp，会指向难以预想的内存空间</span>
        <span class="n">tmp</span><span class="o">=</span><span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">_size</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 打印链表</span>
    <span class="kt">void</span> <span class="n">printLinkedList</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">LinkedNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">_dummyHead</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">_size</span><span class="p">;</span>
    <span class="n">LinkedNode</span><span class="o">*</span> <span class="n">_dummyHead</span><span class="p">;</span>

<span class="p">};</span>
</code></pre></div></div>

<h3 id="反转链表">反转链表</h3>

<p>Leetcode 206.
给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>

<p>双指针法：</p>
<div align="center"> <img src="/pic/DS/Leetcode206.gif" width="500" /> </div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ListNode</span><span class="o">*</span> <span class="nf">reverseList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">temp</span><span class="p">;</span> <span class="c1">// 保存cur的下一个节点</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">pre</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>  <span class="c1">// 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next</span>
        <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">pre</span><span class="p">;</span> <span class="c1">// 翻转操作</span>
        <span class="c1">// 更新pre 和 cur指针</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">pre</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>递归法：让cur指向pre，然后再将cur与cur-&gt;next进行调换。本质上和双指针法相同。</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ListNode</span><span class="o">*</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">pre</span><span class="p">,</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">cur</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">cur</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">pre</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">pre</span><span class="p">;</span>
    <span class="c1">// 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步</span>
    <span class="c1">// pre = cur;</span>
    <span class="c1">// cur = temp;</span>
    <span class="k">return</span> <span class="n">reverse</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span><span class="n">temp</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">ListNode</span><span class="o">*</span> <span class="n">reverseList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 和双指针法初始化是一样的逻辑</span>
    <span class="c1">// ListNode* cur = head;</span>
    <span class="c1">// ListNode* pre = NULL;</span>
    <span class="k">return</span> <span class="n">reverse</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="两两交换链表中的节点">两两交换链表中的节点</h3>

<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>

<p>可以递归可以迭代，使用虚拟头结点避免额外的表头判断。</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ListNode</span><span class="o">*</span> <span class="nf">swapPairs</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">dummyHead</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 设置一个虚拟头结点</span>
    <span class="n">dummyHead</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span> <span class="c1">// 将虚拟头结点指向head，这样方便后面做删除操作</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">dummyHead</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="c1">// 记录临时节点</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">tmp1</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="c1">// 记录临时节点</span>

        <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>    <span class="c1">// 步骤一</span>
        <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>          <span class="c1">// 步骤二</span>
        <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tmp1</span><span class="p">;</span>   <span class="c1">// 步骤三</span>

        <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="c1">// cur移动两位，准备下一轮交换</span>
    <span class="p">}</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">dummyHead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">dummyHead</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ListNode</span><span class="o">*</span> <span class="n">swapPairs</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">swapPairs</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="删除链表倒数第n个节点">删除链表倒数第n个节点</h3>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>

<p>最简单的方法是先计算总长度再做删除，另外还有两种优化方法：</p>
<ol>
  <li>
    <p>我们可以使用两个指针 first 和 second 同时对链表进行遍历，并且 first 比 second 超前 n 个节点。当 first 遍历到链表的末尾时，second 就恰好处于倒数第 n 个节点。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">ListNode</span><span class="o">*</span> <span class="nf">removeNthFromEnd</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">ListNode</span><span class="o">*</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
     <span class="n">ListNode</span><span class="o">*</span> <span class="n">first</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
     <span class="n">ListNode</span><span class="o">*</span> <span class="n">second</span> <span class="o">=</span> <span class="n">dummy</span><span class="p">;</span>
     <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="k">while</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
         <span class="n">second</span> <span class="o">=</span> <span class="n">second</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="n">second</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">second</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
     <span class="n">ListNode</span><span class="o">*</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
     <span class="k">delete</span> <span class="n">dummy</span><span class="p">;</span>
     <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>可以在遍历链表的同时将所有节点依次入栈。根据栈「先进后出」的原则，我们弹出栈的第 n 个节点就是需要删除的节点，并且目前栈顶的节点就是待删除节点的前驱节点。</p>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">ListNode</span><span class="o">*</span> <span class="nf">removeNthFromEnd</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">ListNode</span><span class="o">*</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
     <span class="n">stack</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">*&gt;</span> <span class="n">stk</span><span class="p">;</span>
     <span class="n">ListNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">dummy</span><span class="p">;</span>
     <span class="k">while</span> <span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">stk</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
         <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">stk</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
     <span class="p">}</span>
     <span class="n">ListNode</span><span class="o">*</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
     <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
     <span class="n">ListNode</span><span class="o">*</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
     <span class="k">delete</span> <span class="n">dummy</span><span class="p">;</span>
     <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="链表相交">链表相交</h3>

<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>

<p>一种方法是首先遍历链表 headA，并将链表 headA 中的每个节点加入哈希集合中。然后遍历链表 headB，对于遍历到的每个节点，判断该节点是否在哈希集合中即可：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ListNode</span> <span class="o">*</span><span class="nf">getIntersectionNode</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">headA</span><span class="p">,</span> <span class="n">ListNode</span> <span class="o">*</span><span class="n">headB</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">ListNode</span> <span class="o">*&gt;</span> <span class="n">visited</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">headA</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">visited</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">headB</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">temp</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">temp</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>另一种方法为双指针法：当链表 headA 和 headB 都不为空时，创建两个指针 pA 和 pB，初始时分别指向两个链表的头节点 headA 和 headB，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：</p>

<ol>
  <li>每步操作需要同时更新指针 pA 和 pB。</li>
  <li>如果指针 pA 不为空，则将指针 pA 移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点。</li>
  <li>如果指针 pA 为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点。</li>
  <li>当指针 pA 和 pB 指向同一个节点或者都为空时，返回它们指向的节点或者 null。</li>
</ol>

<p>假设链表 headA 的不相交部分有 a 个节点，链表 headB 的不相交部分有 b 个节点，两个链表相交的部分有 c 个节点，则有 a+c=m，b+c=n。
如果 a=b，则两个指针会同时到达两个链表相交的节点，此时返回相交的节点；
如果 a!=b，两个指针不会同时到达链表的尾节点，在指针 pA 移动了 a+c+b 次、指针 pB 移动了 b+c+a 次之后，两个指针会同时到达两个链表相交的节点，该节点也是两个指针第一次同时指向的节点，此时返回相交的节点。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ListNode</span> <span class="o">*</span><span class="nf">getIntersectionNode</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">headA</span><span class="p">,</span> <span class="n">ListNode</span> <span class="o">*</span><span class="n">headB</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">headA</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="n">headB</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">pA</span> <span class="o">=</span> <span class="n">headA</span><span class="p">,</span> <span class="o">*</span><span class="n">pB</span> <span class="o">=</span> <span class="n">headB</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">pA</span> <span class="o">!=</span> <span class="n">pB</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pA</span> <span class="o">=</span> <span class="n">pA</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">?</span> <span class="n">headB</span> <span class="o">:</span> <span class="n">pA</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">pB</span> <span class="o">=</span> <span class="n">pB</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">?</span> <span class="n">headA</span> <span class="o">:</span> <span class="n">pB</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">pA</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<h3 id="环形链表">环形链表</h3>

<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>

<p>一个非常直观的思路是：我们遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。
另外一种思路使用快慢指针：fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。
如下图所示，设链表中环外部分的长度为 $a$，slow 指针进入环后，又走了 $b$ 的距离与 fast 相遇，距离环的起点为 $c$。此时，fast 指针已经走完了环的 $n$ 圈，因此它走过的总距离为 $a+n(b+c)+b=a+(n+1)b+nc$。
根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的 2 倍。因此，我们有
\(a+(n+1)b+nc=2(a+b)a=c+(n−1)(b+c)\)有了 $a=c+(n−1)(b+c)$ 的等量关系，我们会发现：从相遇点到入环点的距离加上 n−1 圈的环长，恰好等于从链表头部到入环点的距离。
因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ListNode</span> <span class="o">*</span><span class="nf">detectCycle</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fast</span> <span class="o">==</span> <span class="n">slow</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ListNode</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="n">slow</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="数据结构与算法" /><summary type="html"><![CDATA[理解虚拟头结点]]></summary></entry><entry><title type="html">Leetcode记录：模拟过程</title><link href="http://localhost:4000/2024/07/31/DS-2/" rel="alternate" type="text/html" title="Leetcode记录：模拟过程" /><published>2024-07-31T14:00:00+08:00</published><updated>2024-07-31T14:00:00+08:00</updated><id>http://localhost:4000/2024/07/31/DS-2</id><content type="html" xml:base="http://localhost:4000/2024/07/31/DS-2/"><![CDATA[<h3 id="螺旋矩阵">螺旋矩阵</h3>

<p>给你一个正整数 <code class="language-plaintext highlighter-rouge">n</code> ，生成一个包含 <code class="language-plaintext highlighter-rouge">1</code> 到 <code class="language-plaintext highlighter-rouge">n^2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code class="language-plaintext highlighter-rouge">n x n</code> 正方形矩阵 <code class="language-plaintext highlighter-rouge">matrix</code> 。</p>

<p>模拟顺时针画矩阵的过程:</p>
<ol>
  <li>填充上行从左到右</li>
  <li>填充右列从上到下</li>
  <li>填充下行从右到左</li>
  <li>填充左列从下到上</li>
  <li>由外向内一圈一圈这么画下去。</li>
</ol>

<p>可以发现这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，会有很多bug，因此求解本题依然是要坚持循环不变量原则：例如左闭右开，代码如下：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">generateMatrix</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span> <span class="c1">// 使用vector定义一个二维数组</span>
    <span class="kt">int</span> <span class="n">startx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">starty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 定义每循环一个圈的起始位置</span>
    <span class="kt">int</span> <span class="n">loop</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 用来给矩阵中每一个空格赋值</span>
    <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">loop</span> <span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">startx</span><span class="p">;</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">starty</span><span class="p">;</span>

        <span class="c1">// 下面开始的四个for就是模拟转了一圈</span>
        <span class="c1">// 模拟填充上行从左到右(左闭右开)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 模拟填充右列从上到下(左闭右开)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 模拟填充下行从右到左(左闭右开)</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">starty</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 模拟填充左列从下到上(左闭右开)</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">startx</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span>
        <span class="n">startx</span><span class="o">++</span><span class="p">;</span>
        <span class="n">starty</span><span class="o">++</span><span class="p">;</span>

        <span class="c1">// offset 控制每一圈里每一条边遍历的长度</span>
        <span class="n">offset</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">res</span><span class="p">[</span><span class="n">mid</span><span class="p">][</span><span class="n">mid</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>也可以实时更新上下左右四个边界来判断：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">generateMatrix</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="n">ret</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">right</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span><span class="n">top</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">bottom</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">num</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">top</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="o">++</span><span class="n">top</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">top</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">bottom</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="o">--</span><span class="n">right</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">bottom</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">left</span><span class="p">;</span><span class="n">j</span><span class="o">--</span><span class="p">){</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="o">--</span><span class="n">bottom</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">bottom</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">top</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">){</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="o">++</span><span class="n">left</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="数据结构与算法" /><summary type="html"><![CDATA[螺旋矩阵]]></summary></entry><entry><title type="html">Leetcode记录：滑动窗口和前缀和</title><link href="http://localhost:4000/2024/07/31/DS/" rel="alternate" type="text/html" title="Leetcode记录：滑动窗口和前缀和" /><published>2024-07-31T14:00:00+08:00</published><updated>2024-07-31T14:00:00+08:00</updated><id>http://localhost:4000/2024/07/31/DS</id><content type="html" xml:base="http://localhost:4000/2024/07/31/DS/"><![CDATA[<h2 id="滑动窗口">滑动窗口</h2>
<p>滑动窗口算法的基本思想是维护一个窗口，通过移动窗口的两个边界来处理问题。</p>

<p>具体来说，我们可以使用两个指针 <code class="language-plaintext highlighter-rouge">left</code> 和 <code class="language-plaintext highlighter-rouge">right</code> 分别表示滑动窗口的左右边界，然后通过不断移动右指针 <code class="language-plaintext highlighter-rouge">right</code> 来扩大窗口，同时根据问题的要求调整左指针 <code class="language-plaintext highlighter-rouge">left</code> 来缩小窗口。当右指针 <code class="language-plaintext highlighter-rouge">right</code> 扫描到字符串或数组的末尾时，算法的执行就完成了。</p>

<p>在扩大或缩小窗口的过程中，可以记录下一些中间结果，例如最大值、最小值、子串长度等等，从而求解问题的最终答案。</p>

<h3 id="适用问题">适用问题</h3>

<p>滑动窗口算法可以用于解决一些字符串和数组问题，例如：</p>
<ol>
  <li>字符串匹配问题，例如 Leetcode 第 28 题和第 76 题；</li>
  <li>最长子串或子数组问题，例如 Leetcode 第 3 题、第 209 题和第 424 题；</li>
  <li>最小覆盖子串问题，例如 Leetcode 第 76 题；</li>
  <li>字符串排列问题，例如 Leetcode 第 567 题；</li>
  <li>求解字符串或数组中的一些性质，例如 Leetcode 第 438 题、第 567 题和第 1004 题等。</li>
</ol>

<h3 id="实现方法">实现方法</h3>
<p>滑动窗口算法的实现方法相对简单，主要分为以下几个步骤：</p>
<ol>
  <li>初始化左右指针 $left$ 和 $right$，并根据问题的要求进行一些初始化操作。</li>
  <li>不断移动右指针 $right$，直到出现不符合条件的情况，或者扫描到字符串或数组的末尾。</li>
  <li>对于每个右指针位置 $i$，更新一些中间结果。</li>
  <li>移动左指针 $left$，直到出现符合条件的情况，或者左右指针重合。</li>
  <li>重复第 2 步至第 4 步，直到右指针扫描到字符串或数组的末尾。</li>
</ol>

<h4 id="示例1">示例1</h4>
<p>Leetcode 206.【长度最小的子数组】
给定一个含有 <code class="language-plaintext highlighter-rouge">n</code> 个正整数的数组和一个正整数 <code class="language-plaintext highlighter-rouge">target</code> 。找出该数组中满足其总和大于等于 <code class="language-plaintext highlighter-rouge">target</code> 的长度最小的 子数组<code class="language-plaintext highlighter-rouge">[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>

<p>这道题之所以可以使用滑动窗口，很重要的一个原因是，<strong>在移动终止位置的时候，初始位置是不可逆的，初始位置只可能往后移动，而不用每次都从第零个元素开始。</strong> 代码实现如下：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">minSubArrayLen</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">INT32_MAX</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 滑动窗口数值之和</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 滑动窗口起始位置</span>
        <span class="kt">int</span> <span class="n">subLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 滑动窗口的长度</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="c1">// 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">subLength</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 取子序列的长度</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">&lt;</span> <span class="n">subLength</span> <span class="o">?</span> <span class="n">result</span> <span class="o">:</span> <span class="n">subLength</span><span class="p">;</span>
                <span class="n">sum</span> <span class="o">-=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span> <span class="c1">// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span>
        <span class="k">return</span> <span class="n">result</span> <span class="o">==</span> <span class="n">INT32_MAX</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<h4 id="示例2">示例2</h4>

<p>Leetcode 3.【无重复最长子串】
给定一个字符串 <code class="language-plaintext highlighter-rouge">s</code> ，请你找出其中不含有重复字符的最长子串的长度。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">;</span><span class="c1">//记录字符上一次出现的位置,字符为key，位置为value</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span><span class="c1">//i表示子串的起始位置，j表示子串的结束位置</span>
        <span class="k">if</span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">!=</span> <span class="n">map</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span><span class="c1">//如果字符上一次出现的位置在i之后，更新i</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]],</span> <span class="n">i</span><span class="p">);</span><span class="c1">//map[s[j]]表示字符s[j]上一次出现的位置</span>
        <span class="p">}</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span><span class="c1">//更新结果</span>
        <span class="n">map</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>		<span class="c1">//更新字符s[j]上一次出现的位置</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="示例3">示例3</h4>
<p>Leetcode 1004.【最大连续1的个数】</p>

<p>给定一个二进制数组 <code class="language-plaintext highlighter-rouge">nums</code> 和一个整数 <code class="language-plaintext highlighter-rouge">k</code>，如果可以翻转最多 <code class="language-plaintext highlighter-rouge">k</code> 个<code class="language-plaintext highlighter-rouge">0</code> ，则返回数组中连续 <code class="language-plaintext highlighter-rouge">1</code> 的最大个数。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">longestOnes</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lsum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rsum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rsum</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">];</span> <span class="c1">//[0，right]中0的个数.</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">lsum</span> <span class="o">&lt;</span> <span class="n">rsum</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">lsum</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
            <span class="o">++</span><span class="n">left</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>该问题也可以用前缀和思路来考虑：要想快速判断一个区间内 <code class="language-plaintext highlighter-rouge">0</code> 的个数，我们可以考虑将数组中的 <code class="language-plaintext highlighter-rouge">0</code> 变成 <code class="language-plaintext highlighter-rouge">1</code>，<code class="language-plaintext highlighter-rouge">1</code> 变成 <code class="language-plaintext highlighter-rouge">0</code>。此时，我们对数组 A 求出前缀和，记为数组 <code class="language-plaintext highlighter-rouge">P</code>，那么 <code class="language-plaintext highlighter-rouge">[left,right]</code> 中包含不超过 <code class="language-plaintext highlighter-rouge">k</code> 个 <code class="language-plaintext highlighter-rouge">1</code>（注意这里就不是 <code class="language-plaintext highlighter-rouge">0</code> 了），当且仅当二者的前缀和之差：<code class="language-plaintext highlighter-rouge">P[right]−P[left−1]&lt;=k</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">longestOnes</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">P</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">P</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">P</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">P</span><span class="p">[</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="n">P</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>其中 <code class="language-plaintext highlighter-rouge">lower_bound</code> 用于在有序序列中查找第一个大于或等于给定值的元素的位置（迭代器）。</p>

<h4 id="示例4-等二刷用优化再做一遍">示例4 等二刷用优化再做一遍</h4>
<p>Leetcode 76.【最小覆盖子串】
给你一个字符串 <code class="language-plaintext highlighter-rouge">s</code> 、一个字符串 <code class="language-plaintext highlighter-rouge">t</code> 。返回 <code class="language-plaintext highlighter-rouge">s</code> 中涵盖 <code class="language-plaintext highlighter-rouge">t</code> 所有字符的最小子串。如果 <code class="language-plaintext highlighter-rouge">s</code> 中不存在涵盖 <code class="language-plaintext highlighter-rouge">t</code> 所有字符的子串，则返回空字符串 <code class="language-plaintext highlighter-rouge">""</code> 。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ori</span><span class="p">,</span> <span class="n">cnt</span><span class="p">;</span>
    
<span class="kt">bool</span> <span class="nf">check</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">p</span> <span class="o">:</span> <span class="n">ori</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">string</span> <span class="n">minWindow</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">string</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span> <span class="n">c</span> <span class="o">:</span> <span class="n">t</span><span class="p">){</span>
        <span class="n">ori</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="n">ansLeft</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ori</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">++</span><span class="n">right</span><span class="p">])</span> <span class="o">!=</span> <span class="n">ori</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">cnt</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">check</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">&lt;=</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">){</span>
                <span class="n">ansLeft</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
                <span class="n">length</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ori</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">])</span><span class="o">!=</span> <span class="n">ori</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">cnt</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]]</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">left</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">right</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">length</span> <span class="o">==</span> <span class="n">INT_MAX</span> <span class="o">?</span> <span class="s">""</span> <span class="o">:</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">ansLeft</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>注意更新右端窗口及cnt的时候先移动左端窗口，更新length，最后再right++.</p>

<p><strong>优化算法：</strong> 用一个变量 less 维护目前子串中有 less 种字母的出现次数小于 t 中字母的出现次数。具体来说（注意下面算法中的 less 变量）：</p>

<ol>
  <li>初始化 ansLeft=−1, ansRight=m，用来记录最短子串的左右端点，其中 m 是 s 的长度。</li>
  <li>用一个哈希表（或者数组）cntT 统计 t 中每个字母的出现次数。</li>
  <li>初始化 left=0，以及一个空哈希表（或者数组）cntS，用来统计 s 子串中每个字母的出现次数。</li>
  <li>初始化 less 为 t 中的不同字母个数。</li>
  <li>遍历 s，设当前枚举的子串右端点为 right，把字母 c=s[right] 的出现次数加一。加一后，如果 cntS[c]=cntT[c]，说明 c 的出现次数满足要求，把 less 减一。</li>
  <li>如果 less=0，说明 cntS 中的每个字母及其出现次数都大于等于 cntT 中的字母出现次数，那么： 如果 right−left &lt; ansRight−ansLeft，说明我们找到了更短的子串，更新 ansLeft=left, ansRight=right。</li>
  <li>把字母 x=s[left] 的出现次数减一。减一前，如果 cntS[x]=cntT[x]，说明 x 的出现次数不满足要求，把 less 加一。</li>
  <li>左端点右移，即 left 加一。</li>
  <li>重复上述三步，直到 less&gt;0，即 cntS 有字母的出现次数小于 cntT 中该字母的出现次数为止。</li>
  <li>最后，如果 ansLeft&lt;0，说明没有找到符合要求的子串，返回空字符串，否则返回下标 ansLeft 到下标 ansRight 之间的子串。</li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="nf">minWindow</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">string</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">ans_left</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ans_right</span> <span class="o">=</span> <span class="n">m</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">less</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">cnt_s</span><span class="p">[</span><span class="mi">128</span><span class="p">]{},</span> <span class="n">cnt_t</span><span class="p">[</span><span class="mi">128</span><span class="p">]{};</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">less</span> <span class="o">+=</span> <span class="n">cnt_t</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">++</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 有 less 种字母的出现次数 &lt; t 中的字母出现次数</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">right</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 移动子串右端点</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">];</span> <span class="c1">// 右端点字母（移入子串）</span>
            <span class="n">less</span> <span class="o">-=</span> <span class="o">++</span><span class="n">cnt_s</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="n">cnt_t</span><span class="p">[</span><span class="n">c</span><span class="p">];</span> <span class="c1">// c 的出现次数从 &lt; 变成 &gt;=</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">less</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 涵盖：所有字母的出现次数都是 &gt;=</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">ans_right</span> <span class="o">-</span> <span class="n">ans_left</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 找到更短的子串</span>
                    <span class="n">ans_left</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span> <span class="c1">// 记录此时的左右端点</span>
                    <span class="n">ans_right</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="kt">char</span> <span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="o">++</span><span class="p">];</span> <span class="c1">// 左端点字母（移出子串）</span>
                <span class="n">less</span> <span class="o">+=</span> <span class="n">cnt_s</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span> <span class="o">==</span> <span class="n">cnt_t</span><span class="p">[</span><span class="n">x</span><span class="p">];</span> <span class="c1">// x 的出现次数从 &gt;= 变成 &lt;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ans_left</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">""</span> <span class="o">:</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">ans_left</span><span class="p">,</span> <span class="n">ans_right</span> <span class="o">-</span> <span class="n">ans_left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>
<h4 id="示例5">示例5</h4>
<p>Leetcode 904.【水果成篮】
实质上就是找最多包含$k$个元素的连续最长子数组。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">totalFruit</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">fruits</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fruits</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">cnt</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">++</span><span class="n">cnt</span><span class="p">[</span><span class="n">fruits</span><span class="p">[</span><span class="n">right</span><span class="p">]];</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">cnt</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">fruits</span><span class="p">[</span><span class="n">left</span><span class="p">]);</span>
                <span class="o">--</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">cnt</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="o">++</span><span class="n">left</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p><strong>可以发现，滑动窗口和最大最小子数组或字符串问题关系密切，更新左窗口和更新length的先后顺序与最大还是最小问题相关</strong></p>

<h4 id="找出字符串中所有字母的异位词">找出字符串中所有字母的异位词</h4>

<p>Leetcode 438. 给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>

<p>我们可以在字符串 s 中构造一个长度为与字符串 p 的长度相同的滑动窗口，并在滑动中维护窗口中每种字母的数量；当窗口中每种字母的数量与字符串 p 中每种字母的数量相同时，则说明当前窗口为字符串 p 的异位词。</p>

<p>在此基础上，我们不再分别统计滑动窗口和字符串 p 中每种字母的数量，而是统计滑动窗口和字符串 p 中每种字母数量的差；并引入变量 differ 来记录当前窗口与字符串 p 中数量不同的字母的个数，并在滑动窗口的过程中维护它。<strong>在判断滑动窗口中每种字母的数量与字符串 p 中每种字母的数量是否相同时，只需要判断 differ 是否为零即可</strong>。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">findAnagrams</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">string</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">sLen</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">pLen</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sLen</span> <span class="o">&lt;</span> <span class="n">pLen</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">count</span><span class="p">(</span><span class="mi">26</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pLen</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="o">++</span><span class="n">count</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="sc">'a'</span><span class="p">];</span>
        <span class="o">--</span><span class="n">count</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="sc">'a'</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">differ</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span>
            <span class="o">++</span><span class="n">differ</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">differ</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sLen</span><span class="o">-</span><span class="n">pLen</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="sc">'a'</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
            <span class="o">--</span><span class="n">differ</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">count</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="sc">'a'</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
            <span class="o">++</span><span class="n">differ</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="o">--</span><span class="n">count</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="sc">'a'</span><span class="p">];</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">pLen</span><span class="p">]</span><span class="o">-</span><span class="sc">'a'</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
            <span class="o">--</span><span class="n">differ</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">count</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">pLen</span><span class="p">]</span><span class="o">-</span><span class="sc">'a'</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
            <span class="o">++</span><span class="n">differ</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="o">++</span><span class="n">count</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">pLen</span><span class="p">]</span><span class="o">-</span><span class="sc">'a'</span><span class="p">];</span>

        <span class="k">if</span><span class="p">(</span><span class="n">differ</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="串联所有单词的子串">串联所有单词的子串</h4>
<p>Leetcode 30. 给定一个字符串 s 和一个字符串数组 words。 words中所有字符串长度相同。
s 中的<strong>串联子串</strong>是指一个包含 words 中所有字符串以任意顺序排列连接起来的子串。返回所有串联子串在 s 中的开始索引。</p>

<p>和上一道题十分类似，只不过字符变成了单词，记 words 的长度为 m，words 中每个单词的长度为 n，s 的长度为 ls。首先需要将 s 划分为单词组，每个单词的大小均为 n （首尾除外）。这样的划分方法有 n 种，即先删去前 i （i=0∼n−1）个字母后，将剩下的字母进行划分，如果末尾有不到 n 个字母也删去。对这 n 种划分得到的单词数组分别使用滑动窗口对 words 进行类似于「字母异位词」的搜寻。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">findSubstring</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">words</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">ls</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">differ</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">++</span><span class="n">differ</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)];</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">word</span><span class="o">:</span> <span class="n">words</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">differ</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">differ</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">ls</span> <span class="o">-</span> <span class="n">m</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">start</span> <span class="o">+=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">string</span> <span class="n">word</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">differ</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">differ</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">word</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">start</span> <span class="o">-</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">differ</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">differ</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">differ</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">res</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="字符串的排列">字符串的排列</h4>

<p>Leetcode 567. 给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。</p>

<p>用前面的方法直接解决。</p>
<h2 id="前缀和">前缀和</h2>

<p>前缀和算法（Prefix Sum）是一种用于快速计算数组元素之和的技术。它通过预先计算数组中每个位置前所有元素的累加和，将这些部分和存储在一个新的数组中，从而在需要计算某个区间的和时，可以通过简单的减法操作得到结果，而不必重新遍历整个区间。</p>

<p>一维前缀和：给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">presum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">presum</span> <span class="o">+=</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">presum</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">sum</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">b</span><span class="p">];</span>
        <span class="k">else</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>二维前缀和：给你一个n行m列的矩阵A ，<strong>下标从1开始。</strong> 请输出以 (x1, y1) 为左上角 , (x2,y2) 为右下角的子矩阵的和。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">arr</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
 
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;&gt;</span> <span class="n">dp</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> <span class="c1">//注意这一步.</span>
 
    <span class="kt">int</span> <span class="n">x1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x1</span> <span class="o">&gt;&gt;</span> <span class="n">y1</span> <span class="o">&gt;&gt;</span> <span class="n">x2</span> <span class="o">&gt;&gt;</span> <span class="n">y2</span><span class="p">;)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">x2</span><span class="p">][</span><span class="n">y2</span><span class="p">]</span> <span class="o">-</span> <span class="n">dp</span><span class="p">[</span><span class="n">x1</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">y2</span><span class="p">]</span> <span class="o">-</span> <span class="n">dp</span><span class="p">[</span><span class="n">x2</span><span class="p">][</span><span class="n">y1</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">x1</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">y1</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div align="center"> <img src="/pic/DS/2DPrefix_Sum.png" width="800" /> </div>

<h4 id="示例1-1">示例1</h4>

<p>Leetcode 238.【除自身以外数组的乘积】
给你一个整数数组 <code class="language-plaintext highlighter-rouge">nums</code>，返回 数组 <code class="language-plaintext highlighter-rouge">answer</code> ，其中 <code class="language-plaintext highlighter-rouge">answer[i]</code> 等于 <code class="language-plaintext highlighter-rouge">nums</code> 中除 <code class="language-plaintext highlighter-rouge">nums[i]</code> 之外其余各元素的乘积。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">productExceptSelf</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">answer</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>

    <span class="c1">// answer[i] 表示索引 i 左侧所有元素的乘积</span>
    <span class="c1">// 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1</span>
    <span class="n">answer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">answer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">answer</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// R 为右侧所有元素的乘积</span>
    <span class="c1">// 刚开始右边没有元素，所以 R = 1</span>
    <span class="kt">int</span> <span class="n">R</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span>
        <span class="n">answer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">answer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">R</span><span class="p">;</span>
        <span class="c1">// R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span>
        <span class="n">R</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="示例2-1">示例2</h4>
<p>Leetcode 560.【和为k的子数组】
给你一个整数数组 <code class="language-plaintext highlighter-rouge">nums</code> 和一个整数 <code class="language-plaintext highlighter-rouge">k</code> ，请你统计并返回该数组中和为 <code class="language-plaintext highlighter-rouge">k</code> 的子数组的个数。</p>

<p>由于数组可能存在负数，我们无法使用滑动窗口来求解该问题。我们可以存储所有的前缀和出现的次数，遍历的时候寻找 <code class="language-plaintext highlighter-rouge">pre-k</code> 的个数即可。</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">subarraySum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">mp</span><span class="p">;</span>
        <span class="n">mp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//注意！</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pre</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="o">:</span><span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pre</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">pre</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">!=</span> <span class="n">mp</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="n">mp</span><span class="p">[</span><span class="n">pre</span> <span class="o">-</span> <span class="n">k</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="n">mp</span><span class="p">[</span><span class="n">pre</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<h4 id="示例3-1">示例3</h4>
<p>Leetcode 974. 【和可被K整除的子数组】
给定一个整数数组 <code class="language-plaintext highlighter-rouge">nums</code> 和一个整数 <code class="language-plaintext highlighter-rouge">k</code>，返回其中元素之和可被 <code class="language-plaintext highlighter-rouge">k</code> 整除的非空子数组的数目。</p>

<p>由于负数的存在，这里我们存储的是 <code class="language-plaintext highlighter-rouge">(pre % k + k) % k</code>的个数，</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">subarraysDivByK</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">hash</span><span class="p">;</span>
    <span class="n">hash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">e</span> <span class="o">:</span> <span class="n">nums</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">e</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">mod</span> <span class="o">=</span> <span class="p">(</span><span class="n">sum</span> <span class="o">%</span> <span class="n">k</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span> <span class="o">%</span> <span class="n">k</span><span class="p">;</span> <span class="c1">//这里考虑有负数的情况</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hash</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">mod</span><span class="p">))</span> <span class="n">ret</span> <span class="o">+=</span> <span class="n">hash</span><span class="p">[</span><span class="n">mod</span><span class="p">];</span>
        <span class="n">hash</span><span class="p">[</span><span class="n">mod</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="示例4">示例4</h4>
<p>Leetcode 525.【连续数组】
给定一个二进制数组 <code class="language-plaintext highlighter-rouge">nums</code> , 找到含有相同数量的 <code class="language-plaintext highlighter-rouge">0</code> 和 <code class="language-plaintext highlighter-rouge">1</code> 的最长连续子数组，并返回该子数组的长度。</p>

<p>这里的技巧是将0替换为-1，这样只需求和为0的最长连续子数组。
我们要想知道区间长度，就需要知道i和j，因此我们向哈希表中存入的value为当前前缀和的下标。此外，如果我们再次遇到一个值为sum的下标，由于这里求得是最长区间，所以我们不需要更新hash[sum]。而如果整个区间的长度都为0，那么我们就需要在前缀和为0的情况下，找到一个下标为-1的地方来统计整个数组长度。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">findMaxLength</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">e</span> <span class="o">:</span> <span class="n">nums</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">e</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">hash</span><span class="p">;</span>
    <span class="n">hash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hash</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">sum</span><span class="p">))</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">hash</span><span class="p">[</span><span class="n">sum</span><span class="p">]);</span>
        <span class="k">else</span> <span class="n">hash</span><span class="p">[</span><span class="n">sum</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="数据结构与算法" /><summary type="html"><![CDATA[滑动窗口 滑动窗口算法的基本思想是维护一个窗口，通过移动窗口的两个边界来处理问题。]]></summary></entry><entry><title type="html">Leetcode记录：二分查找和双指针法</title><link href="http://localhost:4000/2024/07/30/DS/" rel="alternate" type="text/html" title="Leetcode记录：二分查找和双指针法" /><published>2024-07-30T02:00:00+08:00</published><updated>2024-07-30T02:00:00+08:00</updated><id>http://localhost:4000/2024/07/30/DS</id><content type="html" xml:base="http://localhost:4000/2024/07/30/DS/"><![CDATA[<h2 id="二分查找">二分查找</h2>

<p>二分查找的前提为有序数组，同时要关注数组是否存在重复元素。</p>

<p>二分查找的框架为</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">binarySearch</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="p">...;</span>

    <span class="k">while</span><span class="p">(...)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">...</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">left</span> <span class="o">=</span> <span class="p">...</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">right</span> <span class="o">=</span> <span class="p">...</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">...;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。另外，计算 mid 时需要技巧防止溢出。</p>

<h3 id="基本的二分查找">基本的二分查找</h3>

<p>省略号的部分可以分为两种写法：左闭右闭和左闭右开，可以画图来进行分析，此处略过</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">search</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 定义target在左闭右闭的区间里，[left, right]</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span>
            <span class="kt">int</span> <span class="n">midd</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">((</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span><span class="c1">// 防止溢出 等同于(left + right)/2</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// target 在左区间，所以[left, middle - 1]</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// target 在右区间，所以[middle + 1, right]</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// nums[middle] == target</span>
                <span class="k">return</span> <span class="n">mid</span><span class="p">;</span> <span class="c1">// 数组中找到目标值，直接返回下标</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 未找到目标值</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="c1">// Another version:</span>
<span class="kt">int</span> <span class="n">search</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="c1">// 定义target在左闭右开的区间里，即：[left, right)</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span>
            <span class="kt">int</span> <span class="n">middle</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">((</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">middle</span><span class="p">;</span> <span class="c1">// target 在左区间，在[left, middle)中</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// target 在右区间，在[middle + 1, right)中</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// nums[middle] == target</span>
                <span class="k">return</span> <span class="n">middle</span><span class="p">;</span> <span class="c1">// 数组中找到目标值，直接返回下标</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 未找到目标值</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>但是如果给定有序数组 <code class="language-plaintext highlighter-rouge">nums = [1,2,2,2,3]，target = 2</code>，此算法返回的索引是 <code class="language-plaintext highlighter-rouge">2</code>，但是如果我想得到 <code class="language-plaintext highlighter-rouge">target</code> 的左侧边界，即索引 <code class="language-plaintext highlighter-rouge">1</code>，或者我想得到 <code class="language-plaintext highlighter-rouge">target</code> 的右侧边界，即索引 <code class="language-plaintext highlighter-rouge">3</code>，这样的话此算法是无法处理的。</p>

<h3 id="寻找左右侧边界的二分搜索">寻找左右侧边界的二分搜索</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">left_bound</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 注意</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 注意</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 注意</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// target 比所有数都大</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span> <span class="o">?</span> <span class="n">left</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">right_bound</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 注意</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span> <span class="o">?</span> <span class="n">right</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 注意</span>
<span class="p">}</span>
</code></pre></div></div>

<p>也可以统一写为一个函数</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">binarySearch</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">left_bound</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span> <span class="o">||</span> <span class="p">(</span><span class="n">lower</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">target</span><span class="p">)){</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">left</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">searchRange</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">leftIdx</span> <span class="o">=</span> <span class="n">binarySearch</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">rightIdx</span> <span class="o">=</span> <span class="n">binarySearch</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">leftIdx</span> <span class="o">&lt;=</span> <span class="n">rightIdx</span> <span class="o">&amp;&amp;</span> <span class="n">rightIdx</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
        <span class="n">nums</span><span class="p">[</span><span class="n">leftIdx</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">rightIdx</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="n">leftIdx</span><span class="p">,</span> <span class="n">rightIdx</span><span class="p">};</span>
    <span class="p">}</span> 
    <span class="k">return</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>对应题目：</p>
<ol>
  <li><strong>704.二分查找</strong></li>
  <li><strong>35.搜索插入位置</strong></li>
  <li><strong>34.在排序数组中查找元素的第一个和最后一个位置</strong></li>
</ol>

<h2 id="双指针法">双指针法</h2>

<p>双指针是指在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个指针进行遍历，从而达到相应的目的。</p>

<p>最常见的双指针算法有两种：</p>
<ol>
  <li>在同一个序列中，用两个指针维护两个位置，或两个位置包含的区间；</li>
  <li>在两个序列里边，两个指针指向不同的序列，来维护某种次序。</li>
</ol>

<p>按照指针的移动方向，双指针分为同向双指针、异向双指针：</p>
<ol>
  <li>同向双指针，也称快慢指针（两个指针一快一慢）；</li>
  <li>异向双指针，分为对撞指针（从两边向中间移动）、背向指针（从中间向两边移动）。</li>
</ol>

<h3 id="快慢指针">快慢指针</h3>

<p>两个指针，初始在同一位置，然后向相同方向移动，一个移动速度快，一个移动速度慢。</p>

<p>适用场景：<strong>查找链表中间节点、链表是否包含环、原地修改数组。</strong></p>

<h4 id="示例1">示例1</h4>
<p>LeetCode 876.【链表的中间结点】</p>

<p>给你单链表的头结点 head ，请你找出并返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。如下图所示，链表有 5 个节点，返回第 3 个节点；链表有 6 个节点，返回第 4 个节点。</p>

<div align="center"> <img src="/pic/DS/Leetcode876.png" width="400" /> </div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ListNode</span> <span class="nf">middleNode</span><span class="p">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ListNode</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">ListNode</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="n">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="p">.</span><span class="n">next</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="n">next</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">slow</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="示例2">示例2</h4>
<p>LeetCode 26.【删除有序数组中的重复项】
给你一个非严格递增排列的数组 <code class="language-plaintext highlighter-rouge">nums</code> ，请你原地删除重复出现的元素，使每个元素只出现一次 ，返回删除后数组的新长度。元素的相对顺序应该保持 一致 。然后返回 <code class="language-plaintext highlighter-rouge">nums</code> 中唯一元素的个数。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">removeElement</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">slowIndex</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">fastIndex</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">fastIndex</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">fastIndex</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">val</span><span class="o">!=</span><span class="n">nums</span><span class="p">[</span><span class="n">fastIndex</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="n">nums</span><span class="p">[</span><span class="n">slowIndex</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">nums</span><span class="p">[</span><span class="n">fastIndex</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">slowIndex</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="对撞指针">对撞指针</h3>
<p>两个指针，初始一个在左、一个在右，左指针向右移动，右指针向左移动，直到相撞停止。</p>

<p>适用场景：<strong>二分查找、反转数组、回文判定。</strong></p>
<h4 id="示例1-1">示例1</h4>
<p>LeetCode 977.【有序数组的平方】
给你一个按<strong>非递减顺序</strong>排序的整数数组 <code class="language-plaintext highlighter-rouge">nums</code>，返回每个数字的平方组成的新数组，要求也按<strong>非递减顺序</strong>排序。</p>

<p>由于数组平方的<strong>最大值就在数组的两端</strong>，不是最左边就是最右边，不可能是中间，此时可以考虑双指针法了</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sortedSquares</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;)</span> <span class="p">{</span> <span class="c1">// 注意这里要i &lt;= j，因为最后要处理两个元素</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>  <span class="p">{</span>
                <span class="n">result</span><span class="p">[</span><span class="n">k</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="n">j</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">result</span><span class="p">[</span><span class="n">k</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">i</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<div align="center"> <img src="/pic/DS/Leetcode977.gif" width="400" /> </div>

<h4 id="示例2-1">示例2</h4>
<p>LeetCode 344.【反转字符串】</p>

<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code class="language-plaintext highlighter-rouge">s</code> 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 <code class="language-plaintext highlighter-rouge">O(1)</code> 的额外空间解决这一问题。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">reverseString</span><span class="p">(</span><span class="kt">char</span><span class="p">[]</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
        <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
        <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="n">left</span><span class="o">++</span><span class="p">;</span>
        <span class="n">right</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="背向指针">背向指针</h3>
<p>两个指针，初始都在中间，左指针向左移动，右指针向右移动，直至碰到最左或最右边界。</p>

<p>使用场景：<strong>查找字符串中的最长回文子串。</strong></p>

<h4 id="示例1-2">示例1</h4>
<p>LeetCode 5.最长回文子串</p>

<p>给你一个字符串 <code class="language-plaintext highlighter-rouge">s</code>，找到 <code class="language-plaintext highlighter-rouge">s</code> 中最长的回文子串。如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>

<p>在给定字符串中找回文子串的难点在于，<strong>回文子串的的长度可能是奇数也可能是偶数</strong>，如果回文串的长度为奇数，则它有一个中心字符，例如<code class="language-plaintext highlighter-rouge">bacab</code>；如果回文串的长度为偶数，则可以认为它有两个中心字符，例如<code class="language-plaintext highlighter-rouge">baab</code>。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">string</span> <span class="nf">expandCenter</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="c1">// 要时刻注意避免越界访问</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">len</span>
           <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">left</span><span class="o">--</span><span class="p">;</span>
        <span class="n">right</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">string</span> <span class="n">longestPalindrome</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="n">string</span> <span class="n">res</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">sub1</span> <span class="o">=</span> <span class="n">expandCenter</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">string</span> <span class="n">sub2</span> <span class="o">=</span> <span class="n">expandCenter</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">sub1</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">?</span> <span class="n">res</span> <span class="o">:</span> <span class="n">sub1</span><span class="p">;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">sub2</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">?</span> <span class="n">res</span> <span class="o">:</span> <span class="n">sub2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="数据结构与算法" /><summary type="html"><![CDATA[二分查找]]></summary></entry><entry><title type="html">CSAPP-2-3:程序的机器级运行过程</title><link href="http://localhost:4000/2024/01/02/CSAPP-2-3/" rel="alternate" type="text/html" title="CSAPP-2-3:程序的机器级运行过程" /><published>2024-01-02T16:23:00+08:00</published><updated>2024-01-02T16:23:00+08:00</updated><id>http://localhost:4000/2024/01/02/CSAPP-2-3</id><content type="html" xml:base="http://localhost:4000/2024/01/02/CSAPP-2-3/"><![CDATA[<h1 id="程序的机器级表示">程序的机器级表示</h1>

<h2 id="过程">过程</h2>

<p>过程提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能，然后可以在程序不同的地方调用这个函数。
过程的形式多样：函数（function），方法（method），子例程（subroutine），处理函数（handler）等等。</p>

<p>要提供对过程的机器级支持，必须要处理许多不同的属性。假设过程P调用过程Q，Q执行后返回到P，这些动作包括下面一个或多个机制：</p>
<ol>
  <li><strong>传递控制</strong>：在进入过程Q时，程序计数器必须被设置为Q的代码的起始地址。在返回时，要把程序计数器设置为P中调用Q后的指令的地址。</li>
  <li><strong>传递数据</strong>：P必须能够向Q提供一个或多个参数，Q必须能够向P返回一个值。</li>
  <li><strong>分配和释放内存</strong>：在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些空间。</li>
</ol>

<h3 id="过程时栈">过程时栈</h3>

<p>栈提供了后进先出的内存管理原则。在过程P调用Q的例子中，当Q在执行时，P以及所有向上追溯到P的调用链中的过程都是暂时被挂起的。当Q运行时，它只需要为局部变量分配新的存储空间或者设置到另一个过程的调用。另一方面，当Q返回时，任何它所分配的局部存储空间都可以被释放。因此，程序可以用栈来管理它的过程所需要的存储空间。</p>

<div align="center"> <img src="/pic/CSAPP/Stack.png" width="400" /> </div>

<p>x86-64的栈向低地址方向增长，%rsp指向栈顶元素，将栈指针减小一个适当的量可以为没有指定初始值的数据在栈上分配空间，类似的可以通过增加栈指针来释放空间。</p>

<p>当x86-64过程需要的存储空间超过寄存器能存放的大小时，就会在栈上分配空间，这个部分称为过程的<strong>栈帧(stack frame)。</strong>上图中，当P调用Q时，会把返回地址压入栈中，<strong>指明当Q返回时要从程序的哪个位置继续执行</strong>，我们把这个返回地址当做P的栈帧的一部分，因为这是和P相关的状态。</p>

<p>Q的代码会扩展当前栈的边界，分配它的栈帧所需的空间，在这个空间中可以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。大多数栈帧都是定长的，但有些过程需要变长的栈帧（<strong>后面会讲</strong>），<strong>通过寄存器，过程P最多可以传递6个人整数值（指针和整数），如果需要更多参数，P可以在调用Q之前在自己的栈帧中存储好这些参数。</strong></p>

<h3 id="转移控制">转移控制</h3>

<p>将控制从P转移到Q只需要简单地把程序计数器（PC）设置为Q的代码起始位置。不过，当稍后从Q返回时，处理器必须记录好它需要继续P的执行的代码的位置。这个信息是用<strong>指令call Q</strong>调用过程Q来记录的。该指令会把地址A压入栈中，并将PC设置为Q的起始地址。压入的地址A称为<strong>返回地址</strong>，是紧跟call后面的那条指令的地址。对应的指令<strong>ret</strong>会从栈中弹出A并把PC设置为A。</p>

<div align="center"> <img src="/pic/CSAPP/call&amp;ret.png" width="400" /> </div>

<p>下面是一个例子：</p>

<div align="center"> <img src="/pic/CSAPP/call1.png" width="500" /> </div>
<div align="center"> <img src="/pic/CSAPP/call2.png" width="500" /> </div>

<h3 id="数据传送">数据传送</h3>

<p>x86-64中可以通过寄存器最多传递6个整型参数。寄存器使用是有特殊顺序的并且寄存器使用的名字取决于要传递的数据类型的大小。</p>

<p>如果一个函数有大于6个整型参数，超过的部分需要用栈来传递。假设P调用Q有n个整型参数且n大于6，则P的栈帧必须要容纳7~n号参数的存储空间并且参数7位于栈顶。 <strong>通过栈传递参数时，所有的数据大小都向8的倍数对齐。</strong>参数到位之后就可以调用call指令了。</p>

<p>下面是参数传递的例子，可以看到最后两个参数位于相对于栈指针距离为8和16的位置。注意：<strong>第6行movl从内存读入4字节，而后面的addb指令只是用其中的低位1字节。（因为它重置了存储a2的寄存器），另外这里也没有做扩展，因为它只是读取，不涉及再做转换，与2.1节的练习不同。</strong></p>

<div align="center"> <img src="/pic/CSAPP/stack&amp;data.png" width="500" /> </div>

<p><strong>要时刻注意MOV指令的使用。</strong></p>

<h3 id="栈上的局部存储">栈上的局部存储</h3>

<p>有些时候局部数据必须存放在内存中：</p>
<ol>
  <li>寄存器不足够存放所有数据</li>
  <li>对一个局部变量使用地址运算符</li>
  <li>某些局部变量是数组或结构</li>
</ol>

<p>下面是两个例子：</p>

<div align="center"> <img src="/pic/CSAPP/localStack1.png" width="500" /> </div>
<div align="center"> <img src="/pic/CSAPP/localStack2.png" width="500" /> </div>
<div align="center"> <img src="/pic/CSAPP/localStack3.png" width="500" /> </div>

<p><strong>注意3-6行，通过栈传参时数据大小按8的倍数对齐，分配局部变量内存时不用。再注意17-20行在读取内存的同时还会将其扩展到适当的大小。</strong></p>

<h3 id="寄存器中的局部存储空间">寄存器中的局部存储空间</h3>

<p>寄存器组是唯一被所有过程共享的资源，虽然在给定时刻只有一个过程是活动的，我们仍要保证一个过程调用另一个过程时，被调用者不会覆盖调用者稍后要使用的寄存器值。因此，根据惯例，<strong>寄存器%rbx,%rbp,$r12~%r15被划分为被调用者保存寄存器</strong>，当过程P调用过程Q时，Q必须保存这些寄存器的值，也就是说如果要用到它们，<strong>就要用pushq将原始值压入栈中，并在返回前从栈中弹出旧值。</strong></p>

<p>所有其他的寄存器除了%rsp都分类为调用者保存寄存器，这意味着任何函数都能修改它们，<strong>所以在调用之前首先保存好这个数据是调用者的责任。</strong></p>

<p>下面是一个例子：</p>

<div align="center"> <img src="/pic/CSAPP/localStack4.png" width="500" /> </div>

<h3 id="递归过程">递归过程</h3>

<p>递归调用一个函数本身与调用其他函数是一样的，栈提供了这种机制，每次函数调用都有他自己私有的状态信息。栈分配和释放规则自然的就与函数调用和返回顺序匹配。</p>

<div align="center"> <img src="/pic/CSAPP/recursion.png" width="500" /> </div>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="CSAPP" /><category term="汇编" /><summary type="html"><![CDATA[程序的机器级表示]]></summary></entry><entry><title type="html">CSAPP-2-2:程序的机器级运行控制</title><link href="http://localhost:4000/2024/01/02/CSAPP-2-2/" rel="alternate" type="text/html" title="CSAPP-2-2:程序的机器级运行控制" /><published>2024-01-02T10:23:00+08:00</published><updated>2024-01-02T10:23:00+08:00</updated><id>http://localhost:4000/2024/01/02/CSAPP-2-2</id><content type="html" xml:base="http://localhost:4000/2024/01/02/CSAPP-2-2/"><![CDATA[<h1 id="程序的机器级表示">程序的机器级表示</h1>

<h2 id="控制">控制</h2>

<p>C语言程序中存在有条件的执行语句，例如<strong>条件语句、循环语句和分支语句</strong>，机器代码提供两种基本的低级机制来实现有条件的行为：<strong>测试数据值，然后根据测试的结果来改变控制流或者数据流，</strong></p>

<h3 id="条件码">条件码</h3>

<p>除了整数寄存器，CPU还维护着一组<strong>单个位</strong>的<strong>条件码(condition code)寄存器</strong>，它们描述了最近的算术或者逻辑操作的属性，最常用的条件码有：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">CF</code>：进位标志。最近的操作使最高位产生了进位，可用来检查无符号操作的溢出。</li>
  <li><code class="language-plaintext highlighter-rouge">ZF</code>：零标志。最近的操作得出的结果为0。</li>
  <li><code class="language-plaintext highlighter-rouge">SF</code>：符号标志。最近的操作得到的结果为负数。</li>
  <li><code class="language-plaintext highlighter-rouge">OF</code>：溢出标志。最近的操作导致一个补码溢出—-正溢出或负溢出。</li>
</ol>

<p>例如，假设我们用一条ADD指令完成<code class="language-plaintext highlighter-rouge">t=a+b</code>的功能，则会根据下面的C表达式来设置条件码：</p>

<div align="center"> <img src="/pic/CSAPP/ConditionExm.png" width="400" /> </div>

<p>注意有几个特殊情况：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">leaq</code>指令<strong>不会改变任何条件码</strong>，除此之外，所有一元二元指令都会设置条件码。</li>
  <li>对于逻辑操作，例如<code class="language-plaintext highlighter-rouge">XOR</code>，<strong>进位标志和溢出标志</strong>会设置为0。</li>
  <li>对于移位操作，<strong>进位标志</strong>将设置为<strong>最后一个</strong>被移除的位，而<strong>溢出标志</strong>设置为0。</li>
  <li><code class="language-plaintext highlighter-rouge">INC</code>和<code class="language-plaintext highlighter-rouge">DEC</code>会设置<strong>溢出和零标志</strong>，但不会改变<strong>进位标志</strong>。</li>
</ol>

<p>除了算术和逻辑操作，还有两类指令会设置条件码，它们只设置条件码而不改变任何其他寄存器：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">CMP</code>指令根据两个操作数之差来设置条件码。除了不更新目的寄存器之外，行为与<code class="language-plaintext highlighter-rouge">SUB</code>指令一致，常用来比较大小。</li>
  <li><code class="language-plaintext highlighter-rouge">TEST</code>指令与<code class="language-plaintext highlighter-rouge">AND</code>指令的行为一样，除了不改变目的寄存器的值。典型的用法是两个操作数是一样的，或者其中操作数是一个掩码用来指示哪些位应该被测试（例如，<code class="language-plaintext highlighter-rouge">testq %rax,%rax</code>用来检查<code class="language-plaintext highlighter-rouge">%rax</code>是负数、零还是正数）。</li>
</ol>

<div align="center"> <img src="/pic/CSAPP/CMP&amp;TEST.png" width="400" /> </div>

<h3 id="访问条件码">访问条件码</h3>

<p>条件码通常不会直接读取，常见的使用方法有三种：</p>

<ol>
  <li>可以根据条件码的某种组合，将一个字节设置为0或1。</li>
  <li>可以条件跳转到程序的某个其他的部分。</li>
  <li>可以有条件的传送数据。</li>
</ol>

<p>针对第一种情况，我们将这一整类指令称为<code class="language-plaintext highlighter-rouge">SET</code>指令，它们的区别就在于他们考虑的条件码组合是什么，此时后缀表示<strong>不同的条件</strong>而不是操作数大小。</p>

<div align="center"> <img src="/pic/CSAPP/SET.png" width="500" /> </div>

<p>一个<code class="language-plaintext highlighter-rouge">SET</code>指令的目的操作数是低位单字节寄存器之一，或者是一个字节的内存为止，指针会将这个字节设置成0或1。为了得到一个32位或64位结果，<strong>必须对高位清零</strong>，例如<code class="language-plaintext highlighter-rouge">a&lt;b</code>的指令序列如下：</p>

<div align="center"> <img src="/pic/CSAPP/SETExm.png" width="400" /> </div>

<p>虽然所有的算术和逻辑操作都会设置条件码，但是所有<code class="language-plaintext highlighter-rouge">SET</code>指令的描述都适用的情况是：执行比较命令，根据计算<code class="language-plaintext highlighter-rouge">t=a-b</code>设置条件码。</p>

<p>考虑<code class="language-plaintext highlighter-rouge">setl</code>指令测试一个有符号比较，当没有发生溢出时（OF设置为0的时候表示无溢出），我们有当 $ a-_w^tb&lt;0 $时有 $a&lt;b$，将SF设置为1可以表明这一点，而当$ a-_w^tb\geq 0 $时有 $a&lt;geq b$，此时SF将置为0，因此有上表<code class="language-plaintext highlighter-rouge">setl</code>的效果，并且由<code class="language-plaintext highlighter-rouge">setl</code>可以推导出其他三个。</p>

<p>对于无符号比较的测试，当 $a&lt;b$时，<code class="language-plaintext highlighter-rouge">CMP</code>指令会设置进位标志，因而无符号比较使用的是进位标志和零标志的结合。</p>

<h3 id="跳转指令">跳转指令</h3>

<p>正常执行的情况下，指令会一条一条按顺序执行下去，跳转指令会导致执行切换到另一个全新的位置。在汇编代码中，这些跳转的目的地<strong>通常用一个标号(label)指明</strong>，例如：</p>

<div align="center"> <img src="/pic/CSAPP/jmpExm.png" width="400" /> </div>

<p>在产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将<strong>跳转目标</strong>（目的指令的地址）编码为跳转指令的一部分。</p>

<p>下图列举了不同的跳转指令，<code class="language-plaintext highlighter-rouge">jmp</code>为无条件跳转，他可以是直接跳转，即跳转目标是作为指令的一部分编码的，也可以是间接跳转，即跳转目标是从寄存器或内存位置中读出的，例如 <code class="language-plaintext highlighter-rouge">jmp *&amp;rax</code>是用寄存器中的值作为跳转目标，<code class="language-plaintext highlighter-rouge">jmp *(%rax)</code>以<code class="language-plaintext highlighter-rouge">%rax</code>中的值作为读地址，再从内存中读出跳转目标。</p>

<div align="center"> <img src="/pic/CSAPP/jmp.png" width="500" /> </div>

<h3 id="跳转指令的编码">跳转指令的编码</h3>

<p>在汇编代码中，跳转指令用符号标号书写，汇编器及后来的链接器会产生跳转目标的适当编码。跳转指令有几种不同的编码，但最常用的都是 <strong>PC相对的(PC-relative)。</strong> 也就是，它们会将 <strong>目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。</strong> 这些地址偏移量可以编码为1,2,4个字节。第二种编码方法就是给出“绝对”地址，用4个字节直接指定目标，汇编器和链接器会选择会选择适当的跳转目的编码。</p>

<p>下面是一个PC相对寻址的例子，第2行的<code class="language-plaintext highlighter-rouge">jmp</code>指令向前跳转到更高的地址，第7行的<code class="language-plaintext highlighter-rouge">jg</code>指令向后跳转到更低的地址：</p>

<div align="center"> <img src="/pic/CSAPP/PCjmpExm.png" width="200" /> </div>
<div align="center"> <img src="/pic/CSAPP/PCjmpExm2.png" width="300" /> </div>

<p>每个16进制两位数都是1个字节，第二行中跳转目标指明为 <code class="language-plaintext highlighter-rouge">loop+0x5+0x3</code>，第五行中为<code class="language-plaintext highlighter-rouge">loop+0xd-0x8</code>，都是下一条指令的地址的相对位置。</p>

<h3 id="用条件控制实现条件分支">用条件控制实现条件分支</h3>

<p>C语言中的if-else语句的通用形式模板如下：</p>

<pre><code class="language-C">if (test-expr)
    then-statement
else
    else-statement
</code></pre>

<p>汇编实现如下：</p>

<div align="center"> <img src="/pic/CSAPP/IfElse.png" width="200" /> </div>

<p>我们可以使用goto风格代码来更好地理解，这里注意汇编中条件跳转的参数与C语言中是相反的：</p>

<div align="center"> <img src="/pic/CSAPP/ifElseC.png" width="500" /> </div>

<p>还有一个例子：</p>

<pre><code class="language-C">void cond(long a, long *p){
    if(p &amp;&amp; a&gt;*p)
        *p=a;
}
</code></pre>

<p>汇编语言为</p>
<pre><code class="language-asm">cond:
    testq %rdi, %rdi
    jz .L2
    cmpq %rsi, (%rdi)
    jle .L2
    movq %rsi, (%rdi)
.L2:
    ret 
</code></pre>

<p>由于&amp;&amp;有短路性质，所以一个if语句在汇编中却有两个条件分支。</p>

<h3 id="用条件传送来实现条件分支">用条件传送来实现条件分支</h3>

<p>实现条件操作的传统方法是 通过使用<strong>控制</strong>的条件转移，当条件满足时程序沿着一条执行路径执行，否则走另一条路径。这种机制简单通用但是可能会低效。</p>

<p>一个替代的策略是使用<strong>数据</strong>的条件转移，这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个。下面是一个例子，注意也是求相反的结果：</p>

<div align="center"> <img src="/pic/CSAPP/cmovExm.png" width="500" /> </div>

<p>首先了解一下现代处理器如何运行，处理器通过使用流水线来获得高性能，一条指令的处理要经过一系列的阶段，例如从内存读指令，确定指令，从内存读数据，执行运算，写数据，更新计数器等。这种方法通过重叠连续指令来获得高性能，例如在取一条指令的同时执行前一条命令的算术运算。那就要实现确定要执行的指令序列才能保持流水线充满待执行的指令。</p>

<p>当机器遇到条件跳转的时候，处理器会采用非常精密的分支预测逻辑来猜测每条跳转指令是否会执行，如果猜错了就要求处理器丢掉它为该跳转指令后所有指令已做的工作，再从正确的位置处填充流水线，这会导致性能严重下降。</p>

<p>下面是一些可用的条件传送指令，源和目的的值可以是16、32、64位，但不支持单字节的条件传送。<strong>无条件传送需要将操作数长度显式编码在指令名中，但条件传送中汇编器可以从目标寄存器的名字来推断操作数长度，因此可以使用同一个名字。</strong></p>

<div align="center"> <img src="/pic/CSAPP/cmov.png" width="500" /> </div>

<p>同条件跳转不同，处理器无需预测测试结果就可以执行条件传送，<strong>在下一章会讨论它的实现。</strong></p>

<p>但是不是所有的条件表达式都可以用条件传送来编译：</p>

<ol>
  <li>如果这两个表达式中的任意一个可能产生错误条件或者副作用，就会导致非法的行为：
 例如，考虑下面这个C函数
    <pre><code class="language-C"> long cread(long *xp){
     return (xp ? *xp : 0);
 }
</code></pre>
    <p>对应的条件传送如下：</p>
    <pre><code class="language-asm"> xp in register %rdi.
 cread:
     movq (%rdi), %rax
     testq %rdi, %rdi
     movl $0, %edx
     cmove %rdx, %rax
     ret
</code></pre>
    <p>此时会出现间接引用空指针的错误。</p>
  </li>
  <li>如果两个操作都需要花费大量的运算，那就不会使用条件传送。</li>
  <li>执行任意分支可能会改变程序其他部分的状态时不会使用条件传送，例如
    <pre><code class="language-C"> val = x&gt;0 ? x*=7 : x+=3;
</code></pre>
  </li>
</ol>

<p>下面是除以2的幂次的例子：</p>

<div align="center"> <img src="/pic/CSAPP/divide8.png" width="300" /> </div>

<p>通过右移来实现，如果x小于0需要加$2^k-1$再进行右移。</p>

<h3 id="循环">循环</h3>

<p>C语言三中循环： do-while, while 和 for：</p>

<ol>
  <li><strong>do-while循环：</strong>
 do-while循环的通用形式为：
    <pre><code class="language-asm"> do
     body-statement
     while(test-expr)
</code></pre>

    <p>汇编形式为：</p>
    <pre><code class="language-asm"> loop:
     body-statement
     t = test-expr
     if (t)
         goto loop
</code></pre>
    <p>下面是阶乘计算的例子：</p>
    <div align="center"> <img src="/pic/CSAPP/dowhile.png" width="500" /> </div>
  </li>
  <li><strong>while循环：</strong>
 while语句有两种生成方法：
    <ol>
      <li>
        <p>第一种称之为jump to middle，这个是GCC带优化命令选项<code class="language-plaintext highlighter-rouge">-Og</code>时采用的翻译方法，可以翻译为：</p>

        <pre><code class="language-asm"> goto test;
 loop:
     body-statement
 test:
     t = test-expr;
     if (t)
         goto loop;
</code></pre>
        <div align="center"> <img src="/pic/CSAPP/while1.png" width="500" /> </div>
      </li>
      <li>
        <p>第二种翻译方法称为guarded-do，首先用条件分支，如果初始条件不成立就跳过循环，把代码变换为do-while循环，这是采用较高优化等级<code class="language-plaintext highlighter-rouge">-O1</code>才会采用的策略：</p>

        <pre><code class="language-asm"> t = test-expr
 if (t)
     goto done;
 loop:
     body-statement;
     t = test-expr;
     if(t)
         goto loop;
 done:
     ret
</code></pre>
        <div align="center"> <img src="/pic/CSAPP/while2.png" width="500" /> </div>
        <div align="center"> <img src="/pic/CSAPP/while3.png" width="300" /> </div>
      </li>
    </ol>
  </li>
  <li>
    <p><strong>for循环：</strong>
 for循环的通用形式为</p>

    <pre><code class="language-asm"> for(init-expr; test-expr; update-expr)
     body-statement
</code></pre>

    <p>这样一个循环的行为与下面这段代码的行为一样：</p>

    <pre><code class="language-asm"> init-expr;
 while (test-expr) {
     body-statement
     update-expr;
 }
</code></pre>
    <p>再利用while循环翻译为汇编语言。</p>

    <div align="center"> <img src="/pic/CSAPP/while2.png" width="500" /> </div>

    <pre><code class="language-C"> long fun_b(unsigned long x){
     long val = 0;
     long i;
     for(i = 64; i!=0; i--){
         val = (val &lt;&lt; 1) | (x &amp; 1);
         x &gt;&gt;= 1;
     }
     return val;
 }
</code></pre>

    <p>汇编代码为：</p>
    <pre><code class="language-asm"> fun_b:
     movl $64, %edx
     movl $0. &amp;eax
 .L10:
     movq %rdi, %rcx
     andl $1, %ecx
     addq %rax, %rax
     orq %rcx, %rax
     shrq $1, %rdi
     subq $1, %rdx
     jne .L10
     rep; ret
</code></pre>

    <p>因为64不为0，所有初始测试直接被忽略了。这个函数的行为是将x的位反过来，只需每次取x的最低位放进val低位，每次val左移，x右移。</p>
  </li>
</ol>

<h3 id="switch语句">switch语句</h3>

<p>switch语句不仅提高了C代码的可读性，而且通过使用<strong>跳转表</strong>使得实现更加高效。跳转表是一个数组，表项i是一个代码段的地址，当开关索引值等于i时程序采用对应的动作。它的优点在于：执行开关语句的时间与开关情况的数量无关。当开关情况数量比较多并且值的跨度范围比较小时就会使用跳转表。</p>

<div align="center"> <img src="/pic/CSAPP/switch1.png" width="500" /> </div>
<div align="center"> <img src="/pic/CSAPP/switch2.png" width="400" /> </div>
<p>这个例子中包括case label跨过一个不连续区域（101，105没有标号）、有多个标号（104，106）、有些情况会落入其他情况之中（102），因为没有break语句结尾。</p>

<p>可以看到，编译器首先将n减去100，把取值范围移到0-6之间，创建一个新的程序变量index，注意它是<strong>无符号值</strong>，这样我们可以通过测试index是否大于6来判定index是否在0-6之间，如果小于0的话根据补码性质也还是大于6的。根据index值有五个不同的跳转位置，loc_A(.L3)，loc_B(.L5)，loc_C(.L6)，loc_D(.L7)，loc_def(.L8)，最后一个是默认的目的地址。</p>

<p>执行switch语句的关键步骤是通过跳转表来访问代码位置，在汇编第五行以及goto代码中的第16行，<code class="language-plaintext highlighter-rouge">jmp</code>指令的操作数有前缀<code class="language-plaintext highlighter-rouge">*</code>，表明这是一个间接跳转，操作数指定一个内存为止，索引由寄存器%rsi给出，这个寄存器保存着index的值。</p>

<p>C代码将跳转表声明为一个7个元素的数组，每个元素都是一个指向代码位置的指针，可以发现，对于重复情况的处理就是对4和6采用同样的代码标号，对于确实情况的处理就是对1和5采用默认情况的标号。对于fall through的情况就是对应的代码位置也是fall through的。</p>

<p>在汇编中表示如下：</p>
<div align="center"> <img src="/pic/CSAPP/switch3.png" width="400" /> </div>

<p>其中<code class="language-plaintext highlighter-rouge">.rodata</code>为只读数据，其中包含一组7个四“字”（8个字节），每个字的值都是与指定的汇编代码标号相关联的指令地址。</p>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="CSAPP" /><category term="汇编" /><summary type="html"><![CDATA[程序的机器级表示]]></summary></entry></feed>