<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2024-11-03T02:46:28+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Liujiyu’s blog</title><subtitle>learn &amp; record</subtitle><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><entry><title type="html">C++11\14特性</title><link href="http://localhost:4000/2024/10/21/Cpp11_14/" rel="alternate" type="text/html" title="C++11\14特性" /><published>2024-10-21T10:00:00+08:00</published><updated>2024-10-21T10:00:00+08:00</updated><id>http://localhost:4000/2024/10/21/Cpp11_14</id><content type="html" xml:base="http://localhost:4000/2024/10/21/Cpp11_14/"><![CDATA[<h2 id="c11特性">C++11特性</h2>

<h3 id="1-自动类型推导-auto">1. <strong>自动类型推导 (<code class="language-plaintext highlighter-rouge">auto</code>)</strong></h3>

<p>C++11 引入了 <code class="language-plaintext highlighter-rouge">auto</code> 关键字，允许编译器根据表达式的类型自动推导变量的类型。它可以简化代码，特别是在处理复杂的类型时。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>      <span class="c1">// 编译器推导 x 为 int</span>
<span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>   <span class="c1">// 编译器推导 y 为 double</span>
<span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">int</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>  <span class="c1">// 推导为 int*</span>
</code></pre></div></div>

<p>推导规则看CppLearning.pdf。</p>

<h3 id="2-范围-for-循环range-based-for-loop">2. <strong>范围 for 循环（Range-based for loop）</strong></h3>

<p>C++11 引入了范围 for 循环，简化了对容器或数组元素的迭代操作。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">v</span> <span class="o">:</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="3-智能指针-shared_ptr-unique_ptr-weak_ptr">3. <strong>智能指针 (<code class="language-plaintext highlighter-rouge">shared_ptr</code>, <code class="language-plaintext highlighter-rouge">unique_ptr</code>, <code class="language-plaintext highlighter-rouge">weak_ptr</code>)</strong></h3>
<p>智能指针本质是一个封装了一个原始C++指针的类模板，为了确保动态内存的安全性而产生的。
C++11 提供了新的智能指针，用于更好地管理动态内存：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">std::unique_ptr</code>：独占所有权。</li>
  <li><code class="language-plaintext highlighter-rouge">std::shared_ptr</code>：共享所有权，使用引用计数来管理对象的生命周期。</li>
  <li><code class="language-plaintext highlighter-rouge">std::weak_ptr</code>：用于打破 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 之间的循环引用。</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
</code></pre></div></div>

<p>在 C++ 的早期，<code class="language-plaintext highlighter-rouge">auto_ptr</code> 是标准库中唯一提供的智能指针，用于自动管理动态分配的内存。然而，<code class="language-plaintext highlighter-rouge">auto_ptr</code> 有一些设计缺陷，尤其是所有权的转移行为不直观、不安全，因此在 C++11 引入了新的智能指针类型，如 <code class="language-plaintext highlighter-rouge">unique_ptr</code>、<code class="language-plaintext highlighter-rouge">shared_ptr</code> 和 <code class="language-plaintext highlighter-rouge">weak_ptr</code>，并逐渐淘汰了 <code class="language-plaintext highlighter-rouge">auto_ptr</code>。</p>

<p>接下来，我们详细讨论从 <code class="language-plaintext highlighter-rouge">auto_ptr</code> 到 C++11 的智能指针演变。</p>

<h4 id="1-auto_ptrc98">1. <strong><code class="language-plaintext highlighter-rouge">auto_ptr</code>（C++98）</strong></h4>

<p><code class="language-plaintext highlighter-rouge">auto_ptr</code> 是 C++98 标准中的智能指针，用来管理动态分配的对象。它的主要目的是在对象离开作用域时自动释放动态分配的内存，避免内存泄漏。</p>

<h5 id="11-基本用法">1.1 <strong>基本用法</strong>：</h5>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>  <span class="c1">// 动态分配内存并绑定到 auto_ptr</span>
    <span class="n">std</span><span class="o">::</span><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>          <span class="c1">// 转移所有权，p1 不再持有对象</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>       <span class="c1">// 输出 10</span>
    <span class="c1">// p1 现在是空指针，持有 nullptr</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="12-auto_ptr-的问题">1.2 <strong><code class="language-plaintext highlighter-rouge">auto_ptr</code> 的问题</strong>：</h5>
<ul>
  <li><strong>所有权转移</strong>：<code class="language-plaintext highlighter-rouge">auto_ptr</code> 在拷贝和赋值时会转移资源的所有权。例如，<code class="language-plaintext highlighter-rouge">auto_ptr p2 = p1;</code> 会将资源从 <code class="language-plaintext highlighter-rouge">p1</code> 转移到 <code class="language-plaintext highlighter-rouge">p2</code>，而 <code class="language-plaintext highlighter-rouge">p1</code> 被置为空。这种所有权转移是不直观的，容易导致悬空指针或双重释放的问题。</li>
  <li><strong>不能用于容器</strong>：由于 <code class="language-plaintext highlighter-rouge">auto_ptr</code> 拷贝时会改变源对象的状态，它无法安全地用于 STL 容器（如 <code class="language-plaintext highlighter-rouge">std::vector</code>）。容器通常会在元素的插入和删除过程中进行拷贝操作，使用 <code class="language-plaintext highlighter-rouge">auto_ptr</code> 会导致意外的行为。</li>
  <li><strong>已经废弃</strong>：由于这些问题，<code class="language-plaintext highlighter-rouge">auto_ptr</code> 在 C++11 被标记为<strong>废弃</strong>，并在 C++17 中完全移除。</li>
</ul>

<h4 id="2-unique_ptrc11">2. <strong><code class="language-plaintext highlighter-rouge">unique_ptr</code>（C++11）</strong></h4>

<p><code class="language-plaintext highlighter-rouge">unique_ptr</code> 是 C++11 引入的智能指针，旨在替代 <code class="language-plaintext highlighter-rouge">auto_ptr</code>。它也是一种<strong>独占所有权</strong>的智能指针，但相比 <code class="language-plaintext highlighter-rouge">auto_ptr</code>，<code class="language-plaintext highlighter-rouge">unique_ptr</code> 更加安全和高效。</p>

<h5 id="21-特点">2.1 <strong>特点</strong>：</h5>
<ul>
  <li><strong>独占所有权</strong>：<code class="language-plaintext highlighter-rouge">unique_ptr</code> 独占所管理的资源，不能被拷贝，但可以通过<strong>移动语义</strong>（move semantics）转移所有权。</li>
  <li><strong>轻量高效</strong>：相比于 <code class="language-plaintext highlighter-rouge">shared_ptr</code>，<code class="language-plaintext highlighter-rouge">unique_ptr</code> 没有额外的引用计数开销。</li>
  <li><strong>自定义删除器</strong>：<code class="language-plaintext highlighter-rouge">unique_ptr</code> 支持自定义删除器，可以管理复杂资源（如文件句柄、网络连接等）。</li>
</ul>

<h5 id="22-基本用法">2.2 <strong>基本用法</strong>：</h5>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">20</span><span class="p">));</span>       <span class="c1">// 创建 unique_ptr，管理动态分配的内存</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>    <span class="c1">// 使用 std::move 转移所有权</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>              <span class="c1">// 输出 20</span>
    <span class="c1">// p1 现在是空的，不能再使用它</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="23-与-auto_ptr-的区别">2.3 <strong>与 <code class="language-plaintext highlighter-rouge">auto_ptr</code> 的区别</strong>：</h5>
<ul>
  <li>
    <p><strong>不能拷贝</strong>：与 <code class="language-plaintext highlighter-rouge">auto_ptr</code> 不同，<code class="language-plaintext highlighter-rouge">unique_ptr</code> 不能通过复制构造或赋值操作来拷贝。必须使用 <code class="language-plaintext highlighter-rouge">std::move</code> 将所有权从一个 <code class="language-plaintext highlighter-rouge">unique_ptr</code> 转移到另一个。这避免了 <code class="language-plaintext highlighter-rouge">auto_ptr</code> 的潜在所有权混乱问题。</p>
  </li>
  <li>
    <p><strong>自定义删除器</strong>：<code class="language-plaintext highlighter-rouge">unique_ptr</code> 可以接受自定义删除器来释放资源，适用于更复杂的资源管理场景。</p>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">FILE</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fclose</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">filePtr</span><span class="p">(</span><span class="n">fopen</span><span class="p">(</span><span class="s">"test.txt"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">),</span> <span class="n">fclose</span><span class="p">);</span>
</code></pre></div></div>

<h5 id="24-应用场景">2.4 <strong>应用场景</strong>：</h5>
<ul>
  <li>用于确保资源在离开作用域时被正确释放，避免内存泄漏。</li>
  <li><code class="language-plaintext highlighter-rouge">unique_ptr</code> 适用于独占资源的场景，如管理文件、网络连接或设备句柄等。</li>
</ul>

<h4 id="3-shared_ptrc11">3. <strong><code class="language-plaintext highlighter-rouge">shared_ptr</code>（C++11）</strong></h4>

<p><code class="language-plaintext highlighter-rouge">shared_ptr</code> 是一种支持<strong>共享所有权</strong>的智能指针，多个 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 可以共同管理同一个对象。对象的生命周期会延长，直到最后一个 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 释放它。</p>

<h5 id="31-特点">3.1 <strong>特点</strong>：</h5>
<ul>
  <li><strong>引用计数</strong>：<code class="language-plaintext highlighter-rouge">shared_ptr</code> 内部维护一个引用计数，当引用计数为 0 时，所管理的对象会被自动销毁。</li>
  <li><strong>拷贝安全</strong>：<code class="language-plaintext highlighter-rouge">shared_ptr</code> 可以被拷贝，拷贝时引用计数增加。</li>
  <li><strong>线程安全</strong>：C++11 标准中，<code class="language-plaintext highlighter-rouge">shared_ptr</code> 的引用计数是线程安全的。</li>
</ul>

<h5 id="32-基本用法">3.2 <strong>基本用法</strong>：</h5>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>   <span class="c1">// 推荐的创建方式</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>                          <span class="c1">// 拷贝 p1，引用计数增加</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>                         <span class="c1">// 输出 30</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Use count: "</span> <span class="o">&lt;&lt;</span> <span class="n">p1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 引用计数输出 2</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="33-shared_ptr-与-unique_ptr-的区别">3.3 <strong><code class="language-plaintext highlighter-rouge">shared_ptr</code> 与 <code class="language-plaintext highlighter-rouge">unique_ptr</code> 的区别</strong>：</h5>
<ul>
  <li>
    <p><strong>共享所有权</strong>：<code class="language-plaintext highlighter-rouge">shared_ptr</code> 的设计目的是让多个智能指针共享同一个对象。当不再需要对象时，引用计数归零，自动销毁对象。相比之下，<code class="language-plaintext highlighter-rouge">unique_ptr</code> 独占对象，不能共享。</p>
  </li>
  <li>
    <p><strong>性能开销</strong>：由于 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 需要维护引用计数，它比 <code class="language-plaintext highlighter-rouge">unique_ptr</code> 有更大的内存和性能开销。如果没有必要的共享行为，应该优先使用 <code class="language-plaintext highlighter-rouge">unique_ptr</code>。</p>
  </li>
</ul>

<h5 id="34-自定义删除器">3.4 <strong>自定义删除器</strong>：</h5>
<p>与 <code class="language-plaintext highlighter-rouge">unique_ptr</code> 类似，<code class="language-plaintext highlighter-rouge">shared_ptr</code> 也支持自定义删除器：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">FILE</span><span class="o">&gt;</span> <span class="n">filePtr</span><span class="p">(</span><span class="n">fopen</span><span class="p">(</span><span class="s">"test.txt"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">),</span> <span class="n">fclose</span><span class="p">);</span>
</code></pre></div></div>

<h5 id="35-应用场景">3.5 <strong>应用场景</strong>：</h5>
<ul>
  <li>当多个对象需要共享同一个资源时，可以使用 <code class="language-plaintext highlighter-rouge">shared_ptr</code>。例如，一个对象在多个模块中被使用，所有模块都应该控制其生命周期。</li>
  <li>当对象的强引用计数降为0时，shared_ptr会释放该对象的内存，但控制块不会立即释放，因为仍然有weak_ptr可能在观察它。控制块会在弱引用计数也降为0时释放，这样可以确保weak_ptr可以安全地判断对象是否有效。</li>
</ul>

<h4 id="4-weak_ptrc11">4. <strong><code class="language-plaintext highlighter-rouge">weak_ptr</code>（C++11）</strong></h4>

<p><code class="language-plaintext highlighter-rouge">weak_ptr</code> 是一种<strong>非拥有</strong>（non-owning）的智能指针，它与 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 配合使用，用于解决共享对象的<strong>循环引用</strong>问题。<code class="language-plaintext highlighter-rouge">weak_ptr</code> 不影响引用计数。</p>

<h5 id="41-特点">4.1 <strong>特点</strong>：</h5>
<ul>
  <li><strong>弱引用</strong>：<code class="language-plaintext highlighter-rouge">weak_ptr</code> 只是指向对象，并不影响对象的生命周期，不能直接解引用。</li>
  <li><strong>循环引用解决</strong>：在使用 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 时，如果两个对象相互持有对方的 <code class="language-plaintext highlighter-rouge">shared_ptr</code>，会导致循环引用，无法释放内存。使用 <code class="language-plaintext highlighter-rouge">weak_ptr</code> 可以打破这种循环。</li>
</ul>

<h5 id="42-基本用法">4.2 <strong>基本用法</strong>：</h5>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sp</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">40</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">wp</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>  <span class="c1">// 创建 weak_ptr，不增加引用计数</span>

    <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">wp</span><span class="p">.</span><span class="n">lock</span><span class="p">())</span> <span class="p">{</span>  <span class="c1">// 使用 lock() 生成 shared_ptr</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">temp</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 输出 40</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Resource no longer available."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="43-应用场景">4.3 <strong>应用场景</strong>：</h5>
<ul>
  <li><code class="language-plaintext highlighter-rouge">weak_ptr</code> 通常用于避免循环引用。例如在双向链表、图结构或依赖关系复杂的系统中，<code class="language-plaintext highlighter-rouge">shared_ptr</code> 的循环引用问题可以通过 <code class="language-plaintext highlighter-rouge">weak_ptr</code> 解决。</li>
</ul>

<p><strong>智能指针中的引用计数是线程安全的，但是智能指针所指向的对象的线程安全问题，智能指针没有做任何保障线程不安全。</strong></p>

<h3 id="4-lambda-表达式">4. <strong>Lambda 表达式</strong></h3>

<p>C++11 引入了 lambda 表达式，使得可以在代码中编写匿名函数，特别适合于函数作为参数的场景，如回调、事件处理等。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">add</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 输出 3</span>
</code></pre></div></div>

<p>捕获外部变量：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">](</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">func</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 输出 8</span>
</code></pre></div></div>

<p>匿名函数本质上是一个对象，在其定义的过程中会创建出一个栈对象，内部通过重载()符号实现函数调用的外表。</p>

<p>优点：使用匿名函数，可以免去函数的声明和定义。这样匿名函数仅在调用函数的时候才会创建函数对象，而调用结束后立即释放，所以匿名函数比非匿名函数更节省空间。</p>

<h3 id="5-移动语义与右值引用-rvalue-references">5. <strong>移动语义与右值引用 (<code class="language-plaintext highlighter-rouge">rvalue references</code>)</strong></h3>

<p>C++11 引入了移动语义和右值引用，允许开发者通过转移资源所有权来避免不必要的拷贝，极大地提升了性能，尤其是对于临时对象的处理。</p>

<ul>
  <li>右值引用通过 <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> 定义，可以捕获右值，并通过 <code class="language-plaintext highlighter-rouge">std::move()</code> 转移资源。</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">v1</span><span class="p">);</span>  <span class="c1">// v1 的资源被转移给 v2，避免了拷贝</span>
</code></pre></div></div>

<p><strong>完美转发</strong>（Perfect Forwarding）是 C++11 引入的一个特性，<strong>允许函数将其接收到的参数（包括其值类型、引用类型和右值或左值属性）完美地转发给另一个函数</strong>。这种转发可以保留参数的所有特性，从而避免不必要的拷贝或引用失效问题。</p>

<p>完美转发的核心是<strong>右值引用</strong>（rvalue references）和<strong>模板参数推导</strong>，特别是结合了 <code class="language-plaintext highlighter-rouge">std::forward</code> 的使用，使得我们可以将函数接收到的参数以最优的方式传递给其他函数。</p>

<p>完美转发依赖于以下几个概念：</p>

<ol>
  <li><strong>右值引用（Rvalue Reference）</strong>：
    <ul>
      <li>右值引用通过 <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> 语法定义，用来接受右值对象（临时对象），并允许开发者高效地使用和转移这些对象的资源。</li>
      <li>对于模板参数中的 <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code>，它既能接受右值引用，也能接受左值引用，这是完美转发的基础。</li>
    </ul>
  </li>
  <li><strong>万能引用（Universal Reference）</strong>：
    <ul>
      <li>当 <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code> 作为模板参数出现时，它被称为<strong>万能引用</strong>，可以同时接受左值引用和右值引用。编译器根据传递的参数类型推导 <code class="language-plaintext highlighter-rouge">T</code> 的类型，从而决定是左值引用还是右值引用。</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">std::forward</code></strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">std::forward</code> 是一个帮助函数，用来在函数内部将参数以原始的类型（左值或右值）转发给另一个函数。它根据模板参数的类型决定是否执行<strong>移动语义</strong>（move semantics）。</li>
    </ul>
  </li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="c1">  // for std::forward</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Lvalue reference: "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">process</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Rvalue reference: "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">forwarder</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">process</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span>  <span class="c1">// 保持 arg 的值类别</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
    <span class="n">forwarder</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>        <span class="c1">// 转发左值，调用 process(int&amp;)</span>
    <span class="n">forwarder</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>      <span class="c1">// 转发右值，调用 process(int&amp;&amp;)</span>
<span class="p">}</span>
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Lvalue reference: 42
Rvalue reference: 100
</code></pre></div></div>

<p>如果没有使用 <code class="language-plaintext highlighter-rouge">std::forward</code>，完美转发就无法正常工作。例如：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">forwarder</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">process</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>  <span class="c1">// 没有使用 std::forward</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
    <span class="n">forwarder</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>        <span class="c1">// 错误：a 是左值，传递给 process 时应为左值引用</span>
    <span class="n">forwarder</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>      <span class="c1">// 错误：100 是右值，但被转发为左值</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在这段代码中，<code class="language-plaintext highlighter-rouge">process(arg)</code> 传递的是 <code class="language-plaintext highlighter-rouge">arg</code>，无论 <code class="language-plaintext highlighter-rouge">arg</code> 是左值还是右值，都会被视为<strong>左值</strong>传递。结果是，即使你传递的是右值，它在传递过程中也会丧失右值属性。</p>

<p><strong><code class="language-plaintext highlighter-rouge">std::forward</code> 根据模板参数的类型来决定是否转发为右值：</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>如果 <code class="language-plaintext highlighter-rouge">T</code> 是左值引用类型，<code class="language-plaintext highlighter-rouge">std::forward&lt;T&gt;(t)</code> 会返回 <code class="language-plaintext highlighter-rouge">t</code> 的左值引用。</li>
  <li>如果 <code class="language-plaintext highlighter-rouge">T</code> 是右值引用类型，<code class="language-plaintext highlighter-rouge">std::forward&lt;T&gt;(t)</code> 会将 <code class="language-plaintext highlighter-rouge">t</code> 转换为右值引用。</li>
</ul>

<h3 id="6-完美转发的注意事项">6. <strong>完美转发的注意事项</strong></h3>

<ol>
  <li><strong>引用折叠</strong>：
    <ul>
      <li>在完美转发中，C++11 引入了<strong>引用折叠规则</strong>，帮助解决模板参数推导过程中多重引用的问题。具体规则如下：
        <ul>
          <li><code class="language-plaintext highlighter-rouge">T&amp; &amp;</code>、<code class="language-plaintext highlighter-rouge">T&amp; &amp;&amp;</code>、<code class="language-plaintext highlighter-rouge">T&amp;&amp; &amp;</code> 都会折叠为 <code class="language-plaintext highlighter-rouge">T&amp;</code>（左值引用）。</li>
          <li>只有 <code class="language-plaintext highlighter-rouge">T&amp;&amp; &amp;&amp;</code> 会折叠为 <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code>（右值引用）。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>性能问题</strong>：
    <ul>
      <li>完美转发的设计目的是优化性能，减少不必要的拷贝和对象构造。然而，完美转发可能引入额外的复杂性，尤其是在处理移动语义时。</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">std::forward</code> 与 <code class="language-plaintext highlighter-rouge">std::move</code> 的区别</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">std::move</code> 总是将其参数转换为右值引用，而 <code class="language-plaintext highlighter-rouge">std::forward</code> 会根据参数类型决定是否保留其值类别。因此，<code class="language-plaintext highlighter-rouge">std::forward</code> 更适合用于模板参数转发。</li>
    </ul>
  </li>
</ol>

<h3 id="6-nullptr">6. <strong><code class="language-plaintext highlighter-rouge">nullptr</code></strong></h3>

<p>C++11 引入了 <code class="language-plaintext highlighter-rouge">nullptr</code>，它取代了传统的 <code class="language-plaintext highlighter-rouge">NULL</code>，成为一个类型安全的空指针常量。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>  <span class="c1">// 代替 NULL</span>
</code></pre></div></div>

<h3 id="7-constexpr">7. <strong><code class="language-plaintext highlighter-rouge">constexpr</code></strong></h3>

<p>C++11 引入了 <code class="language-plaintext highlighter-rouge">constexpr</code>，它允许在编译时计算常量表达式，提高编译期的优化。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">square</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">square</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>  <span class="c1">// 在编译时计算</span>
</code></pre></div></div>

<h3 id="8-委托构造函数delegating-constructors">8. <strong>委托构造函数（Delegating constructors）</strong></h3>

<p>C++11 允许一个构造函数调用另一个构造函数，简化了构造函数的实现。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">MyClass</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>  <span class="c1">// 调用另一个构造函数</span>
    <span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{}</span>

<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="9-显式转换运算符explicit-conversion-operators">9. <strong>显式转换运算符（Explicit conversion operators）</strong></h3>

<p>C++11 允许将类型转换运算符标记为 <code class="language-plaintext highlighter-rouge">explicit</code>，避免隐式转换带来的错误。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">MyClass</span> <span class="n">obj</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 只有通过显示的转换，才能将 obj 转换为 bool</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="10-stdthread-和多线程支持">10. <strong><code class="language-plaintext highlighter-rouge">std::thread</code> 和多线程支持</strong></h3>

<p>C++11 引入了标准库的多线程支持，包括 <code class="language-plaintext highlighter-rouge">std::thread</code>、<code class="language-plaintext highlighter-rouge">std::mutex</code>、<code class="language-plaintext highlighter-rouge">std::lock_guard</code> 等，可以直接使用标准库进行线程创建和同步。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span><span class="kt">void</span> <span class="nf">threadFunc</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello from thread"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">threadFunc</span><span class="p">);</span>  <span class="c1">// 创建一个线程</span>
    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>                   <span class="c1">// 等待线程结束</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="11-变参模板variadic-templates">11. <strong>变参模板（Variadic templates）</strong></h3>

<p>C++11 支持变参模板，允许模板接受任意数量的模板参数。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">...</span> <span class="o">&lt;&lt;</span> <span class="n">args</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// C++17 fold expression</span>
<span class="p">}</span>
<span class="n">print</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="s">"Hello"</span><span class="p">);</span>  <span class="c1">// 输出：1 2.5 Hello</span>
</code></pre></div></div>

<h3 id="12-stdtuple">12. <strong><code class="language-plaintext highlighter-rouge">std::tuple</code></strong></h3>

<p>C++11 引入了 <code class="language-plaintext highlighter-rouge">std::tuple</code>，它是一个固定大小的异构集合，允许存储不同类型的对象。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;tuple&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="s">"Hello"</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 输出 1</span>
</code></pre></div></div>

<h3 id="13-enum-class">13. <strong><code class="language-plaintext highlighter-rouge">enum class</code></strong></h3>

<p>C++11 引入了强类型枚举 <code class="language-plaintext highlighter-rouge">enum class</code>，它比传统的 <code class="language-plaintext highlighter-rouge">enum</code> 更安全，因为它不会隐式转换为整型。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">Color</span> <span class="p">{</span> <span class="n">Red</span><span class="p">,</span> <span class="n">Green</span><span class="p">,</span> <span class="n">Blue</span> <span class="p">};</span>
<span class="n">Color</span> <span class="n">c</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">Red</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="14-stdarray">14. <strong><code class="language-plaintext highlighter-rouge">std::array</code></strong></h3>

<p>C++11 提供了 <code class="language-plaintext highlighter-rouge">std::array</code>，它是 C++ STL 的静态数组，具有固定大小，并且提供了与 STL 容器相同的接口。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 输出 2</span>
</code></pre></div></div>

<h3 id="15-初始化列表initializer-lists">15. <strong>初始化列表（Initializer Lists）</strong></h3>

<p>C++11 引入了初始化列表语法，允许通过大括号 <code class="language-plaintext highlighter-rouge">{}</code> 直接初始化对象。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>  <span class="c1">// 使用初始化列表</span>
</code></pre></div></div>

<h3 id="16-decltype">16. <strong><code class="language-plaintext highlighter-rouge">decltype</code></strong></h3>

<p>C++11 提供了 <code class="language-plaintext highlighter-rouge">decltype</code>，用于推导表达式的类型，类似于 <code class="language-plaintext highlighter-rouge">auto</code>，但 <code class="language-plaintext highlighter-rouge">decltype</code> 可以用于复杂表达式的类型推导。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>  <span class="c1">// y 的类型与 x 相同，推导为 int</span>
</code></pre></div></div>

<h3 id="17-静态断言static_assert">17. <strong>静态断言（<code class="language-plaintext highlighter-rouge">static_assert</code>）</strong></h3>

<p>C++11 引入了 <code class="language-plaintext highlighter-rouge">static_assert</code>，用于在编译时进行条件检查，如果条件为假，编译器会抛出错误。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">,</span> <span class="s">"int size is not 4 bytes"</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="18-后置返回类型trailing-return-types">18. <strong>后置返回类型（Trailing Return Types）</strong></h3>

<p>C++11 支持在函数定义中使用后置返回类型，特别适用于复杂的返回类型或函数模板。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="19-noexcept">19. <strong><code class="language-plaintext highlighter-rouge">noexcept</code></strong></h3>

<p>C++11 引入了 <code class="language-plaintext highlighter-rouge">noexcept</code>，用于标记函数不抛出异常，有助于编译器优化。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="c1">// 函数不抛出异常</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="20-右值引用与移动构造函数">20. <strong>右值引用与移动构造函数</strong></h3>

<p>C++11 提供了右值引用和移动语义，用于避免不必要的对象拷贝，提高性能。移动构造函数和移动赋值运算符可以通过转移资源来避免深拷贝。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MyClass</span><span class="p">(</span><span class="n">MyClass</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="c1">// 实现移动构造函数</span>
    <span class="p">}</span>
    <span class="n">MyClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">MyClass</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="c1">// 实现移动赋值运算符</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="总结">总结</h3>

<p>C++11 是 C++ 语言的一次重大更新，带来了许多极大增强语言能力的特性。这些特性不仅简化了编写 C++ 代码的过程，还提供了强大的工具用于提高性能和安全性，使得 C++ 在现代开发中更加高效和实用。</p>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="C++" /><summary type="html"><![CDATA[C++11特性]]></summary></entry><entry><title type="html">C++补充</title><link href="http://localhost:4000/2024/10/21/Cpp/" rel="alternate" type="text/html" title="C++补充" /><published>2024-10-21T10:00:00+08:00</published><updated>2024-10-21T10:00:00+08:00</updated><id>http://localhost:4000/2024/10/21/Cpp</id><content type="html" xml:base="http://localhost:4000/2024/10/21/Cpp/"><![CDATA[<h3 id="内存分区">内存分区</h3>

<p>C++内存主要分为以下几个部分：</p>

<p>栈（Stack）：用于存储局部变量、函数参数、返回地址等。栈是自动管理的，数据进入作用域分配空间，离开作用域自动释放。</p>

<p>堆（Heap）：用于动态分配内存，如使用new或malloc分配的内存。堆内存需要手动释放，否则会导致内存泄露。</p>

<p>全局/静态存储区：存储全局变量和静态变量。全局/静态存储区的内存在程序编译时就已经分配好，且在程序整个运行期间都存在。</p>

<p>常量存储区：存储常量字符串等。该区域的内存在程序编译时就已经分配好，并且内容不可更改。</p>

<p>代码区：存储程序的可执行代码。</p>

<h3 id="多态的实现原理实现方式是什么以及多态的优点特点">多态的实现原理（实现方式）是什么？以及多态的优点（特点）？</h3>
<p>实现方式：多态分为动态多态和静态多态（又称编译期多态，即在系统编译期间就可以确定程序将要执行哪个函数）</p>

<p>其中动态多态是通过虚函数实现的，虚函数是类的成员函数，存在存储虚函数指针的表叫做虚函数表，虚函数表是一个存储类成员虚函数的指针，每个指针都指向调用它的地方，当子类调用虚函数时，就会去虚表里面找自己对应的函数指针，从而实现“谁调用、实现谁”从而实现多态。</p>

<p>静态多态则是通过函数重载（函数名相同，参数不同，两个函数在同一作用域），运算符重载，和重定义（又叫隐藏，指的是在继承关系中，子类实现了一个和父类名字一样的函数，（只关注函数名，和参数与返回值无关）这样的话子类的函数就把父类的同名函数隐藏了。隐藏只与函数名有关，与参数没有关系）来实现的。</p>

<p>优点：加强代码的可扩展性，可替换性，增强程序的灵活性，提高使用效率，简化对应用代码的编写和修改过程。</p>

<h3 id="final标识符的作用">final标识符的作用</h3>
<p>放在类的后面表示该类无法被继承，也就是阻止了从类的继承，放在虚函数后面该虚函数无法被重写，表示阻止虚函数的重载</p>

<h3 id="explicit关键字">explicit关键字</h3>
<p>只能用于修饰只有一个参数的类构造函数（有一个例外就是，当除了第一个参数以外的其他参数都有默认值的时候此关键字依然有效），它的作用是表明该构造函数是显示的，而非隐式的，跟它对应的另一个关键字是implicit，意思是隐藏的，类构造函数默认情况下声明为implicit。作用是防止类构造函数的隐式自动转换。</p>

<p>在<code class="language-plaintext highlighter-rouge">std::vector</code>中，<code class="language-plaintext highlighter-rouge">push_back()</code>和<code class="language-plaintext highlighter-rouge">emplace_back()</code>都用于在末尾添加元素，但它们的实现和适用场景有所不同。</p>

<h3 id="push_back"><code class="language-plaintext highlighter-rouge">push_back()</code></h3>

<ul>
  <li><strong>功能</strong>：将一个元素拷贝或移动到容器的末尾。</li>
  <li><strong>实现方式</strong>：<code class="language-plaintext highlighter-rouge">push_back()</code>会创建一个临时对象（如果传入的是构造参数），然后将该对象拷贝或移动到<code class="language-plaintext highlighter-rouge">vector</code>的末尾。对于已存在的对象传递，是直接拷贝或移动的。</li>
  <li><strong>适用场景</strong>：在需要添加一个已经创建好的对象（例如一个临时变量或函数返回的对象）时使用<code class="language-plaintext highlighter-rouge">push_back()</code>更直观。</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>           <span class="c1">// 拷贝 str</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"world"</span><span class="p">);</span>        <span class="c1">// 创建临时对象并拷贝</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">str</span><span class="p">));</span> <span class="c1">// 移动 str</span>
</code></pre></div></div>

<h3 id="emplace_back"><code class="language-plaintext highlighter-rouge">emplace_back()</code></h3>

<ul>
  <li><strong>功能</strong>：直接在<code class="language-plaintext highlighter-rouge">vector</code>的末尾构造对象，避免不必要的拷贝或移动操作。</li>
  <li><strong>实现方式</strong>：<code class="language-plaintext highlighter-rouge">emplace_back()</code>会将传入的参数直接用于调用对象的构造函数，因此不会额外创建临时对象。这在效率上更高，特别是对于复杂对象来说。</li>
  <li><strong>适用场景</strong>：在需要添加新对象且不希望额外拷贝时，使用<code class="language-plaintext highlighter-rouge">emplace_back()</code>更合适，尤其在构造的过程中可以直接传入参数。</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>    <span class="c1">// 直接构造字符串，无需拷贝</span>
<span class="n">vec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">);</span>    <span class="c1">// 调用 std::string(10, 'a') 构造字符串</span>
</code></pre></div></div>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">push_back()</code></strong>适用于已有对象或简单对象的插入，能更直观表达意图。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">emplace_back()</code></strong>适合在需要构造复杂对象时使用，因为它可以避免临时对象的创建，提高效率。</li>
</ul>

<h3 id="类中static函数是否能声明为虚函数">类中static函数是否能声明为虚函数？</h3>
<p>不能，因为类中的static函数是所有类实例化对象所共有的，没有this指针，而虚函数依靠vptr和vtable来处理，vptr是一个指针，在类中的构造函数中生成，并且只能通过this指针访问，对于静态成员函数来说，他没有this指针，无法访问vptr，因此static函数无法声明为虚函数</p>

<h3 id="为什么存在this指针">为什么存在this指针？</h3>
<p>类和对象中的成员函数存储在公共的代码段，不同的对象调用成员函数时编译器为了知道具体操作的是哪一个对象给每个“非静态的成员函数”增加了一个隐藏的指针参数，让该指针指向当前对象，在函数体中所有成员变量的操作，都是通过这个指针来完成的由编译器自动完成。</p>

<p>C++ 中有四种主要的强制类型转换方式：<code class="language-plaintext highlighter-rouge">static_cast</code>、<code class="language-plaintext highlighter-rouge">dynamic_cast</code>、<code class="language-plaintext highlighter-rouge">const_cast</code> 和 <code class="language-plaintext highlighter-rouge">reinterpret_cast</code>，它们各自有不同的功能和适用场景。以下是每种类型转换的特点和实现原理：</p>

<h3 id="四个类型强制转换">四个类型强制转换</h3>
<h5 id="1-static_cast">1. <code class="language-plaintext highlighter-rouge">static_cast</code></h5>

<ul>
  <li><strong>特点</strong>：用于在编译时执行显式的类型转换。它可以在已知不会引发错误的情况下，用于安全类型转换。
    <ul>
      <li>支持基本数据类型之间的转换，如<code class="language-plaintext highlighter-rouge">int</code>到<code class="language-plaintext highlighter-rouge">float</code>。</li>
      <li>支持指针或引用在类层次结构中的转换，但只能用于已知类型的上下层关系（例如父类到子类的转换）。</li>
      <li>支持 void* 到其他指针类型的转换。</li>
    </ul>
  </li>
  <li><strong>原理</strong>：在编译时执行，转换过程中不会进行运行时检查，因此效率较高，但不适用于多态类型的安全转换。</li>
  <li>
    <p><strong>适用场景</strong>：当确定转换是合法且安全时，如基本类型之间转换、类层次结构中父类指针转换为子类指针（前提是确知转换有效）。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">);</span> <span class="c1">// 浮点转为整数</span>
</code></pre></div>    </div>
  </li>
</ul>

<h5 id="2-dynamic_cast">2. <code class="language-plaintext highlighter-rouge">dynamic_cast</code></h5>

<ul>
  <li><strong>特点</strong>：用于在运行时执行安全的类型转换，主要用于指针或引用之间的转换。只能用于带有虚函数的多态类（即 RTTI，运行时类型识别）。
    <ul>
      <li>如果转换失败，指针类型会返回 <code class="language-plaintext highlighter-rouge">nullptr</code>，引用类型会抛出 <code class="language-plaintext highlighter-rouge">bad_cast</code> 异常。</li>
      <li>只能用于类层次结构中基类和派生类之间的转换。</li>
    </ul>
  </li>
  <li><strong>原理</strong>：依赖于 RTTI 机制，在运行时检查类型安全性，适用于基类指针向派生类指针的转换（即向下转型）。</li>
  <li>
    <p><strong>适用场景</strong>：当需要在类层次结构中安全地进行向下转换，并且类是多态类（带有虚函数表）时。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="p">{}</span> <span class="p">};</span> <span class="c1">// 必须是多态类</span>
<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{};</span>

<span class="n">Base</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">;</span>
<span class="n">Derived</span><span class="o">*</span> <span class="n">d</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="c1">// 转换成功</span>
</code></pre></div>    </div>
  </li>
</ul>

<h5 id="3-const_cast">3. <code class="language-plaintext highlighter-rouge">const_cast</code></h5>

<ul>
  <li><strong>特点</strong>：用于去掉或添加 <code class="language-plaintext highlighter-rouge">const</code> 或 <code class="language-plaintext highlighter-rouge">volatile</code> 修饰符，通常用于处理需要修改 <code class="language-plaintext highlighter-rouge">const</code> 对象的场景。
    <ul>
      <li>只能更改对象的<code class="language-plaintext highlighter-rouge">const</code>或<code class="language-plaintext highlighter-rouge">volatile</code>属性，不能用于其他类型的转换。</li>
    </ul>
  </li>
  <li><strong>原理</strong>：编译时直接更改类型的<code class="language-plaintext highlighter-rouge">const</code>或<code class="language-plaintext highlighter-rouge">volatile</code>修饰，不影响数据在内存中的布局。</li>
  <li>
    <p><strong>适用场景</strong>：当需要在调用接口时移除<code class="language-plaintext highlighter-rouge">const</code>属性，如需要对<code class="language-plaintext highlighter-rouge">const</code>对象进行某些不可更改操作，或需要传递<code class="language-plaintext highlighter-rouge">const</code>对象给非<code class="language-plaintext highlighter-rouge">const</code>函数。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span> <span class="c1">// 去掉 const 修饰</span>
</code></pre></div>    </div>
  </li>
</ul>

<h5 id="4-reinterpret_cast">4. <code class="language-plaintext highlighter-rouge">reinterpret_cast</code></h5>

<ul>
  <li><strong>特点</strong>：用于进行极为底层的、类型上不安全的强制转换。它可以将任何指针类型转换为其他指针类型，或将整数转换为指针类型。
    <ul>
      <li>不同类型的指针之间、整数和指针之间可以相互转换。</li>
      <li>该转换并不更改数据的底层二进制表示。</li>
    </ul>
  </li>
  <li><strong>原理</strong>：直接重新解释内存中的二进制内容，将指针或数据的类型重新解释为目标类型。转换后数据的行为可能无法预测，因此需慎重使用。</li>
  <li>
    <p><strong>适用场景</strong>：当需要进行底层数据操作（如位操作或字节处理）时，或者需要将指针类型和整数类型之间转换时。</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">65</span><span class="p">;</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 将 int* 转为 char*</span>
</code></pre></div>    </div>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th>转换类型</th>
      <th>适用范围</th>
      <th>运行时检查</th>
      <th>主要功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">static_cast</code></td>
      <td>编译时可确定的安全转换</td>
      <td>否</td>
      <td>基本类型转换、类层次结构的向上转换</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">dynamic_cast</code></td>
      <td>类层次结构中的向下转换，适用于多态类型</td>
      <td>是</td>
      <td>多态类的运行时类型检查，确保转换安全</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">const_cast</code></td>
      <td>去掉或添加<code class="language-plaintext highlighter-rouge">const</code>或<code class="language-plaintext highlighter-rouge">volatile</code>修饰</td>
      <td>否</td>
      <td>改变<code class="language-plaintext highlighter-rouge">const</code>或<code class="language-plaintext highlighter-rouge">volatile</code>修饰，主要用于修改<code class="language-plaintext highlighter-rouge">const</code>对象</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">reinterpret_cast</code></td>
      <td>低层次、不安全的类型转换</td>
      <td>否</td>
      <td>直接重新解释数据的二进制表示，适用于指针和整数之间的转换</td>
    </tr>
  </tbody>
</table>

<h5 id="使用建议">使用建议</h5>

<ul>
  <li>优先选择 <strong><code class="language-plaintext highlighter-rouge">static_cast</code></strong> 和 <strong><code class="language-plaintext highlighter-rouge">dynamic_cast</code></strong>，因为它们更安全、用途更清晰。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">const_cast</code></strong> 仅在必要时使用（如函数接口限制）。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">reinterpret_cast</code></strong> 应慎用，避免带来不易预期的错误和不稳定因素。</li>
</ul>

<h3 id="string实现">string实现</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="c1"> // for strlen, strcpy</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">MyString</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">capacity</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="c1">// 默认构造函数</span>
    <span class="n">MyString</span><span class="p">()</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">),</span> <span class="n">len</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">capacity</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

    <span class="c1">// 带参数构造函数</span>
    <span class="n">MyString</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
        <span class="n">capacity</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">capacity</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 拷贝构造函数（深拷贝）</span>
    <span class="n">MyString</span><span class="p">(</span><span class="k">const</span> <span class="n">MyString</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
        <span class="n">capacity</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">capacity</span><span class="p">;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">capacity</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 移动构造函数</span>
    <span class="n">MyString</span><span class="p">(</span><span class="n">MyString</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">),</span> <span class="n">len</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">len</span><span class="p">),</span> <span class="n">capacity</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">other</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">other</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">other</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 析构函数</span>
    <span class="o">~</span><span class="n">MyString</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 赋值运算符重载</span>
    <span class="n">MyString</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">MyString</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">delete</span><span class="p">[]</span> <span class="n">data</span><span class="p">;</span> <span class="c1">// 释放旧的内存</span>

            <span class="n">len</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
            <span class="n">capacity</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">capacity</span><span class="p">;</span>
            <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">capacity</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
            <span class="n">strcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 移动赋值运算符</span>
    <span class="n">MyString</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">MyString</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">delete</span><span class="p">[]</span> <span class="n">data</span><span class="p">;</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
            <span class="n">len</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
            <span class="n">capacity</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">capacity</span><span class="p">;</span>

            <span class="n">other</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
            <span class="n">other</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">other</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 获取字符串长度</span>
    <span class="kt">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 获取容量</span>
    <span class="kt">size_t</span> <span class="n">getCapacity</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">capacity</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 检索字符串中的字符</span>
    <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">"Index out of range"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">"Index out of range"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// 添加字符到末尾</span>
    <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">resize</span><span class="p">(</span><span class="n">capacity</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">capacity</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">data</span><span class="p">[</span><span class="n">len</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
        <span class="n">data</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 追加字符串</span>
    <span class="kt">void</span> <span class="n">append</span><span class="p">(</span><span class="k">const</span> <span class="n">MyString</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">other</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">resize</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">other</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">strcat</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
        <span class="n">len</span> <span class="o">+=</span> <span class="n">other</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 打印字符串</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"(empty)"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="c1">// 重新分配内存</span>
    <span class="kt">void</span> <span class="n">resize</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">new_capacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span><span class="o">*</span> <span class="n">new_data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">new_capacity</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">strcpy</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">data</span><span class="p">;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">new_data</span><span class="p">;</span>
        <span class="n">capacity</span> <span class="o">=</span> <span class="n">new_capacity</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

</code></pre></div></div>

<h3 id="什么是模板的全特化">什么是模板的全特化？</h3>
<p>模板的全特化是在模板的原始定义之外针对某个特定类型，提供模板的特定实现。当我们为一个模板指定了所有模板参数的具体类型时，就是全特化。全特化完全替代了通用模板，对于特定的类型，编译器将使用全特化的版本。</p>

<p>为什么要使用全特化？</p>
<ol>
  <li>定制化特定类型的行为：对于某些特殊类型，需要不同于通用模板的实现。</li>
  <li>优化性能：针对特定类型，提供更高效的实现。</li>
  <li>解决特定类型的特殊需求：处理某些类型无法在通用模板中处理的特殊情况。</li>
</ol>

<h3 id="什么是模板的偏特化">什么是模板的偏特化？</h3>
<p>模板的偏特化是对模板参数进行部分特化，即不需要指定所有模板参数，而是针对某些参数或某些参数特性（如指针、引用、特定的类型模式）进行特化。</p>

<p>为什么要使用偏特化？</p>
<ol>
  <li>更灵活的特化方式：可以针对一类类型进行特化，而不局限于某个具体类型。</li>
  <li>处理类型的某些特征：如指针类型、引用类型、数组类型等。</li>
  <li>提高代码的复用性和可维护性：通过偏特化，可以减少重复代码。</li>
</ol>

<p><strong>偏特化只能用于类模板</strong>，不能直接对函数模板进行偏特化（但可以通过重载实现类似效果）。在偏特化时，需要在模板参数列表和类名中同时体现特化的部分。
编译器会优先选择最匹配的特化版本。如果有多个特化版本可以匹配，可能会导致编译错误，需要避免这种情况。</p>

<h3 id="const关键字">const关键字</h3>

<ol>
  <li>修饰变量：<code class="language-plaintext highlighter-rouge">const</code> 变量的值在初始化后不能被更改。</li>
  <li>修饰指针，可以细分为三种情况：
    <ul>
      <li><strong>指向常量的指针</strong>：指针指向的内容不可更改，但指针本身可以指向其他地址。</li>
      <li><strong>常量指针</strong>：指针本身不可更改，但指向的内容可以更改。</li>
    </ul>
  </li>
  <li>修饰函数参数，可以避免在函数内部修改该参数的值，这在传递引用或指针参数时尤为重要。
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">void</span> <span class="nf">printValue</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
     <span class="c1">// value = 10; // 错误，value 被 const 修饰</span>
     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>修饰类成员函数，表示该函数不会修改类的成员变量。只能在不修改类状态的成员函数上使用 <code class="language-plaintext highlighter-rouge">const</code>，适用于如 get 函数等。</li>
  <li>修饰返回值，在函数返回类型前加 <code class="language-plaintext highlighter-rouge">const</code> 可防止返回值在调用处被修改，例如返回对象的引用时防止被调用方修改。
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">getConstReference</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">static</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
     <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="volatile-关键字">volatile 关键字</h3>
<p><code class="language-plaintext highlighter-rouge">volatile</code> 告知编译器不要对变量进行优化，使程序在每次访问变量时重新从内存中读取数据。这种关键字通常用于特殊情况下，如硬件寄存器访问、多线程共享标志或中断处理程序中，以确保读取到的值是最新的。</p>

<p>例如：在多线程编程中，某些变量可能会被多个线程共享，可能会在一个线程中修改并在另一个线程中读取。如果没有 volatile 关键字，编译器可能会将该变量缓存到寄存器中，导致其他线程无法读取到最新的值。</p>

<h3 id="const-volatile什么意思">const volatile什么意思</h3>
<p><code class="language-plaintext highlighter-rouge">const volatile</code> 修饰的变量是只读的（不能被程序代码修改）并且易变的（编译器不能优化读取操作，必须每次都从内存中读取最新值）。常见于需要频繁读取最新值但不修改的场景，例如硬件寄存器或跨线程共享的只读标志。</p>

<p>例如：在多线程环境中，如果一个共享标志变量仅用于指示某种状态（如停止信号），一个线程可能会设置该标志，而其他线程只能读取该标志的值且不应修改它。将这个变量声明为 <code class="language-plaintext highlighter-rouge">const volatile</code> 可以避免优化，并确保读取到最新的值。</p>

<h3 id="c内存模型堆里面的内部碎片和外部碎片">C++内存模型，堆里面的内部碎片和外部碎片</h3>

<p>在 C++ 中，内存模型描述了程序如何管理和使用内存的布局。通常来说，C++ 内存模型分为以下几个区域：</p>

<ol>
  <li>
    <p><strong>栈区（Stack）</strong>：用于存储局部变量、函数调用时的参数和返回地址等。栈的内存是自动管理的，遵循“后进先出”的原则，即函数结束后栈内的局部变量自动销毁。栈内存分配效率高，但空间有限。</p>
  </li>
  <li>
    <p><strong>堆区（Heap）</strong>：用于动态分配的内存（例如通过 <code class="language-plaintext highlighter-rouge">new</code>、<code class="language-plaintext highlighter-rouge">malloc</code> 等）。堆内存由程序员手动管理，必须显式分配和释放。堆的大小仅受系统内存限制，适用于大数据结构和需要跨函数保留的数据。</p>
  </li>
  <li>
    <p><strong>全局区（静态存储区）</strong>：用于存储全局变量、静态变量和常量字符串，程序在启动时分配，直到程序结束才释放。</p>
  </li>
  <li>
    <p><strong>常量存储区</strong>：存放常量字符串，程序结束后由编译器释放。</p>
  </li>
  <li>
    <p><strong>代码区</strong>：存放程序的机器指令，由操作系统分配，用于存储程序的可执行代码，通常只读。</p>
  </li>
</ol>

<h4 id="堆内存中的内部碎片和外部碎片">堆内存中的内部碎片和外部碎片</h4>

<p>在堆内存中，碎片化是指内存管理系统由于分配和释放不同大小的内存块而导致的空闲内存片段。碎片化分为 <strong>内部碎片</strong> 和 <strong>外部碎片</strong>。</p>

<h5 id="1-内部碎片">1. 内部碎片</h5>

<p><strong>内部碎片</strong>是指分配的内存块中，因分配粒度或对齐的原因，实际使用的内存少于分配的内存，造成内存浪费。例如，当分配一个较小的对象（如 5 字节），但由于内存对齐的要求，分配器可能会为它分配 8 字节，这其中多余的 3 字节就是内部碎片。</p>

<p>内部碎片主要发生在以下情况下：</p>

<ul>
  <li><strong>内存对齐</strong>：为确保内存访问的效率，很多系统要求内存按照特定的字节对齐（如 4 字节、8 字节）。如果请求的内存块不满足对齐要求，分配器会分配比请求更多的内存。</li>
  <li><strong>固定大小的分配单元</strong>：某些分配器使用固定大小的内存块进行分配，如果请求的内存小于这个块的大小，则剩余部分形成内部碎片。</li>
</ul>

<h5 id="2-外部碎片">2. 外部碎片</h5>

<p><strong>外部碎片</strong>是指堆中存在很多小的、相互分散的空闲内存块，但这些内存块彼此不连续，因此无法满足较大的内存分配请求。例如，如果程序频繁分配和释放不同大小的内存块，可能会留下分散的小空闲块。这些空闲块的总和足够大，但因为不连续，导致无法分配较大的内存块。</p>

<p>外部碎片会影响程序性能，降低内存分配效率，可能导致内存不足的假象。堆内存的外部碎片主要通过以下方式产生：</p>

<ul>
  <li><strong>不规则的内存分配与释放</strong>：程序频繁分配和释放不同大小的内存块，导致空闲块分散。</li>
  <li><strong>缺乏内存整理</strong>：一些内存分配器不会自动合并相邻的空闲内存块，从而导致外部碎片。</li>
</ul>

<h3 id="内存碎片的处理方法">内存碎片的处理方法</h3>

<ul>
  <li><strong>内存池</strong>：预分配一定数量的内存块以满足相似大小的内存请求，从而减少内存碎片。</li>
  <li><strong>紧凑分配</strong>：一些内存管理器会自动合并相邻的空闲块，减少外部碎片。</li>
  <li><strong>自定义分配器</strong>：对特定数据结构自定义内存分配器，以便更有效地管理内存分配。</li>
</ul>

<h3 id="一般c的类的memory-layout有哪些成分c的对象在内存上长什么样如果涉及到继承呢">一般C++的类的memory layout有哪些成分，C++的对象在内存上长什么样？如果涉及到继承呢？</h3>
<ol>
  <li><strong>基本类的内存布局</strong>
 一个没有继承关系、虚函数或虚继承的简单 C++ 类的内存布局由以下成分组成：
    <ul>
      <li><strong>成员变量：</strong> 按照声明顺序存储在对象内存布局中，但编译器可能会根据内存对齐要求调整实际顺序。</li>
      <li><strong>对齐填充：</strong> 为了满足内存对齐要求，编译器会在成员变量之间或对象的结尾填充一些字节，以确保对象在内存中对齐。</li>
    </ul>
  </li>
  <li>
    <p><strong>带有虚函数的类的内存布局</strong>
 当一个类包含虚函数时，编译器会在该类的对象布局中添加一个 <strong>虚函数表指针（vptr）</strong>，指向该类的虚函数表（<code class="language-plaintext highlighter-rouge">vtable</code>）。<code class="language-plaintext highlighter-rouge">vtable</code> 是一个指针数组，指向类的虚函数实现。这使得运行时可以通过多态性动态调用不同的函数。在这种情况下，Base 类对象的内存布局会包含以下成分：</p>

    <ul>
      <li>vptr：指向虚函数表的指针，存储在对象的头部或其他位置。</li>
      <li>成员变量：x。
 虚函数表（vtable）则存储在程序的只读区域（常量存储区）中。</li>
    </ul>
  </li>
  <li><strong>带有单继承的类的内存布局</strong>
 在单继承情况下，派生类继承基类的成员变量和 vptr（如果基类有虚函数）。派生类对象的布局如下：
    <ul>
      <li>vptr：如果基类或派生类定义了虚函数，那么 vptr 会在对象中存在。如果基类已有虚函数表，派生类会复用或重写这个 vptr。</li>
      <li>基类成员：继承基类的成员变量，保持基类的布局。</li>
      <li>派生类自己的成员：存储在基类成员之后。</li>
    </ul>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
 <span class="nl">public:</span>
     <span class="kt">double</span> <span class="n">y</span><span class="p">;</span>
     <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func3</span><span class="p">();</span>
 <span class="p">};</span>
</code></pre></div>    </div>
    <p>在这种情况下，Derived 的内存布局包括：</p>

    <ul>
      <li>vptr：指向 Derived 类的 vtable，因为 Derived 覆盖了或增加了虚函数。</li>
      <li>基类成员：继承的 x。</li>
      <li>派生类成员：y。</li>
    </ul>
  </li>
  <li><strong>多重继承的内存布局</strong>
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">class</span> <span class="nc">Base1</span> <span class="p">{</span>
 <span class="nl">public:</span>
     <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
     <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func1</span><span class="p">();</span>
 <span class="p">};</span>

 <span class="k">class</span> <span class="nc">Base2</span> <span class="p">{</span>
 <span class="nl">public:</span>
     <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
     <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func2</span><span class="p">();</span>
 <span class="p">};</span>

 <span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base1</span><span class="p">,</span> <span class="k">public</span> <span class="n">Base2</span> <span class="p">{</span>
 <span class="nl">public:</span>
     <span class="kt">double</span> <span class="n">c</span><span class="p">;</span>
 <span class="p">};</span>
</code></pre></div>    </div>
    <p>在这种情况下，Derived 的布局如下：</p>

    <ul>
      <li>Base1 的 vptr：指向 Base1 的 vtable。</li>
      <li>Base1 的成员：a。</li>
      <li>Base2 的 vptr：指向 Base2 的 vtable。</li>
      <li>Base2 的成员：b。</li>
      <li>Derived 的成员：c。</li>
    </ul>
  </li>
  <li><strong>虚继承的内存布局</strong>
 在虚继承中，派生类会共享基类的一个实例，从而避免多重继承中的菱形继承问题。编译器会为虚继承类添加一个 <strong>虚基类指针（vptr）</strong> 或 <strong>虚基类表指针（vbptr）</strong>，用于定位虚基类在对象内存中的位置。
    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
 <span class="nl">public:</span>
     <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
 <span class="p">};</span>

 <span class="k">class</span> <span class="nc">Derived1</span> <span class="o">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>

 <span class="k">class</span> <span class="nc">Derived2</span> <span class="o">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>

 <span class="k">class</span> <span class="nc">MostDerived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Derived1</span><span class="p">,</span> <span class="k">public</span> <span class="n">Derived2</span> <span class="p">{</span>
     <span class="c1">// ...</span>
 <span class="p">};</span>
</code></pre></div>    </div>
    <p>在这种情况下，MostDerived 的布局可能包含：</p>

    <ul>
      <li>Derived1的 vfptr</li>
      <li>Derived1 的 vbptr：用于指向 Base 类的虚基类位置。</li>
      <li>Derived1的类成员</li>
      <li>Derived2的 vfptr</li>
      <li>Derived2 的 vbptr：用于指向 Base 类的虚基类位置。</li>
      <li>Derived2的类成员</li>
      <li>Base vfptr</li>
      <li>虚基类 Base：Base 的实例在内存中只有一份，且通过 vbptr 进行定位。</li>
    </ul>
  </li>
</ol>

<h3 id="虚继承">虚继承</h3>
<p>虚继承（Virtual Inheritance）是一种特殊的继承方式，主要用于解决多重继承中的菱形继承（或称钻石继承）问题。菱形继承问题通常会导致重复继承基类成员，造成 <strong>冗余和二义性</strong>，而虚继承可以确保派生类共享基类的唯一实例。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived1</span> <span class="o">:</span> <span class="k">public</span> <span class="k">virtual</span> <span class="n">Base</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">Derived2</span> <span class="o">:</span> <span class="k">public</span> <span class="k">virtual</span> <span class="n">Base</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>

<span class="k">class</span> <span class="nc">MostDerived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Derived1</span><span class="p">,</span> <span class="k">public</span> <span class="n">Derived2</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
</code></pre></div></div>

<p>在启用虚继承后，C++ 编译器会在 Derived1 和 Derived2 中添加一个虚基类表指针（vbptr），指向 Base 的唯一实例位置。在实例化 MostDerived 时，编译器会根据虚基类表找到并共享 Base 的实例。</p>

<p>因此，MostDerived 的内存布局可能如下：</p>

<ul>
  <li>Derived1 的 vbptr：用于指向 Base 的唯一实例。</li>
  <li>Derived2 的 vbptr：用于指向 Base 的唯一实例。</li>
  <li>唯一的 Base 实例。</li>
  <li>MostDerived 自己的成员（如果有）</li>
</ul>

<h3 id="如果一个类继承了有虚函数的类父类会存在在子类中吗">如果一个类继承了有虚函数的类，父类会存在在子类中吗</h3>
<p>会的，派生类对象中包含基类的数据成员，因此在派生类对象中基类的部分会存在。</p>

<h3 id="父类转子类安全吗子类转父类呢">父类转子类安全吗？子类转父类呢？</h3>
<p><strong>基类指针或引用转换为派生类指针或引用通常是不安全的</strong>，因为基类对象不一定包含派生类的所有成员。如果直接将一个基类对象的指针或引用转换为派生类类型，并尝试访问派生类的成员，可能会导致未定义行为。</p>

<p>如果基类指针或引用实际上指向的是一个派生类对象，则可以通过 <code class="language-plaintext highlighter-rouge">dynamic_cast</code> 进行安全的转换。<code class="language-plaintext highlighter-rouge">dynamic_cast</code> 会在运行时检查类型，如果转换失败会返回 <code class="language-plaintext highlighter-rouge">nullptr</code>（对于指针）或抛出 <code class="language-plaintext highlighter-rouge">bad_cast</code> 异常（对于引用）。</p>

<p><strong>将派生类指针或引用转换为基类指针或引用通常是安全的</strong>。因为派生类包含基类的所有成员，因此将派生类对象视为基类对象不会导致内存或成员访问问题。这种转换可以通过 <strong>隐式转换</strong> 或 <strong>static_cast</strong> 安全地完成。</p>
<h3 id="假设是64位的机器一个空的类占多大内存如果这个类包含一个虚函数呢如果有一个类继承了空类大小是多少分类讨论">假设是64位的机器，一个空的类占多大内存，如果这个类包含一个虚函数呢？如果有一个类继承了空类，大小是多少（分类讨论）？</h3>

<ul>
  <li><strong>空类</strong>：通常占 <code class="language-plaintext highlighter-rouge">1</code> 字节。</li>
  <li><strong>含虚函数的空类</strong>：占 <code class="language-plaintext highlighter-rouge">8</code> 字节（在 64 位系统上，为虚函数表指针大小）。</li>
  <li><strong>继承自空类的类</strong>：
    <ul>
      <li>如果没有额外成员，通常应用空基类优化，占 <code class="language-plaintext highlighter-rouge">1</code> 字节。</li>
      <li>如果包含其他成员，则仅占成员的大小（空基类不增加额外空间）。</li>
    </ul>
  </li>
  <li><strong>继承自含虚函数的空类的类</strong>：大小至少为 <code class="language-plaintext highlighter-rouge">8</code> 字节（包含 <code class="language-plaintext highlighter-rouge">vptr</code>），即使派生类本身没有增加成员。</li>
  <li>
    <h3 id="虚表里除了可能有虚函数还可能有什么">虚表里除了可能有虚函数，还可能有什么？</h3>
    <ol>
      <li>虚表通常包含一个指向类型信息的指针，用于支持 typeid 和 dynamic_cast 等操作。这个指针指向的结构包含了当前类的类型信息，以便在运行时能够识别对象的实际类型。</li>
      <li>在涉及 <strong>虚继承</strong> 的多重继承中，虚表还可能包含 虚基类偏移指针，用于支持虚基类的定位。当派生类通过虚继承的方式继承基类时，虚基类在对象布局中的位置并不是固定的，因为不同的派生路径会共享同一个虚基类实例。</li>
    </ol>
  </li>
</ul>

<h3 id="如果一个函数是成员模板函数可以被声明为虚函数吗">如果一个函数是成员模板函数，可以被声明为虚函数吗？</h3>
<p>在 C++ 中，<strong>成员模板函数不能被声明为虚函数</strong>。这是因为模板函数的机制和虚函数的机制在设计和实现上存在冲突。</p>

<ol>
  <li>
    <p><strong>模板函数的编译时多态性</strong>：<br />
模板函数是通过 <strong>编译时多态</strong> 实现的。编译器会在编译期间根据模板的具体类型生成函数的代码，即模板函数的实例化发生在编译时。这意味着，模板函数在编译时会根据使用的类型参数生成特定版本的代码。</p>
  </li>
  <li>
    <p><strong>虚函数的运行时多态性</strong>：<br />
虚函数依赖于 <strong>运行时多态</strong>，通过虚函数表（vtable）在运行时动态绑定函数。这要求在程序执行时通过虚表指针（<code class="language-plaintext highlighter-rouge">vptr</code>）来调用合适的虚函数实现。</p>
  </li>
</ol>

<p>由于模板函数在编译时实例化，其生成的具体函数可能是无限多种类型的组合，无法在虚表中预先创建一个模板函数的实例。因此，C++ 标准不允许将模板成员函数声明为虚函数。</p>

<h3 id="虚函数可以内联吗">虚函数可以内联吗？</h3>
<p>在 C++ 中，<strong>虚函数可以被声明为内联函数</strong>，但是在实际调用中是否会被内联展开，<strong>取决于编译器是否能够在编译时确定具体的调用目标</strong>。虚函数的运行时多态性机制使得它们通常不符合内联的条件，但在特定情况下，虚函数可以被内联。</p>

<ol>
  <li>
    <p><strong>虚函数的运行时多态性</strong>：<br />
虚函数是通过虚函数表（vtable）实现运行时多态性的，在调用时根据对象的实际类型选择具体的函数实现。这种机制通常需要在运行时确定调用的具体实现，因此通常通过基类指针或引用调用虚函数时，编译器在编译期无法确定具体的实现。</p>
  </li>
  <li>
    <p><strong>内联的编译时展开</strong>：<br />
内联函数的目的是在编译时直接用函数体替换函数调用，从而避免函数调用的开销（如栈帧管理和参数传递）。这要求编译器在编译期就知道函数的具体实现，以便将其展开。</p>
  </li>
</ol>

<p>虚函数的运行时多态特性和内联函数的编译时展开机制存在矛盾，因此虚函数通常难以被内联。</p>

<ul>
  <li><strong>虚函数可以声明为内联</strong>，但实际内联展开取决于编译器的判断。</li>
  <li>如果通过具体对象（非指针或引用）调用虚函数，编译器可能会内联。</li>
  <li>非多态调用（例如派生类中直接调用基类的虚函数）也可能被内联。</li>
  <li>典型的多态调用（通过基类指针或引用调用虚函数）通常无法内联，因为编译器在编译期无法确定具体实现。
    <h3 id="optional取size是多大">optional<bool>取size是多大？</bool></h3>
  </li>
</ul>

<h3 id="描述一下c编译的整个过程">描述一下C++编译的整个过程</h3>

<h3 id="如果头文件定义了函数源文件不实现会在哪个环节报错如果构建的是静态库会报错吗">如果头文件定义了函数，源文件不实现，会在哪个环节报错？如果构建的是静态库，会报错吗？</h3>

<h3 id="对静态库和动态库的理解">对静态库和动态库的理解</h3>

<h3 id="一个shared_ptr大小是多大unique_ptr呢不同智能指针性能上有什么区别如果只是用指针解引用性能上有区别吗">一个shared_ptr大小是多大，unique_ptr呢？不同智能指针性能上有什么区别？如果只是用指针解引用，性能上有区别吗？</h3>

<h3 id="手动实现shared_ptr和unique_ptr">手动实现shared_ptr和unique_ptr</h3>

<h3 id="c多线程中常用的mutex是怎么实现的和自旋锁有什么区别">C++多线程中常用的mutex是怎么实现的，和自旋锁有什么区别？</h3>

<h3 id="atomic内部实现是有锁还是没锁的所有的原子变量都没锁吗对于原子变量的memory-order有了解吗">atomic内部实现？是有锁还是没锁的？所有的原子变量都没锁吗？对于原子变量的memory order有了解吗？</h3>

<h3 id="无锁队列">无锁队列</h3>

<h3 id="stl容器的线程安全">STL容器的线程安全</h3>

<h3 id="红黑树和哈希表的区别时间和空间的性能上">红黑树和哈希表的区别（时间和空间的性能上）</h3>

<h3 id="在交易场景中哈希表和红黑树各自应当在什么时候使用deque和vector有哪些使用场景">在交易场景中，哈希表和红黑树各自应当在什么时候使用？deque和vector有哪些使用场景</h3>

<h3 id="实现一个订单簿系统有挂单吃单撤单的功能">实现一个订单簿系统，有挂单吃单撤单的功能</h3>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="C++" /><summary type="html"><![CDATA[内存分区]]></summary></entry><entry><title type="html">计算机系统、网络面经</title><link href="http://localhost:4000/2024/10/21/CS/" rel="alternate" type="text/html" title="计算机系统、网络面经" /><published>2024-10-21T10:00:00+08:00</published><updated>2024-10-21T10:00:00+08:00</updated><id>http://localhost:4000/2024/10/21/CS</id><content type="html" xml:base="http://localhost:4000/2024/10/21/CS/"><![CDATA[<h3 id="描述一下cpu怎么从内存中获取数据的要经过哪些模块">描述一下cpu怎么从内存中获取数据的，要经过哪些模块？</h3>

<h3 id="介绍一下cpu中的cache">介绍一下cpu中的cache</h3>

<h3 id="不同层级的cache现实中常见的速度">不同层级的cache现实中常见的速度</h3>

<h3 id="通过什么方式写出对cache更友好的代码对于数组某些特定的长度会使读取变慢吗">通过什么方式写出对cache更友好的代码？对于数组，某些特定的长度会使读取变慢吗？</h3>

<h3 id="虚拟内存是什么好处是什么每个页的大小一般是多少">虚拟内存是什么？好处是什么？每个页的大小一般是多少？</h3>

<h3 id="线程和进程的区别-它们在linux的实现上的区别">线程和进程的区别？ 它们在Linux的实现上的区别？</h3>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="C++" /><summary type="html"><![CDATA[描述一下cpu怎么从内存中获取数据的，要经过哪些模块？]]></summary></entry><entry><title type="html">其他面经</title><link href="http://localhost:4000/2024/10/21/other/" rel="alternate" type="text/html" title="其他面经" /><published>2024-10-21T10:00:00+08:00</published><updated>2024-10-21T10:00:00+08:00</updated><id>http://localhost:4000/2024/10/21/other</id><content type="html" xml:base="http://localhost:4000/2024/10/21/other/"><![CDATA[<h3 id="c性能检测用过什么工具">C++性能检测用过什么工具</h3>

<h3 id="gdb看backtrace和切换线程">gdb看backtrace和切换线程</h3>

<h3 id="全部加载到内存太大了怎么办">全部加载到内存太大了怎么办</h3>

<h3 id="数据迁移怎么保证一致性">数据迁移怎么保证一致性</h3>

<h3 id="新旧数据不兼容怎么办">新旧数据不兼容怎么办</h3>

<h3 id="有哪些加速计算的方法">有哪些加速计算的方法</h3>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="C++" /><summary type="html"><![CDATA[C++性能检测用过什么工具]]></summary></entry><entry><title type="html">C++多线程</title><link href="http://localhost:4000/2024/10/20/Thread/" rel="alternate" type="text/html" title="C++多线程" /><published>2024-10-20T10:00:00+08:00</published><updated>2024-10-20T10:00:00+08:00</updated><id>http://localhost:4000/2024/10/20/Thread</id><content type="html" xml:base="http://localhost:4000/2024/10/20/Thread/"><![CDATA[<p>C++的<code class="language-plaintext highlighter-rouge">atomic</code>库和<code class="language-plaintext highlighter-rouge">thread</code>库是多线程编程中常用的库，提供了安全的并发操作支持。</p>

<h3 id="1-thread库">1. <code class="language-plaintext highlighter-rouge">thread</code>库</h3>

<p><a href="https://blog.csdn.net/QLeelq/article/details/115747717">This link</a></p>

<h3 id="2-atomic库">2. <code class="language-plaintext highlighter-rouge">atomic</code>库</h3>

<p><code class="language-plaintext highlighter-rouge">&lt;atomic&gt;</code>库主要提供了原子操作（atomic operations），即无需锁机制即可实现的线程安全操作。这对提高多线程环境下的数据一致性和性能很有帮助。</p>

<h4 id="常见的原子类型">常见的原子类型</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">std::atomic&lt;T&gt;</code></strong>：提供一种基础原子类型，<code class="language-plaintext highlighter-rouge">T</code>可以是整型、指针等。常见类型如<code class="language-plaintext highlighter-rouge">std::atomic&lt;int&gt;</code>、<code class="language-plaintext highlighter-rouge">std::atomic&lt;bool&gt;</code>等。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">std::atomic_flag</code></strong>：最简单的原子布尔类型，适用于实现简单的锁（如自旋锁）。</li>
</ul>

<h4 id="原子操作的基本方法">原子操作的基本方法</h4>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">store(value)</code></strong>：原子地存储一个值。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">load()</code></strong>：原子地加载一个值。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">exchange(value)</code></strong>：原子地将变量的值设置为<code class="language-plaintext highlighter-rouge">value</code>，并返回先前的值。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">compare_exchange_strong(expected, desired)</code></strong> 和 <strong><code class="language-plaintext highlighter-rouge">compare_exchange_weak(expected, desired)</code></strong>：原子比较并交换操作，根据当前值与<code class="language-plaintext highlighter-rouge">expected</code>是否相等决定是否替换为<code class="language-plaintext highlighter-rouge">desired</code>。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">fetch_add(value)</code></strong>、<strong><code class="language-plaintext highlighter-rouge">fetch_sub(value)</code></strong>、<strong><code class="language-plaintext highlighter-rouge">fetch_or(value)</code></strong>等：执行加、减、或等操作并返回旧值。</li>
</ul>

<h4 id="原子变量的示例">原子变量的示例</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">counter</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">increment</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">counter</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 原子增加操作</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">increment</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">increment</span><span class="p">);</span>

    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Final counter value: "</span> <span class="o">&lt;&lt;</span> <span class="n">counter</span><span class="p">.</span><span class="n">load</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="多线程" /><summary type="html"><![CDATA[C++的atomic库和thread库是多线程编程中常用的库，提供了安全的并发操作支持。]]></summary></entry><entry><title type="html">算法和c++类面经</title><link href="http://localhost:4000/2024/10/11/Problem/" rel="alternate" type="text/html" title="算法和c++类面经" /><published>2024-10-11T10:00:00+08:00</published><updated>2024-10-11T10:00:00+08:00</updated><id>http://localhost:4000/2024/10/11/Problem</id><content type="html" xml:base="http://localhost:4000/2024/10/11/Problem/"><![CDATA[<h3 id="改进以下类">改进以下类</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">MyStruct</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">MyClass</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">MyClass</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MyStruct</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">_val</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">_val</span><span class="p">)</span> <span class="p">{};</span>
<span class="nl">protected:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MyStruct</span><span class="o">&gt;</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>有两处要修改，一个内存对齐，把b放最前面；另外一个是<code class="language-plaintext highlighter-rouge">val(_val)</code>改为<code class="language-plaintext highlighter-rouge">val(std::move(_val))</code></p>

<h3 id="vector的resize和reserve的区别">vector的resize和reserve的区别</h3>

<ol>
  <li>reserve() 函数用于预先分配一定数量的内存空间，以容纳指定数量的元素，但并不改变 vector 的实际大小（即元素数量）。
 仅影响容量（capacity），不影响大小（size）。不会初始化元素，也不会调用元素的构造函数。
 如果 new_cap 小于等于当前容量，则 reserve() 不做任何操作。主要用于优化性能，减少因多次动态分配内存导致的开销。</li>
  <li>resize() 函数用于改变 vector 的大小（size），即元素的数量。根据新的大小，vector 会增加或减少元素。
 当新的大小大于当前大小时：vector 会增加新的元素，并对新元素进行默认初始化（或使用提供的 value 初始化）。如果新的大小超过当前容量（capacity），vector 会重新分配内存。
 当新的大小小于当前大小时：vector 会删除多余的元素，调用它们的析构函数。
 可能会改变容量，如果新的大小超过当前容量，vector 会自动扩容：如果 vector 之前已经包含元素，需要将这些元素从旧的内存区域移动或复制到新的内存区域。对于支持移动语义的元素类型（即具有移动构造函数），元素将被移动到新内存区域。如果元素类型不支持移动构造函数，但支持复制构造函数，元素将被复制到新内存区域。在成功分配新内存并移动/复制元素后，vector 会释放旧的内存空间。</li>
</ol>

<h3 id="题1">题1</h3>

<p>Point是两个浮点数pnl,drawdown的tuple，A是一个包含N个Point的List，求出所有处于efficient frontier上的Point， Point x处于efficient frontier上当且仅当A中不存在其他的Point y使得y.pnl &gt; x.pnl 并且 y.drawdown &lt; x.drawdown.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">pnl</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">drawdown</span><span class="p">;</span>
    <span class="n">Point</span><span class="p">(</span><span class="kt">double</span> <span class="n">p</span><span class="p">,</span> <span class="kt">double</span> <span class="n">d</span><span class="p">)</span> <span class="o">:</span> <span class="n">pnl</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">drawdown</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">// 比较函数，用于排序</span>
<span class="kt">bool</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">pnl</span> <span class="o">!=</span> <span class="n">b</span><span class="p">.</span><span class="n">pnl</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">pnl</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">pnl</span><span class="p">;</span> <span class="c1">// pnl 从大到小排序</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">drawdown</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">drawdown</span><span class="p">;</span> <span class="c1">// drawdown 从小到大排序</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">findEfficientFrontier</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;&amp;</span> <span class="n">points</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 复制一份数据，避免修改原始数据</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">sorted_points</span> <span class="o">=</span> <span class="n">points</span><span class="p">;</span>

    <span class="c1">// 按照定义的规则排序</span>
    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">sorted_points</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">sorted_points</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">compare</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">efficient_frontier</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">min_drawdown</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">infinity</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">point</span> <span class="o">:</span> <span class="n">sorted_points</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">point</span><span class="p">.</span><span class="n">drawdown</span> <span class="o">&lt;</span> <span class="n">min_drawdown</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">efficient_frontier</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">point</span><span class="p">);</span>
            <span class="n">min_drawdown</span> <span class="o">=</span> <span class="n">point</span><span class="p">.</span><span class="n">drawdown</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">efficient_frontier</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="最小子序和">最小子序和</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">MaxSubsequenceSum</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ThisSum</span><span class="p">,</span> <span class="n">MaxSum</span><span class="p">;</span>
    <span class="n">ThisSum</span> <span class="o">=</span> <span class="n">MaxSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span> 
        <span class="n">ThisSum</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="n">MaxSum</span> <span class="o">&gt;</span> <span class="n">ThisSum</span><span class="p">)</span>
            <span class="n">MaxSum</span> <span class="o">=</span> <span class="n">ThisSum</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">ThisSum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">ThisSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">MaxSum</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<h3 id="最大子序列乘积">最大子序列乘积</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span> <span class="nf">maxProduct</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">max_ending_here</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">min_ending_here</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">max_so_far</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">temp_max</span> <span class="o">=</span> <span class="n">max_ending_here</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">temp_min</span> <span class="o">=</span> <span class="n">min_ending_here</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">temp_max</span><span class="p">,</span> <span class="n">temp_min</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">max_ending_here</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">temp_max</span> <span class="o">*</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">min_ending_here</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">temp_min</span> <span class="o">*</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

        <span class="n">max_so_far</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max_so_far</span><span class="p">,</span> <span class="n">max_ending_here</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">max_so_far</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="面经" /><summary type="html"><![CDATA[改进以下类]]></summary></entry><entry><title type="html">数学题目类面经</title><link href="http://localhost:4000/2024/10/10/Problem2/" rel="alternate" type="text/html" title="数学题目类面经" /><published>2024-10-10T10:00:00+08:00</published><updated>2024-10-10T10:00:00+08:00</updated><id>http://localhost:4000/2024/10/10/Problem2</id><content type="html" xml:base="http://localhost:4000/2024/10/10/Problem2/"><![CDATA[<h3 id="题1">题1</h3>
<p>两个人抛硬币，正面为H，反面为T每个人可以选择一个长度为3的序列，如果抛到该序列则胜利，如果A选择了HTH序列，B该选择什么序列保证自己的胜率最高。</p>

<p>看绿皮书Markov链</p>

<h3 id="题2">题2</h3>

<p>n个学生围成一圈，每个人有若干个糖果，接下来按照以下步骤重复分配：</p>
<ol>
  <li>如果有人有奇数个糖果，则会从老师那里额外拿到一个糖果；</li>
  <li>然后所有人将自己一半数量的糖果给左侧的人；
证明：有限步之后每个人的糖果数量是相同的。</li>
</ol>

<h3 id="题3">题3</h3>

<p>有10000个硬币，全部抛起来后，记正面朝上的个数为X，求X=5000的概率（一位有效数字即可）</p>

<p>这是一个二项分布n=10000,p=0.5
当n很大时可以近似于正态分布，$\mu = np = 5000, \sigma^2 = np(1-p) = 2500.$</p>

<p>再将X标准化$Z= \frac{X-\mu}{\sigma} \sim N(0,1)$
$P(4999.5&lt; X&lt; 5000.5) = \Phi(0.01)-\Phi(-0.01) = 0.5040−0.4960=0.0080$</p>

<h3 id="题4">题4</h3>
<p>给出以下问题的解析解：</p>
<ol>
  <li>一个n位线性字符串，每一位都是0或1，求不存在相邻的1的字符串的个数。</li>
  <li>一个n为环形字符串，每一位都是0或1，求不存在相邻的1的字符串的个数。</li>
</ol>

<h3 id="题5">题5</h3>
<p>有N个石头，每个人可以拿若干个石头，第一个人不能全拿光，后面的人不能拿的比前面的人多，请问N什么时候先手必胜，什么时候后手必胜。</p>

<p>分为奇数，2m,4m,其中m为奇数，还有2的幂次。</p>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="面经" /><summary type="html"><![CDATA[题1 两个人抛硬币，正面为H，反面为T每个人可以选择一个长度为3的序列，如果抛到该序列则胜利，如果A选择了HTH序列，B该选择什么序列保证自己的胜率最高。]]></summary></entry><entry><title type="html">概率论:随机变量（绿皮书+额外补充）</title><link href="http://localhost:4000/2024/09/26/Probability2/" rel="alternate" type="text/html" title="概率论:随机变量（绿皮书+额外补充）" /><published>2024-09-26T10:00:00+08:00</published><updated>2024-09-26T10:00:00+08:00</updated><id>http://localhost:4000/2024/09/26/Probability2</id><content type="html" xml:base="http://localhost:4000/2024/09/26/Probability2/"><![CDATA[<h1 id="一元随机变量与分布函数">一元随机变量与分布函数</h1>

<h2 id="离散型随机变量">离散型随机变量</h2>

<ol>
  <li>0-1分布：$P(X=0)=p,P(X=1)=1-p$.</li>
  <li>二项分布：X可看做n个0-1分布重复独立试验，试验成功的次数，$P(X=k) = C_n^kp^k(1-p)^{n-k}$，记作$X \sim B(n,p).$</li>
  <li>泊松分布：$P(X=k) = \frac{e^{-\lambda}\lambda^k}{k!}$,记作$X \sim P(\lambda)$.</li>
  <li>超几何分布：$P(X=k)=\frac{C_a^kC_b^{n-k}}{C_N^n}$，记作$X\sim H(n,a,N)$，就是N个球，a个红球b个白球，不放回取n个，X为红球的个数。</li>
  <li>几何分布：$P(X=k)=p(1-p)^{k-1}$，独立重复Bernoulli试验，第k次首次成功的概率。</li>
  <li>负二项分布：$P(X=k)=C_{k-1}^{r-1}(1-p)^{kr}p^r$，试验进行到出现r次成功才停止，X为饰演的次数。</li>
</ol>

<p>可以证明当n足够大，p足够小，且np保持适当大小时，$B(n,p)$可以用$P(np)$近似表述。</p>

<h2 id="概率分布函数">概率分布函数</h2>

<p>概率分布函数定义为$F(x) = P(X\leq x)$，具有以下性质：</p>
<ol>
  <li>$P(x_1\leq X \leq x_2) = F(x_2) - F(x_1) + P(X=x_1)$</li>
  <li>$F(x)$单调不减</li>
  <li>$0\leq F(x) \leq 1, \lim_{a\rightarrow -\infty}F(a) = 0, \lim_{a\rightarrow \infty}F(a) = 1.$</li>
  <li>$F(x)$右连续，离散型的$F(x)$没有左连续。</li>
</ol>

<h2 id="连续型随机变量">连续型随机变量</h2>

<p>如果存在一个非负实函数$f(x)$满足$F(x)=\int_{-\infty}^x f(t)dt$，则称X为连续型随机变量，$f(x)$为概率密度函数，具有以下性质：</p>
<ol>
  <li>$f(x)\geq 0$</li>
  <li>$\int_{-\infty}^{\infty}f(t)dt = 1$</li>
  <li>$\forall x_1&lt;x_2, P(x_1\leq X\leq x_2) = \int_{x_1}^{x_2} f(t)dt$</li>
  <li>在$f(x)$的连续点处，$F’(x)=f(x)$</li>
  <li>$\forall a, P(X=a) = 0.$</li>
</ol>

<p>常见的连续型随机变量：</p>
<ol>
  <li>均匀分布：$f(x)=\begin{cases}
 \frac{1}{b-a}, x\in(a,b) <br />
 0, 其他
 \end{cases}$，记作$X\sim U(a,b).$
 $P(c&lt;X&lt;c+l) = \frac{l}{b-a}, F(x)=\begin{cases}
     0, x&lt;a \ \frac{x-a}{b-a}, a\leq x &lt; b <br />
     1, x\geq b
 \end{cases}$</li>
  <li>
    <p>指数分布：$f(x)= \begin{cases}
 \lambda e^{-\lambda x}, x&gt; 0 <br />
 0, x\leq 0
 \end{cases}$，记作$X\sim E(\lambda).$
 $F(x) =\int_{-\infty}^x f(t)dt = \begin{cases}
     1-e^{-\lambda x}, x&gt;0 \ 0, x\leq 0
 \end{cases}$</p>

    <p>指数分布最重要的性质是无记忆性：$P(X&gt;t_0+t|X&gt;t_0) = \frac{P(X&gt;t_0+t)}{P(X&gt;t_0)} = e^{-\lambda t} = P(X&gt;t)$,即$P(X&gt;t_0+t) = P(X&gt;t_0)P(X&gt;t)$.可以联想到某产品的正常使用时长。
 类似的无记忆性还有几何分布：$P(X-m=n)=P(X=m)P(X=n)$，可以联想到抛硬币。</p>
  </li>
  <li>正态分布：$f(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{\frac{-(x-\mu)^2}{2\sigma^2}}, |x| &lt; +\infty,\sigma&gt;0,|\mu|&lt;+\infty$，记作$X\sim N(\mu,\sigma^2)$服从参数为$(\mu,\sigma)$的正态分布。
 （补充：$\int_{-\infty}^{+\infty}e^{-x^2}dx=\sqrt{\pi}.$）
 正态分布具有以下性质：
    <ol>
      <li>$f(x)$关于$x=\mu$对称</li>
      <li>$ \max f(x) = f(\mu) = \frac{1}{\sqrt{2\pi}\sigma}$</li>
      <li>$ \lim_{|x-\mu|\rightarrow \infty} f(x) = 0$</li>
    </ol>

    <p>当$\mu=0,\sigma=1$的时候称为标准正态分布，密度函数为$\varphi(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}$,分布函数为$\varPhi(x) = \int_{-\infty}^x \frac{1}{\sqrt{2\pi}}e^{-\frac{t^2}{2}}dt$，具有性质：</p>
    <ol>
      <li>$\varPhi(-x) = 1-\varPhi(x)$</li>
      <li>当$X\sim N(\mu,\sigma^2)$时，$\frac{X-\mu}{\sigma} \sim N(0,1) \Rightarrow P(a&lt;x&lt;b) = \varPhi(\frac{b-\mu}{\sigma})-\varPhi(\frac{a-\mu}{\sigma})$</li>
    </ol>
  </li>
</ol>

<h2 id="一维随机变量函数的分布">一维随机变量函数的分布</h2>

<p>若X分布已知，Y=g(X).</p>
<ol>
  <li>当Y是离散型时，找到${Y=y_k}$的等价事件${X\in D_k}$，则有$P(Y=y_k) = P(X\in D_k)$.</li>
  <li>当Y是连续型时同样可以求出分布函数$F_Y$，求导获得$f_Y$.</li>
</ol>

<p><strong>如果$X$为连续型，密度函数为$f_X(x),\ y=g(X)$，如果$y=g(X)$严格单增(减)，记$y=g(x)$的反函数为$x=h(y)$，则有</strong></p>

\[f_Y(y) = \begin{cases}
    f_X(h(y))\|h'(y)\|, y\in D \\
    0, y\notin D
\end{cases}, D为y=g(x)的值域.\]

<p><strong>1. $X\sim N(\mu,\sigma)$，求$aX+b$的密度函数：</strong>
$y=g(X)=aX+b \Rightarrow x = h(y) = \frac{y-b}{a}$,
$h’(y)=\frac{1}{a} \Rightarrow f_Y(y) = \frac{1}{|a|}f_X(\frac{y-b}{a}).$</p>

<p><strong>2. $X\sim U(0,\pi),Y=\sin(x)$，求$f_Y(y)$：</strong>
 当$0&lt; y \leq 1, F_Y(y)=P(Y\leq y) = P(X\in[0,\arcsin y]\cup [\pi-\arcsin y,\pi]) = \frac{2\arcsin y}{\pi}$
 因此$f_Y(y)=\begin{cases}
    \frac{2}{\pi} \frac{1}{\sqrt{1-y^2}}, 0 &lt; y \leq 1<br />
    0, 其他
 \end{cases}$
（补充：$(\arccos x)’ = -\frac{1}{\sqrt{1-x^2}}, (\arctan x)’ = \frac{1}{1+x^2}.$）</p>

<p><strong>有了连续型随机变量后可以去证明$P(AB)=0$并不能证明AB互斥，比如在$(0,1)$上取值，A为(0,0.5],B为[0.5,1).</strong></p>

<h1 id="多元随机变量及其分布">多元随机变量及其分布</h1>

<h2 id="二元离散型随机变量">二元离散型随机变量</h2>

<ol>
  <li>联合分布律：$P(X=x_i,Y=y_j) = p_{ij}, \sum_{i,j}p_{ij}=1, p_{ij}\geq 0.$</li>
  <li>
    <p>边际分布：$p_{i\cdot}=\sum_{j}p_{ij} = P(X=x_i), p_{\cdot j} = \sum_i p_{ij} = P(Y=y_j).$</p>
  </li>
  <li>条件分布：$P(X=x_i | Y=y_j) = \frac{p_{ij}}{p_{\cdot j}}$,
 P(Y=y_j | X=x_i) = \frac{p_{ij}}{p_{i\cdot}}.$</li>
</ol>

<h2 id="分布函数">分布函数</h2>

<ol>
  <li>联合分布函数：$F(x,y) = P(X\leq x, Y \leq y)$，有性质：
    <ol>
      <li>$F(x,y)$单调不减</li>
      <li>$0\leq F(x,y) \leq 1, F(x,-\infty) = F(-\infty,y) = 0, F(+\infty,+\infty) = 1.$</li>
      <li>$F(x,y)$关于x或y右连续</li>
      <li>$P(x_1&lt;X\leq x_2, y_1 &lt; Y \leq y_2) = F(x_2,y_2)- F(x_1,y_2) -F(x_2,y_1)+F(x_1,y_1).$</li>
    </ol>
  </li>
  <li>边际分布函数：$F_X(x) = P(X\leq x) = F(x,+\infty), F_Y(y)= F(+\infty,y).</li>
  <li>条件分布函数：
    <ol>
      <li>离散型：$F_{Y|X}(y|x_i) = P(Y\leq y| X=x_i)$</li>
      <li>连续型：$F_{Y|X}(y|x) = \lim_{\delta\rightarrow 0^+} P(Y\leq y| x &lt; X \leq x+\delta)$</li>
    </ol>
  </li>
</ol>

<h2 id="连续型随机变量-1">连续型随机变量</h2>

<ol>
  <li>$F(x,y) =\int_{-\infty}^x\int_{-\infty}^y f(u,v) dudv$，$f(x,y)$称为联合概率密度函数，性质有：
    <ol>
      <li>$f(x,y)\geq 0$</li>
      <li>$\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty} f(x,y) dxdy = F(+\infty,+\infty) =1$</li>
      <li>在$f(x,y)$连续点上有$\frac{\partial^2F}{\partial x\partial y} = f(x,y).$</li>
      <li>$P((X,Y)\in D) = \int\int_D f(x,y) dxdy.$</li>
    </ol>
  </li>
  <li>边际概率密度函数：$F_X(x) = P(X\leq x) = \int_{-\infty}^x[\int_{-\infty}^{+\infty}f(x,y)dy]dx \Rightarrow f_X(x) = \int_{-\infty}^{\infty}f(x,y)dy.$
 同理 $f_Y(y) = \int_{-\infty}^{+\infty}f(x,y)dx.$</li>
  <li>条件分布：$F_{Y|X}(y|x) = \lim_{\delta\rightarrow 0^+} P(Y\leq y| x &lt; X \leq x+\delta) = \lim_{\delta\rightarrow 0^+}\frac{F(x+\delta,y)-F(x,y)}{F_X(x+\delta) - F_X(x)} = \int_{-\infty}^y \frac{f(x,v)}{f_X(x)}dv.$
 因此条件概率密度函数$f_{Y|X}(y|x)=\frac{f(x,y)}{f_X(x)}.$
二元均匀分布：$f(x,y) = \begin{cases}
 \frac{1}{S(D)}, (x,y)\in D <br />
 0, 其他
\end{cases}$</li>
</ol>

<p>二元正态分布：$f(x,y) = \frac{1}{2\pi\sigma_1\sigma_2\sqrt{1-\rho^2}}\exp{-\frac{1}{2(1-\rho^2)}[\frac{(x-\mu_1)^2}{\sigma_1^2} - 2\rho\frac{(x-\mu_1)(y-\mu_2)}{\sigma_1\sigma_2} + \frac{(y-\mu_2)^2}{\sigma_2^2}]}$，有以下性质：</p>
<ol>
  <li>$X\sim N(\mu_1,\sigma_1^2), Y\sim N(\mu_2,\sigma_2^2).$</li>
  <li>给定$X=x, Y \sim N(\mu_2+\rho\frac{\sigma_2}{\sigma_1}(x-\mu_1), (1-\rho^2)\sigma_2^2)$</li>
  <li>给定$Y=y, X \sim N(\mu_1+\rho\frac{\sigma_1}{\sigma_2}(y-\mu_2), (1-\rho^2)\sigma_1^2)$</li>
</ol>

<p><strong>如果X为离散型随机变量，概率分布为p_X(x_i)，由全概率公式有\(P(A)=\sum_iP(A\|X=x_i)P(X=x_i)\)</strong>
<strong>如果X为连续型，其密度函数为$p_X(x)$，则\(P(A) = \int_{-\infty}^{+\infty}P(A\|X=x)p_X(x).\)</strong></p>

<p>例子：设$U_1,\cdots,U_n$独立同分布于$(0,1]$上的均匀分布，令$\xi = \min{n\geq 1: U_1+\cdots+U_n &gt; 1}$，求$\xi$的概率分布。</p>

<p>令$\xi(x)=\min{n\geq 1: U_1+\cdots+U_n &gt; x}$，则有
$P(\xi(x)&gt; 1) = P(U_1\leq x) = x$，进而有递推关系
\(\begin{align*}
    P(\xi(x)&gt;n+1) &amp;= P(U_1+\cdots+U_{n+1} \leq x) \\
    &amp;= \int_{-\infty}^{+\infty}P(U_1+\cdots+U_{n+1} \leq x \| U_1 = y)p_{U_1}(y)dy \\
    &amp;= \int_0^1 P(U_2+\cdots+U_{n+1} \leq x-y)dy \\
    &amp;= \int_0^x P(\xi(u)&gt;n)du
\end{align*}\)
由归纳法可以得到$P(\xi(x)&gt;n) = \frac{x^n}{n!}$，因此可以得到$P(\xi&gt;n)=\frac{1}{n!}\Rightarrow P(\xi = n) = \frac{1}{(n-1)!} - \frac{1}{n!}.$</p>

<h2 id="随机变量的独立性">随机变量的独立性</h2>

<p>离散型：$p_{ij} = p_{i\cdot}p_{\cdot j}, i,j=1,2,\ldots$
连续型：$f(x,y) = f_X(x)f_Y(y), a.e. \Leftrightarrow f(x,y)$几乎处处可以写为$m(x)$与$n(y)$的乘积，<strong>注意f的取值范围，y不能与x有关</strong></p>

<p>例：二元正态分布中，XY相互独立$\Leftrightarrow \rho = 0.$</p>

<h2 id="二元随机变量函数的分布">二元随机变量函数的分布</h2>

<h4 id="zxy的分布">$Z=X+Y$的分布</h4>

<p>离散型：\(P(Z=z_k) = \sum_{i=1}^{\infty}P(X=x_i, Y=z_k-x_i), k=1,2,\ldots.\)</p>

<p>连续型：
\(\begin{align*}
    F_Z(z) &amp;= \int\int_{x+y\leq z} f(x,y)dxdy \ \int_{-\infty}^{+\infty}dx\int_{-\infty}^{z-x} f(x,y)dy \\
    &amp;= \int_{-\infty}^z dv \int_{-\infty}^{+\infty} f(u,v-u)du\quad(u=x,v=x+y) \\
    f_Z(z) &amp;= \int_{-\infty}^{+\infty} f(x,z-x)dx = \int_{-\infty}^{+\infty}f(z-y,y)dy
\end{align*}\)
特别地，当XY相互独立时，\(f_Z(x) = \int_{-\infty}^{+\infty}f_X(x)f_Y(z-x)dx = \int_{-\infty}^{+\infty} f_X(z-y)f_Y(y)dy.\)</p>

<p>例：</p>
<ol>
  <li>$X,Y$相互独立，$X\sim P(\lambda_1), Y\sim P(\lambda_2) \Rightarrow X+Y \sim P(\lambda_1+\lambda_2)$</li>
  <li>${X_i}$相互独立，$X_i\sim N(\mu_i,\sigma_i^2) \Rightarrow \sum_iX_i \sim N(\sum_i\mu_i, \sum_i \sigma_i^2).$</li>
</ol>

<h4 id="zfracxy的分布">$Z=\frac{X}{Y}$的分布</h4>

\[\begin{align*}
    F_Z(z) &amp;= P(\frac{X}{Y}\leq z) = \int\int_{x/y\leq z}f(x,y)dxdy \\
    &amp;= \int_0^{\infty}dy\int_{-\infty}^{yz}f(x,y)dx + \int_{-\infty}^0dy\int_{yz}^{+\infty}f(x,y)dx \\
    &amp;= \int_{-\infty}^z \left[ \int_0^{\infty}p(ay,y)ydy -\int_{-\infty}^0 p(ay,y)ydy\right]da\quad (这里令x=ay) \\
    &amp;= \int_{-\infty}^zp_Z(a)da \\
    p_Z(z) &amp;= \int_{-\infty}^{\infty}p(zx,x)\|x\|dx.
\end{align*}\]

<h4 id="次序统计量的分布">次序统计量的分布</h4>

<p>设$X_1,\ldots, X_n$独立同分布，分布函数均为$F(x)$，令$\xi_1 = \min(X_1,\ldots,X_n), \xi_2 = \max(X_1,\ldots,X_n).$</p>

\[\begin{align*}
    P(\xi_2 \leq x) &amp;= P(X_1\leq x,\ldots, X_n\leq x) \\
    &amp;= P(X_1\leq x)\cdots P(X_n\leq x) \\
    &amp;= [F(x)]^n \\
    p(x) &amp;= nf(x)(F(x))^{n-1}
\end{align*}\]

\[\begin{align*}
    P(\xi_1 &gt; x) &amp;= P(X_1 &gt; x, \ldots, X_n &gt; x) \\
    &amp;= [1-F(x)]^n \\
    P(\xi_1 \leq x) &amp;= 1-[1-F(x)]^n. \\
    p(x) &amp;= nf(x)[1-F(x)]^{n-1}
\end{align*}\]

<p>$(\xi_1,\xi_2)$的联合分布函数
\(\begin{align*}
    F(x,y) &amp;= P(\xi_1\leq x, \xi_2 \leq y) \\
    &amp;= P(\xi_2 \leq y) - P(\xi_1 &gt; x, \xi_2\leq y) \\
    &amp;= [F(y)]^n - P(\bigcap_{i=1}^n(x &lt; \xi_i \leq y)) \\
    &amp;=\begin{cases}
        [F(y)]^n - [F(y) - F(x)]^n , x&lt;y \\
        [F(y)]^n, x\geq y
    \end{cases}
\end{align*}\)</p>

<h3 id="最大值和最小值的相关系数">最大值和最小值的相关系数</h3>

<p>$X_1,X_2$独立同分布于$U(0,1), Y=\min(X_1,X_2), Z+\max(X_1,X_2)$，请问给定$Z\leq z$时$Y\geq y$的概率是多少？ Y和Z的相关系数是多少？</p>

<p>通过画图可以看出来$P(Y\geq y | Z\leq z) = \begin{cases}
    (z-y)^2 / z^2, 0\leq y \leq z \leq 1,
    0, 其他
\end{cases}$</p>

<p>$\rho_{YZ} = \frac{Cov(Y,Z)}{\sqrt{Var(Y)Var(Z)}}$</p>

<p>首先求$Var(Y),Var(Z),f_Y(x)=2(1-x),f_Z(z)=2z$，可以去计算$E(Y)=\frac{1}{3},E(Z)=\frac{2}{3},E(Y^2)=\frac{1}{6},E(Z^2)=\frac{1}{2}\Rightarrow Var(Y)=E(Y^2)-E(Y)^2 = \frac{1}{18}, Var(Z)=\frac{1}{18}.$</p>

<p>紧接着要计算$E(YZ)=\int_0^1\int_0^zyzf(y,z)dydz$，因此要求$Y,Z$的联合密度函数，先计算联合分布函数：
$F(y,z)=P(Y\leq y, Z\leq z) = P(Z\leq z) - P(Y\geq y,Z\leq z) = z^2-(z-y)^2 = 2zy-y^2 \Rightarrow f(y,z) = \frac{\partial F(y,z)}{\partial y\partial z} = 2.$</p>

<p>因此$E(YZ)=\int_0^1 \int_0^z 2yzdydz = \frac{1}{4}\Rightarrow Cov(Y,Z) =E(YZ)-E(Y)E(Z)=\frac{1}{36} \Rightarrow \rho_{YZ}=\frac{1}{2}.$</p>

<h2 id="随机向量的变换">随机向量的变换</h2>

<p>$(\xi_1,\ldots,\xi_n)$密度函数为$p(x_1,\ldots,x_n)$，现有$m$个函数$\eta_i = f_i(\xi_1,\ldots,\xi_n)$，其联合分布函数为\(G(y_1,\ldots,y_m)=P(\eta_1\leq y_1,\ldots, \eta_m\leq y_m) = \int_\cdots\int_D p(x_1,\ldots,x_n) dx_1\cdots dx_n.\)
其中$D ={(x_1,\ldots,x_n : \eta_1\leq y_1,\ldots, \eta_n \leq y_n)}$</p>

<p>如果$m=n$并且$f_i$有唯一反函数组$x_i = x_i(y_1,\ldots,y_n)$并且$J = \frac{\partial(x_1,\ldots,x_n)}{\partial(y_1,\ldots,y_n)}\neq 0$，那么有
\(q(y_1,\ldots,y_n) = \begin{cases}
    p(x_1(y_1,\ldots,y_n),\ldots)\|J\|, (y_1,\ldots,y_n)\in (\eta_1,\ldots,\eta_n)的值域 \\
    0, 其他
\end{cases}\)</p>

<h1 id="数字特征">数字特征</h1>

<h2 id="数学期望">数学期望</h2>

<p>离散型：$EX=\sum_k x_kp_k$
连续型：$EX=\int_{-\infty}^{\infty}xp(x)dx$</p>

<p>有以下性质：</p>
<ol>
  <li>$E(g(X)) = \int g(x)p(x)dx$</li>
  <li>可加性</li>
  <li>有限个独立的随机变量乘积的期望等于乘积的期望</li>
</ol>

<h2 id="条件期望">条件期望</h2>

<p>$E(\eta|\xi =x) = \int_{-\infty}^{\infty} ydF_{\eta|\xi}(y|x)$</p>

<p>离散型：$E(\eta|\xi =x) = \sum_j y_jp_{\eta|\xi}(y_j|x)$
连续型：$E(\eta|\xi =x) = \int_{-\infty}^{\infty} y p_{\eta|\xi}(y|x)dy$</p>

<h2 id="全期望公式">全期望公式</h2>

<p>$E(X) = E(E(X|Y)) = \begin{cases}
    \sum_y E(X|Y=y)p(Y=y), Y为离散型 <br />
    \int_{-\infty}^{\infty} E(X|Y=y)f_Y(y)dy, Y为连续型
\end{cases}$</p>

<h2 id="方差协方差相关系数">方差、协方差、相关系数</h2>

<p><strong>方差</strong>$Var\xi = E(\xi-E\xi)^2 = E(\xi^2) - E(\xi)^2$
方差性质：</p>
<ol>
  <li>$Var(c\xi+b) = c^2Var(\xi)$</li>
  <li>$Var\xi \leq E(\xi-c)^2$，等号成立当且仅当$c=E\xi$</li>
  <li>$Var(\sum_{i=1}^n \xi_i) = \sum_{i=1}^nVar\xi_i + 2\sum_{1\leq i,j\leq n}E(\xi_i-E\xi_i)(\xi_j-E\xi_j)$，特别地，如果它们两两独立，则有$Var(\sum_{i=1}^n \xi_i) = \sum_{i=1}^nVar\xi_i$</li>
</ol>

<p>称$\xi^* = \frac{\xi-E\xi}{\sqrt{Var\xi}}$为$\xi$的标准化，期望为0，方差为1.</p>

<p>例：两两独立的n个正态分布的和仍服从正态分布:$c_0+c_1X_1+\cdots+c_nX_n \sim N(c_0+c_1\mu_1+\cdots+c_n\mu_n,c_1^2\sigma_1^2+\cdots+c_n^2\sigma_n^2)$</p>

<p><strong>协方差</strong>$Cov(X,Y)=E(X-EX)(Y-EY) = E(XY)-E(X)E(Y)$
协方差性质：</p>
<ol>
  <li>$Cov(X,Y)=Cov(Y,X), Cov(X,a)=0$</li>
  <li>$Cov(X,X)=Var(X)$</li>
  <li>$Cov(aX,bY)=abCov(X,Y)$</li>
  <li>$Cov(X_1+X_2,Y) =Cov(X_1,Y)+Cov(X_2,Y)$</li>
  <li>$X,Y$独立可以推出$Cov(X,Y)=0$，反过来不一定</li>
  <li>$Var(X)Var(Y)\neq 0$的时候$(Cov(X,Y))^2 \leq Var(X)Var(Y)$，等号成立当且仅当$\exists c_1,c_2, s.t. P(Y=c_1+c_2X) = 1$(严格线性关系)</li>
</ol>

<p><strong>相关系数</strong>$\rho_{XY} = \frac{Cov(X,Y)}{\sqrt{Var(X)Var(Y)}}, |\rho_{XY}| \leq 1.$
相关系数性质：</p>
<ol>
  <li>$X,Y$相互独立可以推出$\rho_{XY}=0$，反之不一定</li>
  <li>$|\rho_{XY}|\leq 1$，等号成立当且仅当X和Y有严格线性关系，也就是说$|\rho_{XY}|$反映的是$X$和$Y$的线性关系密切程度</li>
  <li>$\rho_{XY}&gt;0$称为正相关，反之为负相关</li>
  <li>若$\rho_{XY}=0$，称X和Y不相关</li>
  <li>$\rho_{XY} = 0 \Leftrightarrow E(XY)=E(X)E(Y) \Leftrightarrow Var(X+Y)=Var(X)+Var(Y)$</li>
</ol>

<div align="center"> <img src="/pic/QuantGuideBook/Discrete.jpeg" width="600" /> </div>

<div align="center"> <img src="/pic/QuantGuideBook/Continuous.jpeg" width="600" /> </div>

<h2 id="例题">例题</h2>

<h3 id="相遇概率">相遇概率</h3>

<p><strong>两个人会在五点到六点的任意时间到达车站，他们会呆五分钟然后离开，他们每天遇到的概率是多少？</strong></p>

<p>这道题画图最直接，最终概率就是$\frac{60<em>60-2</em>(0.5<em>55</em>55)}{60*60} = \frac{23}{144}.$</p>

<h3 id="三角形概率">三角形概率</h3>

<p><strong>将一个棍子切成三段，能组成一个正方形的概率是多少？</strong></p>

<p>记两次切的位置分别为$x,y, x&lt;y$，则有
\(\begin{align*}
    x+(y-x) &gt; 1-y &amp;\Rightarrow y&gt;1/2 \\
    x+(1-y) &gt; y-x &amp;\Rightarrow y&lt;1/2+x \\
    (y-x)+(1-y) &gt; x \Rightarrow x &lt; 1/2
\end{align*}\)</p>

<p>因此概率为$2\times \frac{1}{8} = \frac{1}{4}$，因为$x&gt;y$是完全对称的情况。</p>

<h3 id="矩生成函数">矩生成函数</h3>

<p><strong>令$M(t) = E(e^{tX})$，则有$M^{n}(0)=E(X^n)$.</strong></p>

<p>若$X \sim N(0,1)$，则
$M(t) = \int_{-\infty}^{\infty}e^{tx}\frac{1}{\sqrt{2\pi}}e^{-x^2/2}dx = e^{t^2/2}\int_{-\infty}^{\infty}\frac{1}{\sqrt{2\pi}}e^{-(x-t)^2/2}dx = e^{t^2/2}$</p>

<p>因此$M’(0) = 0, M’‘(0)=1, M^3(0)=0, M^4(0)=3.$</p>

<h3 id="数面条">数面条</h3>

<p><strong>如果碗里面有100个面条，你拿起面条的两个端点将他们连在一起，持续做这件事直到没有端点，请计算圆圈的期望数量。</strong></p>

<p>如果只有一根那就是1，两根的话有4个端点，有$C_4^2=6$种拿法，其中有两种是直接将各自圈起来，因此圆圈的期望数量为$E(f(2))=\frac{2}{6}\times (1+E(f(1))) + \frac{4}{6} \times E(f(1)) = \frac{1}{3} + E(f(1)) = 1 + \frac{1}{3}$</p>

<p>以此类推，可以发现$E(f(n)) = 1+\frac{1}{3}+\cdots+\frac{1}{2n-1}.$ 再用归纳法进行证明。</p>

<h3 id="最优对冲比例">最优对冲比例</h3>

<p><strong>你买了一份A股票，现在你想卖出一些B股票来对冲，你应该卖多少来使得你的利润方差最小化？假设A、B股票回报方差为$\sigma_A^2,\sigma_B^2$，它们的相关系数为$\rho$.</strong></p>

<p>我们要最小化$Var(r_A-hr_B) = \sigma_A^2 + h^2\sigma_B^2 - 2h\rho\sigma_A\sigma_B \Rightarrow h = \rho\frac{\sigma_A}{\sigma_B}.$</p>

<h3 id="骰子游戏">骰子游戏</h3>

<p><strong>每次掷骰子，你都要支付那个面的数值，如果转到4\5\6则可以再投一次，否则游戏停止，请问游戏的花费期望是多少。</strong></p>

<p>$Y$记为第一次掷骰子的点数，$X$为花费，则有$E(X|Y\in{1,2,3}) = 2, E(X|Y\in{4,5,6}) = 5 + E(X)$，因此$E(X) =\frac{1}{2}(7+E(X)) \Rightarrow E(X)=7.$</p>

<h3 id="卡牌游戏">卡牌游戏</h3>

<p><strong>你在一张一张翻扑克牌，翻到第一张Ace所需要翻的牌数期望是多少？</strong></p>

<p>令$X_i=1$如果卡牌$i$在Ace之前被翻，否则为0，那么$E(X)=1+\sum_{i=1}^48E(X_i)$</p>

<p><strong>注意$P(X_i=1)=\frac{1}{5}$，这里可以考虑是第i个牌随机插入到由4个Ace构成的队列中，只有放在队首才能够满足。</strong></p>

<p>因此$E(X) = 1+ \frac{48}{5}$</p>

<h3 id="随机变量的和">随机变量的和</h3>

<p><strong>假设$X_1,\ldots,X_n$独立同分布于$(0,1)$上的均匀分布，$S_n=X_1+\cdots+X_n \leq 1$的概率是多少？</strong></p>

<p>用归纳法证明$P(S_n\leq 1) = \frac{1}{n!}.$</p>

<p>$P(S_{n+1}\leq 1) = \int_{0}^1 f(X_{n+1})P(S_n\leq 1-X_{n+1})dX_{n+1}=\int_0^1 \frac{(1-X_{n+1})^n}{n!} =\frac{1}{(n+1)!}$</p>

<h3 id="收集优惠券">收集优惠券</h3>

<p><strong>现在盒子里有N种不同的优惠券。（每种有很多张，相当于抽取后又放回）</strong></p>
<ol>
  <li><strong>如果一个孩子想要集齐所有的优惠券，平均需要多少个？</strong>
 令$X_i$为收集到$(i-1)$个不同类型后收集到第$i$种优惠券所需优惠券的数量，因此$X=X_1+\cdots+X_N$
 对于任意的$i$，已收集$i-1$种类型，获得一个新类型的概率为$1-\frac{i-1}{N}$，这就相当于一个概率为$1-\frac{i-1}{N}$的几何分布，因此$E(X_i)=\frac{N}{N-i+1}$，
 可以得到$E(X)=\sum_{i=1}^NE(X_i)=\sum_{i=1}^N \frac{N}{N-i+1}.$</li>
  <li><strong>如果已经收集到n个优惠券，优惠券种类数的期望是多少？</strong>
 这里引入 <strong>indicator random variables</strong> $I_i$，其中$I_i=1$如果第$i$个类型在这$n$个优惠券中，否则为0，
 由此可以得到$Y=\sum_{i=1}^NI_i,$对于任意一个优惠券，它不是第$i$种优惠券的概率为$\frac{N-1}{N}$，
 可以得到$P(I_i=0) = (\frac{N-1}{N})^n\Rightarrow E(I_i)=P(I_i=1) = 1-(\frac{N-1}{N})^n.$
 可以得到$E(Y)=\sum_{i=1}^NE(I_i)=N(1-(\frac{N-1}{N})^n).$</li>
</ol>

<h3 id="违约概率">违约概率</h3>

<p><strong>合同A明年违约概率为50%，合同B为30%，请问至少一个合同违约的概率在什么范围内以及它们之间的相关系数在什么范围内？</strong></p>

<p>至少一个合同违约的概率最大为80%（A违约B就不违约），最小为50%（A违约B就一定违约）
$I_A=1$表示A会违约，则有$E(I_A)=0.5,Var(I_A)=0.25,E(I_B)=0.3, Var(I_B)=0.21$
\(\begin{align}
    P(I_A=1 \|\| I_B=1) &amp;= E(I_A)+E(I_B)-E(I_AI_B) \\
    &amp;= E(I_A) + E(I_B) -(E(I_A)E(I_B)-Cov(I_A,I_B)) \\
    &amp;= 0.8-(0.15-\rho_{AB}\sigma_A\sigma_B) \\
    &amp;= 0.65 - \sqrt{0.21}/2 \rho_{AB}
\end{align}\)
$0.5 \leq 0.65-\sqrt{0.21}/2 \rho_{AB} \leq 0.8 \Rightarrow -\sqrt{3/7}\leq \rho_{AB} \leq \sqrt{3/7}.$</p>

<h3 id="随机蚂蚁">随机蚂蚁</h3>

<p>略，记住蚂蚁相遇只需调换标签即可。</p>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="量化绿皮书" /><summary type="html"><![CDATA[一元随机变量与分布函数]]></summary></entry><entry><title type="html">概率论:事件及其概率（绿皮书+额外补充）</title><link href="http://localhost:4000/2024/09/25/Probability/" rel="alternate" type="text/html" title="概率论:事件及其概率（绿皮书+额外补充）" /><published>2024-09-25T10:00:00+08:00</published><updated>2024-09-25T10:00:00+08:00</updated><id>http://localhost:4000/2024/09/25/Probability</id><content type="html" xml:base="http://localhost:4000/2024/09/25/Probability/"><![CDATA[<h1 id="事件及其概率">事件及其概率</h1>

<h2 id="基础的概率定义和集合操作">基础的概率定义和集合操作</h2>

<h3 id="掷硬币游戏">掷硬币游戏</h3>

<p><strong>A有$(n+1)$个公平的硬币而B有$n$个，如果他们将所有的硬币抛掷，A能有更多正面朝上硬币的概率是多少？</strong></p>

<p>可以从A的硬币中取走一个，那么此时A和B是对称的，此时有三种情况：</p>
<ol>
  <li>A的n个硬币正面朝上的更多，概率记作$P(E_1)=x$.</li>
  <li>一样多，概率记作$P(E_2)=y$.</li>
  <li>B的更多，概率记作$P(E_3)=x$.</li>
</ol>

<p>此时再考虑最后一枚硬币，对于第一个情况，A始终有更多的正面朝上的硬币；对于第二种情况，最后一枚硬币需要朝上；第三种情况则A不可能有更多的正面朝上的硬币，因此概率为$x+0.5y = 0.5.$</p>

<h3 id="扑克游戏">扑克游戏</h3>

<p><strong>现在有52张牌，你拿一张然后荷官拿一张，如果你的数字大你才赢，那么你赢的概率是多少？</strong></p>

<p>可以直接去计算概率$P=\frac{1}{13} \times \left( \frac{0}{51} + \frac{4}{51} + \cdots \frac{48}{51}\right) = \frac{8}{17}$.</p>

<p>但是也可以换一个方法，把情况分为三种：你的牌大、相等、小于荷官的牌，此时$P(E_1) = P(E_3) = \frac{1}{2}(1-P(E_2)) = \frac{1}{2}(1-\frac{3}{51}) = \frac{8}{17}.$</p>

<h3 id="喝醉的乘客">喝醉的乘客</h3>

<p><strong>有100个乘客在排队上飞机，每个人都有自己的位置，但是第一个人喝多了，随便找个位置就坐了，假设其他人如果能坐自己的位置的话就会坐自己的，如果自己的位置被坐了就会随机坐一个，假如你是第100个登机的，请问你能坐在自己位置的概率是多少？</strong></p>

<p>只要有人坐在第一个位置上，后面的乘客都将坐在自己对应的位置上，因此实际上就是计算第一个位置比第100个位置先被坐下的概率，因为两个座位是同等对称的，所以就是50%.</p>

<h3 id="圆上的n个点">圆上的n个点</h3>

<p><strong>N个点随机扔在一个圆周上，它们能在同一个半圆内的概率是多少？</strong></p>

<p>$1,\cdots, i-1,i+1,\cdots, N$个点都在从第$i$个点开始顺时针的半圆上记为事件$E_i$，可以看出$E_1,\cdots,E_N$都是彼此互斥的，
因此$P(E) = P(\cup_{i=1}^N E_i) = \sum_{i=1}^N P(E_i) = \sum_{i=1}^N \frac{1}{2^{N-1}} = \frac{N}{2^{N-1}}.$</p>

<p>类似的如果弧长为$x$弧度的话概率就是$N\times x^{N-1}$.</p>

<h2 id="组合分析">组合分析</h2>

<h3 id="扑克牌">扑克牌</h3>

<p><strong>52张牌，每个人拿五张，请问拿到four-of-a-kind的概率是多少？拿到葫芦的概率是多少？双对的概率是多少？</strong></p>

<ol>
  <li>$P(E_1) = \frac{C_{13}^1 \times 48}{C_{52}^{5}}$</li>
  <li>$P(E_2) = \frac{C_{13}^1 \times C_4^3 \times C_{12}^1 \times C_4^2}{C_{52}^5}$</li>
  <li>$P(E_3) = \frac{C_{13}^2 \times C_4^2 \times C_4^2}{C_{52}^5}$</li>
</ol>

<h3 id="古怪的海盗ii">古怪的海盗II</h3>

<p><strong>有11个海盗，为了保护财宝，决定至少要大于等于6个人才能开锁，人数足够的任意小组都可以打开锁，每个锁可以有多把钥匙但每把钥匙只能开一个锁，请问最少要对财宝上多少个锁？每个海盗有几个钥匙？</strong></p>

<p>任意五个人都不能打开锁，那就要对每个五人组合都有一个特殊的打不开的锁，那就是${11 \choose 5 } = 462$个锁，每个锁有6把钥匙，并且都给独特的一个6人组，也就是说不能有一个六人组每个人都有两个锁的钥匙。因此每个海盗有$462 * 6 / 11 = 252$个钥匙。</p>

<h3 id="象棋比赛">象棋比赛</h3>

<p><strong>一个比赛有$2^n$个选手，实力排名从高到低，$1&gt;2&gt;\cdots&gt;2^n$，比赛实行淘汰制，每轮胜者才能进入下一轮，除决赛外每一轮的对手对局都是随机的，请问1、2名选手能在决赛遇见的概率是多少？</strong></p>

<p>记$E_i$为第$i$轮二人没有碰见，则
$P(E) = P(E_1)\times P(E_2|E_1) \times \cdots \times P(E_{n-1}|E_1E_2\ldots E_{n-2}) = 
\frac{2^n-2}{2^n-1} \times \frac{2^{n-1}-2}{2^{n-1}-1} \times \cdots \frac{2}{3} = \frac{2^{n-1}}{2^n-1}$</p>

<h3 id="申请信">申请信</h3>

<p><strong>你准备投五家公司，有五个信封，每个都对应一个独特的简历，但你的孩子随便将简历放进去了，请问五个简历都装错的概率是多少？</strong></p>

<p>记$E_i$为第$i$个简历装入正确的信封，因此
$P(\cup_{i=1}^5 E_i) = \sum_{i=1}^5P(E_i) - \sum_{i_1&lt;i_2}P(E_iE_j) + \cdots + (-1)^6P(E_1\ldots E_5)$</p>

<p>$P(E_{i_1}\ldots E_{i_k}) = \frac{(5-k)!}{5!} \Rightarrow \sum P(E_{i_1}\ldots E_{i_k}) = \frac{1}{k!}$</p>

<p>因此$P(\cup_{i=1}^5 E_i)= 1 - \frac{1}{2!} + \frac{1}{3!} - \frac{1}{4!} + \frac{1}{5!} = \frac{19}{30} \Rightarrow P(E) = \frac{11}{30}.$</p>

<h3 id="生日问题">生日问题</h3>

<p><strong>需要多少个人才能做到有两个人同一天生日的概率大于0.5?</strong></p>

<p>假设有$n$个人，那么没有两个人同一天生日的概率为$P(\overline{E}) = \frac{A_{365}^n}{365^n} &lt; \frac{1}{2}$,可计算得到$n$最少为23.
<strong>分母表示每个人都不相同，因此分子是排列数而不是组合数。类似的问题有n个球放入N个盒子里，恰好有n个盒子里面有球的概率即为$\frac{A_N^n}{N^n}$.</strong></p>

<h3 id="100位小数">100位小数</h3>

<p><strong>请问$(1+\sqrt{2})^{3000}$的第100位小数是多少？</strong></p>

<p>$(1+\sqrt{2})^{3000} + (1-\sqrt{2})^{3000} = 2\sum_{k=2j, 0\leq j\leq 2/n} {n \choose k}\sqrt{2}^{k}$始终为整数，然而$(1-\sqrt{2})^{3000}$远小于$10^{-100}$，因此第100位小数为9.</p>

<h3 id="以11结尾的整数的三次方">以11结尾的整数的三次方</h3>
<p><strong>$x$为1到$10^{12}$中间的一个整数，请问x的三次方以11结尾的概率是多少？</strong></p>

<p>$x = a+10b \Rightarrow x^3 = a^3 + 30a^2b + 300ab^2 + 1000b^3.$
$x^3$的末尾只由$a^3$决定，因此$a=1$，此时又要保证$3b$是1为结尾，那么$b$的末尾数字必须是7，也就是说$x$的末尾两位数必须是71，因此概率为0.01.</p>

<h3 id="抽签问题">抽签问题</h3>

<p><strong>52张牌有a张红牌b张黑牌，放回或不放回抽n张的话，恰好有k张红牌的概率是多少？</strong></p>

<ol>
  <li>不放回的话概率为$\frac{C_a^k C_b^{n-k}}{C_N^n}.$</li>
  <li>放回的话可以考虑为一个二项分布，试验成功即为抓到红牌，则概率为${n \choose k}p^k(1-p)^{n-k}, p = \frac{a}{N}, 1-p = \frac{b}{N}.$</li>
</ol>

<h3 id="抽签问题ii">抽签问题II</h3>

<p><strong>编号为1到n的球，a个红球b个白球，每次摸一个不放回，摸n次，求第k次摸到红球的概率。</strong></p>

<p>将每次摸的球做一个排列，视为一个样本点，那么概率为$\frac{a(n-1)!}{n!} = \frac{a}{n}.$</p>

<h2 id="条件分布和贝叶斯公式">条件分布和贝叶斯公式</h2>

<table>
  <tbody>
    <tr>
      <td><strong>全概率公式</strong>：对于两两互斥的事件${F_i}$，他们的并集是整个样本空间，那么有$$ P(E) = \sum_{i=1}^n P(E</td>
      <td>F_i)P(F_i).$$</td>
    </tr>
  </tbody>
</table>

<p><strong>A、B事件相互独立</strong> $\Leftrightarrow P(AB)=P(A)P(B) \rightarrow P(AB^c)=P(A)P(B^c).$</p>

<p><strong>ABC事件两两独立</strong> $\Leftrightarrow P(AB)=P(A)P(B), P(AC)=P(A)P(C), P(BC)=P(B)P(C).$</p>

<p><strong>ABC事件相互独立</strong> $\Leftrightarrow P(ABC)=P(A)P(B)P(C) +$ABC两两独立.</p>

<table>
  <tbody>
    <tr>
      <td><strong>贝叶斯公式</strong>：$P(F_j</td>
      <td>E) = \frac{P(E</td>
      <td>F_j)P(F_j)}{\sum_{i=1}^n P(E</td>
      <td>F_i)P(F_i)}.$</td>
    </tr>
  </tbody>
</table>

<h3 id="男女孩">男女孩</h3>

<p><strong>公司为每个有至少一个儿子的妈妈准备晚宴，有两个孩子的Jack女士被邀请参加，她有两个儿子的概率是多少？</strong></p>

<table>
  <tbody>
    <tr>
      <td>$P(A</td>
      <td>B) = \frac{P(AB)}{P(B)} = \frac{1/4}{3/4} = \frac{1}{3}.$</td>
    </tr>
  </tbody>
</table>

<p><strong>当你在路上看到Jack女士带着一个男孩在路上走，她有两个儿子的概率是多少？</strong></p>

<p>此时概率即为$\frac{1}{2}.$</p>

<p>这两个问题给的前提是不一样的，一个是至少有一个儿子，一个是其中一个是男孩。</p>

<h3 id="全是女孩的世界">全是女孩的世界？</h3>
<p><strong>在原始社会，每个夫妻都想有一个女儿，他们会一直要孩子直到生了一个女儿，他们就不再生孩子了，请问社会上女孩的比例最终会是多少？</strong></p>

<p>始终都会是50%，因为每生一个孩子是男是女的概率都是50%，这与夫妻行为无关。</p>

<h3 id="不公平的硬币">不公平的硬币</h3>

<p><strong>给你1000个硬币，有一个两边都是正面，你任意选一个硬币扔10次，每次都是正面向上，请问你这个硬币是不公平的硬币的概率是多少？</strong></p>

<p>记A为该硬币不公平，B为十次投掷均为正面向上，则有：
\(P(A|B) = \frac{P(B|A)P(A)}{P(B|A)P(A)+P(B|A^c)P(A^c)} 
\approx 0.5\)</p>

<h3 id="不公平硬币中寻找公平概率">不公平硬币中寻找公平概率</h3>

<p><strong>给你一个不公平硬币，正面朝上的概率是未知的，请问你可以用这个硬币得到50%概率的事件吗？</strong></p>

<p>投掷两次，先正后反记为输，先反后正记为赢，如果没出现这两种情况则重新再投掷两次。</p>

<h3 id="飞镖游戏">飞镖游戏</h3>

<p><strong>Jason扔两次飞镖，第二次比第一次偏离得多，请问第三次比第一次更远的概率为多少？</strong></p>

<p>三次从近到远记为A\B\C三个等级，枚举一下即可得到概率为$\frac{2}{3}$</p>

<p><strong>假如扔n次，后n-1次都比第一次远，那么他扔第n+1次比第一次也远的概率是多少？</strong></p>

<p>实际上就相当于n个人排列好了，第n+1个人随机站一个位置，他站到第一个位置的概率是多少，就是$\frac{n}{n+1}.$</p>

<h3 id="生日队列">生日队列</h3>

<p><strong>电影院管理说他会送排队的人中第一个生日与前面买过票的人生日一致的人一张票，请问你站在什么位置得到票的概率最高？</strong></p>

<p>p(n) = p(前n-1个人生日不同)*p(你的生日在前n-1个中) = $\frac{365\times\cdots\times (365-n+2)}{365^{n-1}}\times \frac{n-1}{365}.$ 求解不等式组$P(n)&gt;P(n-1), P(n) &gt; P(n+1)$可以得到$n=20.$</p>

<h3 id="骰子顺序">骰子顺序</h3>

<p><strong>你依次掷骰子三次，得到一个递增数列的概率是多少？</strong></p>

<table>
  <tbody>
    <tr>
      <td>当掷的三个数不同时，是一个递增数列的概率是$1/6$，这个与飞镖问题的道理一致，因此最终概率为$P(三个数不同)P(递增</td>
      <td>三个数不同) = (1\times \frac{5}{6} \times \frac{4}{6})\times \frac{1}{6} = \frac{5}{54}.$</td>
    </tr>
  </tbody>
</table>

<h3 id="monty-hall问题">Monty Hall问题</h3>

<p><strong>有三个门，其中一个是车，另外两个是羊，你现在选了一个门，Monty开了另外两个中有羊的一个，现在他给你机会换一个门，你要换吗，换门后赢的概率是多少？</strong></p>

<p>记A为不换门赢，C为主持人打开一个有羊的门。<strong>注意P(C)==1！</strong>
$P(A|C) = \frac{P(C|A)P(A)}{P(C|A)P(A)+P(C|A^c)P(A^c)} = \frac{1/3}{1/3+2/3} = \frac{1}{3}.$也就是说不换门赢当且仅当你最初选的就是有车的门，概率为$\frac{1}{3}$，那么换门赢的概率则为$\frac{2}{3}.$</p>

<h3 id="amoeba人口数">Amoeba人口数</h3>

<p><strong>池塘里有一个amoeba，每分钟它可能死，可能不变，可能分裂成两个或者三个，每个情况概率相同，请问最后amoeba死光的概率是多少？</strong></p>

<table>
  <tbody>
    <tr>
      <td>$P(E) = P(E</td>
      <td>F_1)P(F_1) + \cdots + P(E</td>
      <td>F_4)P(F_4)$</td>
    </tr>
    <tr>
      <td>1. 对于事件1，$P(E</td>
      <td>F_1) = 1.$</td>
      <td> </td>
    </tr>
    <tr>
      <td>2. 对于事件2，$P(E</td>
      <td>F_2) = P(E).$</td>
      <td> </td>
    </tr>
    <tr>
      <td>3. 对于事件3，$P(E</td>
      <td>F_3) = P(E)^2.$</td>
      <td> </td>
    </tr>
    <tr>
      <td>4. 对于事件4，$P(E</td>
      <td>F_4) = P(E)^3.$</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>因此$p = \frac{1}{4}(1+p+p^2+p^3) \Rightarrow p = \sqrt{2}-1.$</p>

<h3 id="盒子中的蜡烛">盒子中的蜡烛</h3>

<p><strong>盒子中有10个红蜡烛，20个蓝色，30个绿色的，你一个一个拿出来，请问当你拿出所有红蜡烛之后里面还至少有一个蓝色和一个绿色蜡烛的概率是多少？</strong></p>

<p>记最后一个红色、蓝色、绿色是在$T_r,T_b,T_g$次被拿出来，那么
$P(E) = P(T_r&lt;T_b \cap T_r&lt;T_g) = P(T_r&lt;T_b&lt;T_g) + P(T_r&lt;T_g&lt;T_b) = P(T_r&lt;T_b|T_g=60)P(T_g=60) + P(T_r&lt;T_g|T_b=60)P(T_b=60) = \frac{30}{60}\times\frac{20}{30} + \frac{20}{60}\times\frac{30}{40} = \frac{7}{12}.$</p>

<h3 id="投掷硬币游戏">投掷硬币游戏</h3>

<p><strong>AB轮流掷硬币，假如背面朝上的下一次为正面朝上则游戏结束，掷出背面的人赢，请问A赢的概率为多少？</strong></p>

<p>$P(A) = \frac{1}{2}P(A|H) + \frac{1}{2}P(A|T)$
$P(A|H) = \frac{1}{2} + \frac{1}{2}(1-P(A|H)) \Rightarrow P(A|H) = \frac{1}{3}.$
$P(A|T) = P(B) = 1-P(A)$
因此$P(A) = \frac{1}{6}+\frac{1}{2}(1-P(A)) \Rightarrow P(A)=\frac{4}{9}.$</p>

<h3 id="俄罗斯转盘">俄罗斯转盘</h3>

<p><strong>一发子弹装在容量为6的手枪内，两个人轮流开枪，你可以选择第一个来还是第二个来，你该怎么选择？</strong></p>

<p>注意，当游戏开始，谁死就已经固定了，如果子弹在1、3、5管内则第一个人死，2、4、6则第二个人死，因此概率就是$\frac{1}{2}$.</p>

<p><strong>如果每次开枪都重新旋转枪管呢？</strong></p>

<p>设第一个人输的概率为$p$，则$p=\frac{1}{6} + \frac{5}{6}(1-p) \Rightarrow p = \frac{6}{11}.$所以应该选第二个开枪。</p>

<p><strong>如果装了两发子弹，对手第一个开枪并且没事，给你选择是否转动枪管再开枪，你该怎么选择？</strong></p>

<p>转了的话这轮活的那就是$\frac{2}{3}$，不转的话这轮活的概率是$\frac{2}{5}.$因此需要转。</p>

<p><strong>如果两个子弹被装在了连续的两个位置，对手第一个开枪并且没事，给你选择是否转动枪管再开枪，你该怎么选择？</strong></p>

<p>转的话活的概率还是$\frac{2}{3}$，不转的话，活的概率为$\frac{3}{4}$，因此不要转。</p>

<h3 id="ace">Ace</h3>
<p><strong>52张牌发给4个人，每人13张，他们每个人都有一个A的概率是多少？</strong></p>

<p>给4个人发牌总共有$\frac{52!}{13!13!13!13!}$种情况，如果每人都有一个A，可以先考虑先发A，共有$4!$种可能，再发剩余48张牌，共有$\frac{48!}{12!12!12!12!}$种可能，因此概率为$\frac{52}{52}\times \frac{39}{51} \times \frac{26}{50} \times \frac{13}{49}$.</p>

<p>如果用条件概率的话逻辑会更清晰，第一张A肯定有$\frac{52}{52}$的概率属于一个人，第二张A在另一个人手里的概率为$\frac{39}{51}$，以此类推，即可得到最终概率。</p>

<h3 id="赌博问题">赌博问题</h3>

<p><strong>一个赌博的人初始有$i$元，每一轮游戏，他有p的概率赢1元，有q=1-p的概率输1元，他要么有了N元或者输光才会停止，请问他最后拥有N元的概率为多少？</strong></p>

<p>设$P_i$为初始为$i$元时赢到N的概率，那么有</p>

\[P_i = pP_{i+1}+qP_{i-1} \Rightarrow P_{i+1}-P_i = \frac{q}{p}(P_i-P_{i-1}) = \cdots = (\frac{q}{p})^i(P_1-P_0)\]

<p>我们有$P_0=0,P_N=1$,我们可以开始计算
$P_1 = pP_2 + qP_0 \Rightarrow P_2=(1+\frac{q}{p})P_1$
$P_3 = (1+\frac{q}{p} + (\frac{q}{p})^2)P_1$
以此类推，
$P_N = 1 = [1+\frac{q}{p}+\cdots + (\frac{q}{p})^{N-1}]P_1 =\begin{cases}
    \frac{1-(q/p)^N}{1-q/p}P_1,\ q/p\neq 1 <br />
    NP_1,\ q/p = 1
\end{cases}$
可以求出$P_1$再求出$P_i$.</p>

<h3 id="篮球分数">篮球分数</h3>

<p><strong>运动员投100个球，投进得一分，她又中了第一个，第二个没投中，后续她的命中率是她过去投中的比例，那么她刚好得到50分的概率为多少？</strong></p>

<p>令$P_{n,k}$为投n个球后得到k分的概率，可以观察到$P_{3,1} = \frac{1}{2}, P_{3,2}=\frac{1}{2}.$</p>

\[\begin{cases}
    P_{4,1} = P((4,1)|(3,1))P_{3,1} + P((4,1)|(3,2))P_{3,2} = \frac{1}{3} \\
    P_{4,2} = P((4,2)|(3,1))P_{3,1} + P((4,2)|(3,2))P_{3,2} = \frac{1}{3} \\ 
    P_{4,3} = P((4,3)|(3,1))P_{3,1} + P((4,3)|(3,2))P_{3,2} = \frac{1}{3} 
\end{cases}\]

<p>因此可以用数学归纳法证明$P_{n,k}=\frac{1}{n-1}\Rightarrow P_{100,50} = \frac{1}{99}.$</p>

<h3 id="路上的车">路上的车</h3>

<p>如果在任意20分钟时间段观察到高速上至少有一辆车的概率为$\frac{609}{625}$，那么在任意5分钟时间段观察到至少有一辆车的概率为多少？假设在20分钟内的任意时间观察到一辆车的概率都是一致的。</p>

<p>$1 - \frac{609}{625} = (1-p)^4 \Rightarrow p=\frac{3}{5}.$</p>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="量化绿皮书" /><summary type="html"><![CDATA[事件及其概率]]></summary></entry><entry><title type="html">绿皮书第二章：Brain Teasers</title><link href="http://localhost:4000/2024/09/10/QuantitiveChap2/" rel="alternate" type="text/html" title="绿皮书第二章：Brain Teasers" /><published>2024-09-10T10:00:00+08:00</published><updated>2024-09-10T10:00:00+08:00</updated><id>http://localhost:4000/2024/09/10/QuantitiveChap2</id><content type="html" xml:base="http://localhost:4000/2024/09/10/QuantitiveChap2/"><![CDATA[<h2 id="问题简化">问题简化</h2>

<h3 id="海盗分金">海盗分金</h3>

<p>五名海盗抢劫了一个装满 100 枚金币的箱子。 作为一群民主海盗，他们同意以下分配战利品的方法：最资深的海盗将提议分配硬币。 所有海盗，包括最资深的海盗，都将投票。如果至少 50% 的海盗（在这种情况下为 3 名海盗）接受该提议，则按提议分配金币。 如果没有，最高级的海盗将被喂给鲨鱼，这个过程从下一个最高级的海盗开始。重复这个过程，直到计划被批准。 你可以假设所有的海盗都是完全理性的：他们想先活下去，然后尽可能多地获得金币。 最后，作为嗜血的海盗，如果可以选择的话，就算自己获得的金币是一样的，他们希望船上的海盗数量越少越好。</p>

<p><strong>金币最终会如何分配？</strong></p>

<ol>
  <li>1个海盗不用分，都是自己的；</li>
  <li>2个海盗也不用分，资深的（第1个）那个肯定全分给自己，因为自己占50%的投票，所以分法是（Remaining，0）；</li>
  <li>3个海盗时，最资深的（第1个）知道2个海盗时，第3个海盗会一枚也得不到，因此会给他一枚，而第2个海盗就别想得到了，因为第1个海盗的策略已经得到2/3人的支持，因此分法是（Remaining，0,1）；</li>
  <li>4个海盗时，最资深的（第1个）知道3个海盗时，第3个海盗会一枚也得不到，因此给他一枚获得他的投票，其他两个海盗不给，投票50%也能通过，因此分法是（Remaining，0,1,0）</li>
  <li>如此动态推下去，分法是（Remaining，0，1,0,1，…, x） 如果海盗数为偶数，x 为0；否则x为1。</li>
</ol>

<h3 id="老虎和羊">老虎和羊</h3>
<p>100只老虎和1只羊被放在一个只有草的魔法岛上。 老虎可以吃草，但他们宁愿吃羊。 假设： A. 每次只有一只老虎可以吃一只羊，而那只老虎在吃完羊后自己也会变成一只羊。 B. 所有的老虎都很聪明，完全理性，它们都想活着。 那么羊会被吃掉吗？</p>

<ol>
  <li>1只老虎，羊肯定被吃，因为老虎吃完羊后变成羊，依然可以活着，没有其他老虎会吃他；</li>
  <li>2只老虎，羊不被吃，因为先吃羊的那只老虎会被后面一直老虎吃掉，所以哪一只都不会先吃羊，达成一个平衡；</li>
  <li>3只老虎，羊被吃，先想出两只老虎情况下羊会不被吃的那只老虎，会吃了羊变成羊，然后活下去；</li>
  <li>4只老虎，羊不被吃，因为剩下3只老虎会吃掉变成羊的那只老虎，所以没有老虎会去吃羊，达成平衡；</li>
  <li>如此类推，偶数只老虎时，羊不被吃，而奇数只老虎时，羊会被吃。 回到本题，100只老虎，则羊不会被吃。</li>
</ol>

<h2 id="逻辑推理">逻辑推理</h2>

<h3 id="快速过河">快速过河</h3>
<p>A、B、C、D 四个人需要过河。 过河的唯一方法是通过一座旧桥，一次最多可容纳 2 人。 天黑了，他们没有手电筒就不能过桥，而他们只有一个手电筒。 所以每一对只能以较慢的人的速度行走。 他们需要尽快将所有这些人带到另一边。 A是最慢的，需要10分钟才能通过； B 需要 5 分钟； C 需要 2 分钟； D 需要 1 分钟。</p>

<p><strong>那么过河最短的时间是多少，方案是什么？</strong></p>

<ol>
  <li>第一趟，让C、D通过，然后C或者D一个人，返回送手电筒；假设为D，则时间为 2 + 1；</li>
  <li>第二趟，让A、B通过，然后C或者D剩下的那个人返回送手电，按第一趟的假设，这次应该是C，则时间为10+2；</li>
  <li>第三趟，C、D通过，用时2分钟。
此时，全部人都到对岸，总用时3+12+2 = 17分钟。</li>
</ol>

<h3 id="猜生日">猜生日</h3>
<p>您和您的同事都知道您的老板 A 的生日是以下 10 个日期之一：
3 月 4 日、3 月 5 日、3 月 8 日
6 月 4 日，6 月 7 日
9 月 1 日，9 月 5 日
12 月 1 日、12 月 2 日、12 月 8 日</p>

<p>A 只告诉了你他生日的月份，并告诉了你的同事 C 生日的号数。 之后，你先说：“我不知道A的生日，C也不知道。” 听完你的话，C回答说：“我不知道A的生日，现在我知道了。” 你笑着说：“现在我也知道了。” 在查看了 10 个日期并听取了您的意见后，您的行政助理没有问任何问题就记下了 A 的生日。 那么助理写了什么？</p>

<ol>
  <li>“C也不知道”，说明我所知道的月份里，对应的号数都是重复的，这样6月和12月被排除，因为如果C拿到7日或者2日，那就很容易知道生日是哪天。所以现在剩下3月和9月。</li>
  <li>C已经推理到月份只有3月和9月，那么C能推出生日，说明肯定不是5号，这样 3月5日和9月5日被排除。</li>
  <li>“现在我也知道了。”这句判断的前提是知道3月5日和9月5日被排除，还剩3月两天，和9月一天。如果你拿到的是3月，肯定没有信心判断是哪天，那么唯一的可能是你拿到的是9月，所以生日是9月1号。</li>
</ol>

<h3 id="花色牌">花色牌</h3>
<p>赌场提供使用一副普通 52 张牌的纸牌游戏。 规则是你每次翻两张牌。对于每一对，如果两者都是黑色的，则进入庄家的牌堆； 如果两者都是红色的，它们会进入你的堆； 如果一黑一红，则丢弃。 重复该过程，直到你们两个通过所有 52 张卡。 如果您的牌堆中有更多牌，您将赢得 100 美元； 否则（包括牌数相同的情况）你什么也得不到。 赌场允许您协商要为游戏支付的价格。 你愿意花多少钱来玩这个游戏？</p>

<p>一毛钱都不给。因为不管怎么发牌，最终牌数都是相同的。</p>

<h3 id="烧绳计时">烧绳计时</h3>
<p>你有两根绳子，每根绳子都可以燃烧一个小时。 但是任何一根绳子密度不均，密的地方烧的慢，疏的地方烧的快，不能保证绳子不同段燃烧速度的一致性。 你如何用这两条绳子测量 45 分钟？</p>

<p>首先<strong>点燃一根的两头和另一根的一头</strong>，开始计时。当两头烧的烧完了，计时半小时，同时<strong>点燃另一个绳子的另一头</strong>，让它也两头烧，重新计时，当它烧完时，计时15分钟。两个加起来就是45分钟。</p>

<h3 id="用天平区分次品球">用天平区分次品球</h3>
<p>有12个球，其中有一个球是次品，跟其他球的重量不一样，是更重还是更轻不清楚。现有一个天平，请问用3次天平测量，如何测出次品球来，并区分是重还是轻。</p>

<div align="center"> <img src="/pic/QuantGuideBook/DefectiveBall.jpg" width="600" /> </div>
<p>这里面有规律，如果球的缺陷类别（重或轻）已知，则可以用M次测量区分3^M个球中的一个次品球；如果缺陷类别未知，则可以区分(3^M-3)/2个球中的一个次品球。</p>

<h3 id="阶乘尾0的个数">阶乘尾0的个数</h3>
<p>100！的尾部有几个0？</p>

<ol>
  <li>分析相乘产生0 的情况。2<em>5 = 10； 4</em>25 = 100 =4<em>5</em>5。 也就是一个5乘一个偶数就能得到1个0，偶数比5的个数要多得多，所以0的个数，取决于能分解出多少个5。那么（5,10，…,100）能分解出多少个5？</li>
  <li>
    <p>（5,10,…，100）除以5，有（1,2，…，20），含20个5，另外（1,2，…，20）中还有4个5，因为（5,10,15,20），除以5有（1,2,3,4），没5了，所以总共含有24个5，也就是有24个0。</p>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>那么1000！呢？ [5,1000]</td>
          <td>200 + [5,200]</td>
          <td>40 + [5,40]</td>
          <td>8 + [5,8]</td>
          <td>1 = 249个</td>
        </tr>
      </tbody>
    </table>
  </li>
</ol>

<h3 id="无限序列">无限序列</h3>
<p>$x^{x^{\cdots}} = 2$，求 x</p>

<p>解答：无限序列的情况，用迭代的思想列方程，$x^{x^{\cdots}} = x^{x^{x^{\cdots}}} = x^2 = 2 \Rightarrow x = \sqrt{2}.$</p>

<h3 id="赛马比赛">赛马比赛</h3>

<p>有25匹马，一次比赛只能跑五匹马，问最少用多少次比赛可以找到前三个最快的。</p>

<ol>
  <li>先分五组跑五次，设1，6，11，16，21为各组第一；</li>
  <li>他们五个再跑一次，假设排名就是1，6，11，16，21；</li>
  <li>1肯定是最快的，再让2，3，6，7，11跑一次就可以了。</li>
</ol>

<h2 id="跳出思维框架">跳出思维框架</h2>

<h3 id="打包箱子">打包箱子</h3>
<p>请问能否把53块1x1x4的砖块放到6x6x6的箱子里？</p>

<p>这题是国际象棋题的升级版。国际象棋的题目是二维的，而箱子是三维的，更难一些，但是解法都是一样的。从国际象棋题展开来说。如图象棋棋盘是黑白相间的64个小方格，假设都为1x1，现在拿去对角线上的两个小方块，请问，还能否放入31个1x2的方格进去？</p>

<div align="center"> <img src="/pic/QuantGuideBook/BoxPacking.jpg" width="600" /> </div>

<p>管怎么放1x2的方格，都会占据1黑1白两个方格。那么最多能放几个1x2方格，取决于黑格或者白格的数量最少的那个。本来64个，黑白各32个，但是移除对角线的两个方格，是同颜色的，那么就还剩下30个黑32个白，或者30个白32个黑，所以不论什么情况，最多是30个，占据的面积是60，有两个不相连的方格剩下。</p>

<p>按照这个套路，解决箱子问题。用小正方体给它上色，也就是2x2x2的小箱子。这样的小箱子总共有3x3x3=27个，然后他们颜色相间的话，只能是13黑14白或者13白14黑。同时因为两个黑白的小箱子能装4块砖（底面积是4倍），所以总共能装的是13x4 等于52块砖。注定有一块2x2x2的小箱子浪费。</p>

<h3 id="日历骰子">日历骰子</h3>
<p>用2个自制的骰子（6面），刻画所有月份里的天数，仅仅是天数。其中第一天为01，一个骰子显示0，一个显示1。那么请问该如何设计这两个骰子。</p>

<ol>
  <li>012345</li>
  <li>012678</li>
  <li>6和9是对称的，只要刻一个数字就可以表达2个数</li>
</ol>

<h3 id="offer之门">offer之门</h3>
<p>假如两个守卫守着两扇门，一扇通往offer，一扇“谢谢你的投递，but you failed”。两守卫一个诚实只说真话，一个狡猾只说假话。你只能问其中一个守卫一句只能用yes/or回答的问题，你如何问，才能顺利打开offer之门？</p>

<p><strong>问其中一个守卫“另一个守卫会说你守的是offer门吗？”，如果该守卫说是的，则选另一扇门，如果说No，那就是这扇门。</strong></p>

<h3 id="挂锁快递">挂锁快递</h3>
<p>你想给上海的朋友发快递送物资，但是最近时局动荡，没上锁的快递不安全，东西会丢，需要用挂锁箱子运送。但是目前你跟你朋友各自有一把锁，但是各自都只有一把钥匙，那么应该怎么送，物资才能安全送达？</p>

<p>第一趟送的时候挂你的锁，安全送到上海，但是你朋友打不开。没关系，你朋友在箱子上又挂了一把他自己的锁，然后快递送回来，你把自己的锁解开，再快递到上海，这时候，就是你朋友的锁在保护物资了。平安到上海后，你朋友就可以打开箱子获得物资了。</p>

<h3 id="最后一球的颜色">最后一球的颜色</h3>
<p>如果袋子里有20个蓝球，14个红球。每次抽两个球，不放回，扔掉。如果抽出的是同色的，往袋子里添加一个蓝球；如果是不同色的，则添加一个红球。假设球足够进行这些操作。请问，袋子里最后一个球是什么颜色的？如果是20个蓝球，13个红球呢？</p>

<p>观察各个组合带来的蓝球和红球的变动规律，蓝球奇数变动，要么加1要么减1；红球要么不变，要么减2，都是偶数变动。所以<strong>如果14个红球的话，最后肯定变成0，13个红球的话最后肯定变成1。</strong></p>

<h3 id="控制灯的开关是哪个">控制灯的开关是哪个</h3>
<p>屋外有四个开关，屋内有一盏灯，其中只有一个开关控制灯。你在屋外不能及时看到灯的状态。请问至少需要进屋几次才能分辨出控制灯的开关是哪个，该如何操作。</p>

<p>灯除了明灭的信息，还有冷热的信息，那么两种状态（亮否，热否）可以表示四种可能情况。那么我们可以先闭合1和2开关，等待一段时间。然后把开关2断开，合上开关3，立即进屋查看灯的两种状态。判断规则如下：</p>

<ol>
  <li>如果灯是亮且热的，那么开关1控制；</li>
  <li>如果灯是亮但不热的，那么开关3控制；</li>
  <li>如果灯是暗但热的，那么开关2控制；</li>
  <li>如果等是暗且不热的，那么开关4控制。</li>
</ol>

<h3 id="求量化平均工资">求量化平均工资</h3>
<p>5个量化工程师去酒吧喝酒，他们好奇量化行业的平均工资是多少，但是又不想暴露自己的收入情况。请问有什么方法可以在不暴露各自收入的情况下，求得他们的收入均值？</p>

<p>第一个工程师设置一个随机初值，写上自己的收入与初值的加和，然后传递给第二个工程师；第二个工程师也加上自己的收入，依次加总完后，将数据给第一个工程师，他将最后的总数减去随机初值，然后除以人数，就是他们收入的均值。这里并没有泄露任何人的真实收入。</p>

<h2 id="巧用对称性">巧用对称性</h2>

<h3 id="确保两堆硬币有同样数量的字面朝上">确保两堆硬币有同样数量的字面朝上</h3>
<p>假设有1000个硬币，其中有20个字面朝上，980个花面朝上；你不能通过触摸感受硬币是哪一面，但是你可以无限次数的翻转硬币。请问怎么分，才能确保分出来的两堆硬币字面朝上的硬币数量相同？</p>

<p>假设给第一堆分了n个硬币，其中有m个字面朝上的，那么另一堆则有1000-n个硬币，其中20-m个字面朝上。我们要确保两边的字面朝上，且手段只有翻面。那么</p>

<p><strong>从1000个硬币中随机选20个，不管这20个里面是否有字面朝上的硬币，都给翻转过来，就能保证这两堆里，字面朝上的硬币数量相等。</strong></p>

<h3 id="打错标签的水果袋">打错标签的水果袋</h3>
<p>有三袋水果，分别装着梨、苹果以及苹果和梨的混装。每个袋子外面打了相应的标签，但是现在水果店老板告诉你，标签都打错了，你可以拿出水果来判断袋子的正确标签，那么请问怎么拿最少次数水果，更正所有的标签？你可以拿无数次，袋子是非透明的。</p>

<ol>
  <li>一次即可，从标记为混装的袋子里拿水果，拿出来的是梨，那么这个袋子里装的就全是梨；拿出来的是苹果，那么这个袋子里装的就全是苹果。它不会出现混装的情况，因为题目告诉了，所有标签都错了。</li>
  <li>假设我们从混装袋子里拿出的是梨，那么标签为梨的袋子里装的肯定是苹果，标签为苹果的就是混装。</li>
</ol>

<h3 id="智者斗酋长">智者斗酋长</h3>
<p>野人酋长抓了50个智者。每分钟他随机抓一个智者去问话，问话前每个智者可以翻转大堂门口的一个玻璃杯，也可以不翻转。如果智者可以肯定地正确地回答“所有智者至少被酋长问过一次话”，那么酋长会放了所有人。否则，回答错误的话，也就是说不是所有人都被问过话，但有智者回答是，那么所有人会被献祭。在他们被关到各自牢房（一人一间）前，他们可以聚集一次商量对策。 那么智者该如何应对才能活下来。被问话的智者是随机且无限次抽取的。不回答不视为答错，智者在没把握的时候可以选择不回答。</p>

<ol>
  <li>非破题人初次被喊话：
    <ol>
      <li>如果杯子是正放的，倒置它（发出信号，等待破题人接收）</li>
      <li>如果杯子是倒置的，不操作；（另一个人发出的信号，且未被破题人归置，也就是信号还未传达至破题人）</li>
    </ol>
  </li>
  <li>非破题人非初次被喊话：
    <ol>
      <li>如果自己未翻转过杯子且杯子是正放的，倒置它；（发出自己的信号，等到接收）</li>
      <li>如果自己已经翻转过杯子，则不做任何操作；</li>
    </ol>
  </li>
  <li>破题人：
    <ol>
      <li>如果杯子是倒置的，计数+1，然后摆正杯子；（接收到信号，1人至少被问话一次）</li>
      <li>如果杯子是正放的，不做操作。这样计数到49时，就可以答题了。</li>
    </ol>
  </li>
</ol>

<h2 id="数列求和">数列求和</h2>

<h3 id="钟表碎片">钟表碎片</h3>
<p>一块钟表刻度为1,2，…，12，摔碎成了连续的3块，且每块的刻度数字和相同，请问碎成了哪三块？</p>

<p>第一块肯定是11,12,1,2；那么往两边推，11点前面的是10,9，加8就超过26了，然后2点往后是3,4, 所以第二块是9,10,3,4；剩下的为第三块，7,8,5,6。</p>

<h3 id="缺失的整数">缺失的整数</h3>
<p>1到100个整数里，缺了两个，问怎么快速得到这个缺失值？</p>

<p>分别求一次和和二次和，列两个方程，然后解方程。</p>

<h3 id="快速定位劣币袋子">快速定位劣币袋子</h3>
<p>有10袋子硬币，每袋100个硬币，每个真币重10克。其中有一袋的硬币全是假币，可能比真硬币重1克，也可能轻1克（全都重或者全都轻）。现在有个电子秤，请问如何用最少的次数称重，找出假币的袋子？</p>

<p><strong>第一个袋子拿1个硬币，第二个袋子拿2个硬币，如此类推，第10个袋子拿10个硬币</strong>，这样假硬币的数量就能反向指出袋子的编号。</p>

<p>类似的还有用二进制序列来区分试剂药品之类的题。比如有1000罐药，其中有一罐有毒，一点就致命，但是需要一天才能显现效果，现在有10只小白鼠，问该如何测试，才能最快把毒药辨别出来？方法是混合试剂，用2进制的方式混。如第9罐药，对应10位的2进制为“0000001001”，也就是喂第7只和第10只小白鼠喝第9罐药（一丁点）。如此类推，将药罐的编号变换为对应的10位2进制，然后为1的数对应的小白鼠喝药，最后看小白鼠的死亡pattern，转换成对应的二进制数，再换算成药罐的序号，就可以在一天内找到毒药。</p>

<p><strong>不管是连续序列，还是2进制变换，本质是要找到一种传递信息或者区分的方式。</strong></p>

<h3 id="100楼层测试玻璃球硬度">100楼层测试玻璃球硬度</h3>
<p>假设你有两颗玻璃球，楼有100层，采用楼层高度表述玻璃球的硬度。当球从小于X层往下掉时不会碎，而当从大于等于X层处下落时会碎。那么考虑最坏的情况，应该怎么测试才能最小化球下落的次数，从而测试出玻璃球的硬度。</p>

<p>假设最坏情况，我们至少要扔N次玻璃球。第一球从N层下落，如果碎了，第二个球从1层开始测到N-1层，肯定能测出X；如果第一球层N层下落，没碎，那么下一步，需要从第N+N-1层下落进行测试，因为如果碎了，另一球可以从N+1层测试到2N -2层，测试N-2次；如此类推，第一球如果没碎，则每次间隔减少1层，直到在N次测试时，覆盖100层楼，也就是 N+（N-1）+(N-2)+… + 1 &gt;=100, 求得N&gt;=14，取最小值14，也就是最少扔14次，不论怎么样，可以测出球的硬度。</p>

<h2 id="鸽笼原理">鸽笼原理</h2>
<p>n只鸽笼，mn+1只鸽子，分配到各个鸽笼里，至少有一只笼子里的鸽子不小于m+1只，也就是至少有m+1只鸽子要共享一只笼子。</p>

<h3 id="袜子成对">袜子成对</h3>
<p>假设你有黄绿红三色袜子x, y, z只（x，y，z均大于0，x+y+z&gt;3），请问随机取，取多少次一定能配上一对？</p>

<p>4次。</p>

<h3 id="是否有两人握手次数相同">是否有两人握手次数相同</h3>
<p>假如你是新上任的领导，第一次去见你的n个团队成员，他们列成一排一一跟你握手。同时他们之间也有新来的相互不认识也会互相握手打招呼。那么请问你是否能肯定地说，“这些人中，至少有两人握手的次数是相同的”。</p>

<p>n+1个人，每个人握手1到n次，因此一定至少有两人握手的次数是相同的。</p>

<h3 id="我们之前见过吗">我们之前见过吗</h3>
<p>晚会上有6人，证明要么至少3人是熟人，要么至少3人是陌生人。</p>

<p>首先，假设我是第六个人，至少有三个人见过我或者没见过我。</p>

<ol>
  <li>如果有三个人见过我：如果有两个互相见过，那加上我就是三个；否则他们三个是陌生人。</li>
  <li>如果有三个人没见过我：如果有两个是陌生人，加上我就是三个；否则他们三个是熟人。</li>
</ol>

<h3 id="正方形中的蚂蚁">正方形中的蚂蚁</h3>

<p>一个边长为1的正方形中有51个蚂蚁，你有一个1/7半径的瓶子，是否能找到一个地方放瓶子能盖住至少三个蚂蚁？</p>

<p>可以的。首先将正方形分为5x5个小正方形，肯定有一个上至少有三个蚂蚁。同时 <strong>$1/5 &lt; \sqrt{2}/7$说明瓶子能盖住这个小正方形。</strong></p>

<h3 id="找假币ii">找假币II</h3>

<p>现在有五个袋子，每个里面有100个硬币，每个袋子中的硬币都是相同的，但是有可能是9g、10g或者11g。我们不知道每个袋子里装的是哪种硬币，你需要几次测量来得到每个袋子中的硬币种类？</p>

<ol>
  <li>如果只有两个袋子的话，此时解空间有9种可能，那么我们就需要第一个袋子取1个，第二个袋子取3个，这样总和在-4到4中间，正好是9个情况：
    <div align="center"> <img src="/pic/QuantGuideBook/Coin2.jpg" width="600" /> </div>
  </li>
  <li>三个袋子的话，有27个可能，第三个袋子就需要取9个。</li>
  <li>以此类推，我们需要从每个袋子中依次取1,3,9,27,81个来测量就可以了。</li>
</ol>

<h2 id="取余运算">取余运算</h2>

<h3 id="猜帽子颜色">猜帽子颜色</h3>

<p>有100个犯人，每个人会给一个红色或者蓝色帽子，他们可以看到别人的帽子但看不到自己的，每个人都会被随机叫去猜自己帽子颜色，猜对了就放走，请问最多能让多少犯人活下来？</p>

<p>可以至少让99个活下来，第一个犯人如果看到红色帽子个数为奇数就说自己是红色的，否则说自己是蓝色的。这样其他人都能推断出自己帽子是什么颜色的。</p>

<p>三个颜色也是一样的道理。</p>

<h3 id="被9整除">被9整除</h3>
<p>给定一个整数，证明为什么各个位数相加能被9整除，原数就能被9整除。</p>

<p>$a=a_n10^n+\cdots+a_1 10^1 + a_0, a_n+\cdots+a_0 = 9x \Rightarrow 
b = a_n(10^n-1)+\cdots+a_1(10^1-1) = a - 9x$
b是可以被9整除的，因此a可以被9整除。</p>

<p>同理可证$(-1)^na_n+\cdots+(-1)a_1+a_0$ 被 11 整除 当且仅当 a 可以被11整除。</p>

<h3 id="变色龙颜色">变色龙颜色</h3>

<p>岛屿上有13个红色变色龙，15个绿色和17个蓝色，每当两只不同颜色的变色龙相遇时就会变成第三种颜色，请问最后他们会变成同一种颜色吗？</p>

<p>假如(m+1,n+1,p+1)可以变成同一种颜色，那么(m,n,p)也是可以的。因此我们考虑(0,2,4)即可，而(0,2,4)是永远变不到(0,0,6)的。</p>

<h2 id="数学归纳法">数学归纳法</h2>

<h3 id="硬币分配问题">硬币分配问题</h3>
<p>假如有1000个硬币，分为两堆，分别有x和y个，此时相乘得到xy，再分别将两堆进行划分，此时得到xy+x1x2+y1y2，以此类推直到每堆只有一个硬币，请问最后的和是多少？</p>

<p>证明$f(n)=\frac{n(n-1)}{2}$即可。</p>

<h3 id="巧克力问题">巧克力问题</h3>

<p>一个6x8的巧克力，需要多少下才能掰成48个小块呢？</p>

<p>证明$f(m,n) = mn-1$即可。</p>

<h3 id="卡车出发点">卡车出发点</h3>

<p>一个环形路上有N个加油站，每个加油站的油量总和是支撑得住车开一圈的，假设最初车没油，请问如何选取加油站作为出发点才能跑完一圈？</p>

<p>Leetcode的一道贪心问题。
设油为x_1,…,x_N，路程油耗为y_1,…,y_N。从头开始遍历，如果x_1+…+x_m &lt; y_1+…+y_m，就将起点设为m+1，再从m+1重新从0计算油量和油耗。</p>

<h2 id="反证法">反证法</h2>

<h3 id="证明sqrt2是无理数">证明$\sqrt{2}$是无理数</h3>

<p>假设$\sqrt{2} = \frac{a}{b}$并且gcd(a,b)=1，则有$a^2 = 2b^2$，a为偶数且a被4整除，因此b也是偶数，这就出现了矛盾。</p>

<h3 id="彩虹帽">彩虹帽</h3>

<p>有七个犯人，每个人带彩虹中的一个颜色的帽子，他们能看到别人的帽子但看不到自己的。让他们猜自己帽子的颜色，有一个猜对的就解放，请问是否能够做到。</p>

<p>设七个颜色分别对应0,1,2,3,4,5,6，记每个人的帽子颜色为$x_i$，他们的猜测为$g_i$，那么就让每个人$(g_i+\sum_{k\neq i}x_k) \% 7 = i$</p>

<p>如果$g_i\neq x_i$，那么 $\sum_{i=1}^7 x_i \% 7 \neq i, i=0,1,2,3,4,5,6$，这样就出现了矛盾。</p>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="量化绿皮书" /><summary type="html"><![CDATA[问题简化]]></summary></entry></feed>