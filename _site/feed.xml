<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2024-09-26T16:48:37+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Liujiyu’s blog</title><subtitle>learn &amp; record</subtitle><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><entry><title type="html">概率论:随机变量（绿皮书+额外补充）</title><link href="http://localhost:4000/2024/09/26/Probability2/" rel="alternate" type="text/html" title="概率论:随机变量（绿皮书+额外补充）" /><published>2024-09-26T10:00:00+08:00</published><updated>2024-09-26T10:00:00+08:00</updated><id>http://localhost:4000/2024/09/26/Probability2</id><content type="html" xml:base="http://localhost:4000/2024/09/26/Probability2/"><![CDATA[]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="量化绿皮书" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">概率论:事件及其概率（绿皮书+额外补充）</title><link href="http://localhost:4000/2024/09/25/Probability/" rel="alternate" type="text/html" title="概率论:事件及其概率（绿皮书+额外补充）" /><published>2024-09-25T10:00:00+08:00</published><updated>2024-09-25T10:00:00+08:00</updated><id>http://localhost:4000/2024/09/25/Probability</id><content type="html" xml:base="http://localhost:4000/2024/09/25/Probability/"><![CDATA[<h1 id="事件及其概率">事件及其概率</h1>

<h2 id="基础的概率定义和集合操作">基础的概率定义和集合操作</h2>

<h3 id="掷硬币游戏">掷硬币游戏</h3>

<p><strong>A有$(n+1)$个公平的硬币而B有$n$个，如果他们将所有的硬币抛掷，A能有更多正面朝上硬币的概率是多少？</strong></p>

<p>可以从A的硬币中取走一个，那么此时A和B是对称的，此时有三种情况：</p>
<ol>
  <li>A的n个硬币正面朝上的更多，概率记作$P(E_1)=x$.</li>
  <li>一样多，概率记作$P(E_2)=y$.</li>
  <li>B的更多，概率记作$P(E_3)=x$.</li>
</ol>

<p>此时再考虑最后一枚硬币，对于第一个情况，A始终有更多的正面朝上的硬币；对于第二种情况，最后一枚硬币需要朝上；第三种情况则A不可能有更多的正面朝上的硬币，因此概率为$x+0.5y = 0.5.$</p>

<h3 id="扑克游戏">扑克游戏</h3>

<p><strong>现在有52张牌，你拿一张然后荷官拿一张，如果你的数字大你才赢，那么你赢的概率是多少？</strong></p>

<p>可以直接去计算概率$P=\frac{1}{13} \times \left( \frac{0}{51} + \frac{4}{51} + \cdots \frac{48}{51}\right) = \frac{8}{17}$.</p>

<p>但是也可以换一个方法，把情况分为三种：你的牌大、相等、小于荷官的牌，此时$P(E_1) = P(E_3) = \frac{1}{2}(1-P(E_2)) = \frac{1}{2}(1-\frac{3}{51}) = \frac{8}{17}.$</p>

<h3 id="喝醉的乘客">喝醉的乘客</h3>

<p><strong>有100个乘客在排队上飞机，每个人都有自己的位置，但是第一个人喝多了，随便找个位置就坐了，假设其他人如果能坐自己的位置的话就会坐自己的，如果自己的位置被坐了就会随机坐一个，假如你是第100个登机的，请问你能坐在自己位置的概率是多少？</strong></p>

<p>只要有人坐在第一个位置上，后面的乘客都将坐在自己对应的位置上，因此实际上就是计算第一个位置比第100个位置先被坐下的概率，因为两个座位是同等对称的，所以就是50%.</p>

<h3 id="圆上的n个点">圆上的n个点</h3>

<p><strong>N个点随机扔在一个圆周上，它们能在同一个半圆内的概率是多少？</strong></p>

<p>$1,\cdots, i-1,i+1,\cdots, N$个点都在从第$i$个点开始顺时针的半圆上记为事件$E_i$，可以看出$E_1,\cdots,E_N$都是彼此互斥的，
因此$P(E) = P(\cup_{i=1}^N E_i) = \sum_{i=1}^N P(E_i) = \sum_{i=1}^N \frac{1}{2^{N-1}} = \frac{N}{2^{N-1}}.$</p>

<p>类似的如果弧长为$x$弧度的话概率就是$N\times x^{N-1}$.</p>

<h2 id="组合分析">组合分析</h2>

<h3 id="扑克牌">扑克牌</h3>

<p><strong>52张牌，每个人拿五张，请问拿到four-of-a-kind的概率是多少？拿到葫芦的概率是多少？双对的概率是多少？</strong></p>

<ol>
  <li>$P(E_1) = \frac{C_{13}^1 \times 48}{C_{52}^{5}}$</li>
  <li>$P(E_2) = \frac{C_{13}^1 \times C_4^3 \times C_{12}^1 \times C_4^2}{C_{52}^5}$</li>
  <li>$P(E_3) = \frac{C_{13}^2 \times C_4^2 \times C_4^2}{C_{52}^5}$</li>
</ol>

<h3 id="古怪的海盗ii">古怪的海盗II</h3>

<p><strong>有11个海盗，为了保护财宝，决定至少要大于等于6个人才能开锁，人数足够的任意小组都可以打开锁，每个锁可以有多把钥匙但每把钥匙只能开一个锁，请问最少要对财宝上多少个锁？每个海盗有几个钥匙？</strong></p>

<p>任意五个人都不能打开锁，那就要对每个五人组合都有一个特殊的打不开的锁，那就是${11 \choose 5 } = 462$个锁，每个锁有6把钥匙，并且都给独特的一个6人组，也就是说不能有一个六人组每个人都有两个锁的钥匙。因此每个海盗有$462 * 6 / 11 = 252$个钥匙。</p>

<h3 id="象棋比赛">象棋比赛</h3>

<p><strong>一个比赛有$2^n$个选手，实力排名从高到低，$1&gt;2&gt;\cdots&gt;2^n$，比赛实行淘汰制，每轮胜者才能进入下一轮，除决赛外每一轮的对手对局都是随机的，请问1、2名选手能在决赛遇见的概率是多少？</strong></p>

<p>记$E_i$为第$i$轮二人没有碰见，则
$P(E) = P(E_1)\times P(E_2|E_1) \times \cdots \times P(E_{n-1}|E_1E_2\ldots E_{n-2}) = 
\frac{2^n-2}{2^n-1} \times \frac{2^{n-1}-2}{2^{n-1}-1} \times \cdots \frac{2}{3} = \frac{2^{n-1}}{2^n-1}$</p>

<h3 id="申请信">申请信</h3>

<p><strong>你准备投五家公司，有五个信封，每个都对应一个独特的简历，但你的孩子随便将简历放进去了，请问五个简历都装错的概率是多少？</strong></p>

<p>记$E_i$为第$i$个简历装入正确的信封，因此
$P(\cup_{i=1}^5 E_i) = \sum_{i=1}^5P(E_i) - \sum_{i_1&lt;i_2}P(E_iE_j) + \cdots + (-1)^6P(E_1\ldots E_5)$</p>

<p>$P(E_{i_1}\ldots E_{i_k}) = \frac{(5-k)!}{5!} \Rightarrow \sum P(E_{i_1}\ldots E_{i_k}) = \frac{1}{k!}$</p>

<p>因此$P(\cup_{i=1}^5 E_i)= 1 - \frac{1}{2!} + \frac{1}{3!} - \frac{1}{4!} + \frac{1}{5!} = \frac{19}{30} \Rightarrow P(E) = \frac{11}{30}.$</p>

<h3 id="生日问题">生日问题</h3>

<p><strong>需要多少个人才能做到有两个人同一天生日的概率大于0.5?</strong></p>

<p>假设有$n$个人，那么没有两个人同一天生日的概率为$P(\overline{E}) = \frac{A_{365}^n}{365^n} &lt; \frac{1}{2}$,可计算得到$n$最少为23.
<strong>分母表示每个人都不相同，因此分子是排列数而不是组合数。类似的问题有n个球放入N个盒子里，恰好有n个盒子里面有球的概率即为$\frac{A_N^n}{N^n}$.</strong></p>

<h3 id="100位小数">100位小数</h3>

<p><strong>请问$(1+\sqrt{2})^{3000}$的第100位小数是多少？</strong></p>

<p>$(1+\sqrt{2})^{3000} + (1-\sqrt{2})^{3000} = 2\sum_{k=2j, 0\leq j\leq 2/n} {n \choose k}\sqrt{2}^{k}$始终为整数，然而$(1-\sqrt{2})^{3000}$远小于$10^{-100}$，因此第100位小数为9.</p>

<h3 id="以11结尾的整数的三次方">以11结尾的整数的三次方</h3>
<p><strong>$x$为1到$10^{12}$中间的一个整数，请问x的三次方以11结尾的概率是多少？</strong></p>

<p>$x = a+10b \Rightarrow x^3 = a^3 + 30a^2b + 300ab^2 + 1000b^3.$
$x^3$的末尾只由$a^3$决定，因此$a=1$，此时又要保证$3b$是1为结尾，那么$b$的末尾数字必须是7，也就是说$x$的末尾两位数必须是71，因此概率为0.01.</p>

<h3 id="抽签问题">抽签问题</h3>

<p><strong>52张牌有a张红牌b张黑牌，放回或不放回抽n张的话，恰好有k张红牌的概率是多少？</strong></p>

<ol>
  <li>不放回的话概率为$\frac{C_a^k C_b^{n-k}}{C_N^n}.$</li>
  <li>放回的话可以考虑为一个二项分布，试验成功即为抓到红牌，则概率为${n \choose k}p^k(1-p)^{n-k}, p = \frac{a}{N}, 1-p = \frac{b}{N}.$</li>
</ol>

<h3 id="抽签问题ii">抽签问题II</h3>

<p><strong>编号为1到n的球，a个红球b个白球，每次摸一个不放回，摸n次，求第k次摸到红球的概率。</strong></p>

<p>将每次摸的球做一个排列，视为一个样本点，那么概率为$\frac{a(n-1)!}{n!} = \frac{a}{n}.$</p>

<h2 id="条件分布和贝叶斯公式">条件分布和贝叶斯公式</h2>

<table>
  <tbody>
    <tr>
      <td><strong>全概率公式</strong>：对于两两互斥的事件${F_i}$，他们的并集是整个样本空间，那么有$$ P(E) = \sum_{i=1}^n P(E</td>
      <td>F_i)P(F_i).$$</td>
    </tr>
  </tbody>
</table>

<p><strong>A、B事件相互独立</strong> $\Leftrightarrow P(AB)=P(A)P(B) \rightarrow P(AB^c)=P(A)P(B^c).$</p>

<p><strong>ABC事件两两独立</strong> $\Leftrightarrow P(AB)=P(A)P(B), P(AC)=P(A)P(C), P(BC)=P(B)P(C).$</p>

<p><strong>ABC事件相互独立</strong> $\Leftrightarrow P(ABC)=P(A)P(B)P(C) +$ABC两两独立.</p>

<table>
  <tbody>
    <tr>
      <td><strong>贝叶斯公式</strong>：$P(F_j</td>
      <td>E) = \frac{P(E</td>
      <td>F_j)P(F_j)}{\sum_{i=1}^n P(E</td>
      <td>F_i)P(F_i)}.$</td>
    </tr>
  </tbody>
</table>

<h3 id="男女孩">男女孩</h3>

<p><strong>公司为每个有至少一个儿子的妈妈准备晚宴，有两个孩子的Jack女士被邀请参加，她有两个儿子的概率是多少？</strong></p>

<table>
  <tbody>
    <tr>
      <td>$P(A</td>
      <td>B) = \frac{P(AB)}{P(B)} = \frac{1/4}{3/4} = \frac{1}{3}.$</td>
    </tr>
  </tbody>
</table>

<p><strong>当你在路上看到Jack女士带着一个男孩在路上走，她有两个儿子的概率是多少？</strong></p>

<p>此时概率即为$\frac{1}{2}.$</p>

<p>这两个问题给的前提是不一样的，一个是至少有一个儿子，一个是其中一个是男孩。</p>

<h3 id="全是女孩的世界">全是女孩的世界？</h3>
<p><strong>在原始社会，每个夫妻都想有一个女儿，他们会一直要孩子直到生了一个女儿，他们就不再生孩子了，请问社会上女孩的比例最终会是多少？</strong></p>

<p>始终都会是50%，因为每生一个孩子是男是女的概率都是50%，这与夫妻行为无关。</p>

<h3 id="不公平的硬币">不公平的硬币</h3>

<p><strong>给你1000个硬币，有一个两边都是正面，你任意选一个硬币扔10次，每次都是正面向上，请问你这个硬币是不公平的硬币的概率是多少？</strong></p>

<p>记A为该硬币不公平，B为十次投掷均为正面向上，则有：
\(P(A|B) = \frac{P(B|A)P(A)}{P(B|A)P(A)+P(B|A^c)P(A^c)} 
\approx 0.5\)</p>

<h3 id="不公平硬币中寻找公平概率">不公平硬币中寻找公平概率</h3>

<p><strong>给你一个不公平硬币，正面朝上的概率是未知的，请问你可以用这个硬币得到50%概率的事件吗？</strong></p>

<p>投掷两次，先正后反记为输，先反后正记为赢，如果没出现这两种情况则重新再投掷两次。</p>

<h3 id="飞镖游戏">飞镖游戏</h3>

<p><strong>Jason扔两次飞镖，第二次比第一次偏离得多，请问第三次比第一次更远的概率为多少？</strong></p>

<p>三次从近到远记为A\B\C三个等级，枚举一下即可得到概率为$\frac{2}{3}$</p>

<p><strong>假如扔n次，后n-1次都比第一次远，那么他扔第n+1次比第一次也远的概率是多少？</strong></p>

<p>实际上就相当于n个人排列好了，第n+1个人随机站一个位置，他站到第一个位置的概率是多少，就是$\frac{n}{n+1}.$</p>

<h3 id="生日队列">生日队列</h3>

<p><strong>电影院管理说他会送排队的人中第一个生日与前面买过票的人生日一致的人一张票，请问你站在什么位置得到票的概率最高？</strong></p>

<p>p(n) = p(前n-1个人生日不同)*p(你的生日在前n-1个中) = $\frac{365\times\cdots\times (365-n+2)}{365^{n-1}}\times \frac{n-1}{365}.$ 求解不等式组$P(n)&gt;P(n-1), P(n) &gt; P(n+1)$可以得到$n=20.$</p>

<h3 id="骰子顺序">骰子顺序</h3>

<p><strong>你依次掷骰子三次，得到一个递增数列的概率是多少？</strong></p>

<table>
  <tbody>
    <tr>
      <td>当掷的三个数不同时，是一个递增数列的概率是$1/6$，这个与飞镖问题的道理一致，因此最终概率为$P(三个数不同)P(递增</td>
      <td>三个数不同) = (1\times \frac{5}{6} \times \frac{4}{6})\times \frac{1}{6} = \frac{5}{54}.$</td>
    </tr>
  </tbody>
</table>

<h3 id="monty-hall问题">Monty Hall问题</h3>

<p><strong>有三个门，其中一个是车，另外两个是羊，你现在选了一个门，Monty开了另外两个中有羊的一个，现在他给你机会换一个门，你要换吗，换门后赢的概率是多少？</strong></p>

<p>记A为不换门赢，C为主持人打开一个有羊的门。<strong>注意P(C)==1！</strong>
$P(A|C) = \frac{P(C|A)P(A)}{P(C|A)P(A)+P(C|A^c)P(A^c)} = \frac{1/3}{1/3+2/3} = \frac{1}{3}.$也就是说不换门赢当且仅当你最初选的就是有车的门，概率为$\frac{1}{3}$，那么换门赢的概率则为$\frac{2}{3}.$</p>

<h3 id="amoeba人口数">Amoeba人口数</h3>

<p><strong>池塘里有一个amoeba，每分钟它可能死，可能不变，可能分裂成两个或者三个，每个情况概率相同，请问最后amoeba死光的概率是多少？</strong></p>

<table>
  <tbody>
    <tr>
      <td>$P(E) = P(E</td>
      <td>F_1)P(F_1) + \cdots + P(E</td>
      <td>F_4)P(F_4)$</td>
    </tr>
    <tr>
      <td>1. 对于事件1，$P(E</td>
      <td>F_1) = 1.$</td>
      <td> </td>
    </tr>
    <tr>
      <td>2. 对于事件2，$P(E</td>
      <td>F_2) = P(E).$</td>
      <td> </td>
    </tr>
    <tr>
      <td>3. 对于事件3，$P(E</td>
      <td>F_3) = P(E)^2.$</td>
      <td> </td>
    </tr>
    <tr>
      <td>4. 对于事件4，$P(E</td>
      <td>F_4) = P(E)^3.$</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>因此$p = \frac{1}{4}(1+p+p^2+p^3) \Rightarrow p = \sqrt{2}-1.$</p>

<h3 id="盒子中的蜡烛">盒子中的蜡烛</h3>

<p><strong>盒子中有10个红蜡烛，20个蓝色，30个绿色的，你一个一个拿出来，请问当你拿出所有红蜡烛之后里面还至少有一个蓝色和一个绿色蜡烛的概率是多少？</strong></p>

<p>记最后一个红色、蓝色、绿色是在$T_r,T_b,T_g$次被拿出来，那么
$P(E) = P(T_r&lt;T_b \cap T_r&lt;T_g) = P(T_r&lt;T_b&lt;T_g) + P(T_r&lt;T_g&lt;T_b) = P(T_r&lt;T_b|T_g=60)P(T_g=60) + P(T_r&lt;T_g|T_b=60)P(T_b=60) = \frac{30}{60}\times\frac{20}{30} + \frac{20}{60}\times\frac{30}{40} = \frac{7}{12}.$</p>

<h3 id="投掷硬币游戏">投掷硬币游戏</h3>

<p><strong>AB轮流掷硬币，假如背面朝上的下一次为正面朝上则游戏结束，掷出背面的人赢，请问A赢的概率为多少？</strong></p>

<p>$P(A) = \frac{1}{2}P(A|H) + \frac{1}{2}P(A|T)$
$P(A|H) = \frac{1}{2} + \frac{1}{2}(1-P(A|H)) \Rightarrow P(A|H) = \frac{1}{3}.$
$P(A|T) = P(B) = 1-P(A)$
因此$P(A) = \frac{1}{6}+\frac{1}{2}(1-P(A)) \Rightarrow P(A)=\frac{4}{9}.$</p>

<h3 id="俄罗斯转盘">俄罗斯转盘</h3>

<p><strong>一发子弹装在容量为6的手枪内，两个人轮流开枪，你可以选择第一个来还是第二个来，你该怎么选择？</strong></p>

<p>注意，当游戏开始，谁死就已经固定了，如果子弹在1、3、5管内则第一个人死，2、4、6则第二个人死，因此概率就是$\frac{1}{2}$.</p>

<p><strong>如果每次开枪都重新旋转枪管呢？</strong></p>

<p>设第一个人输的概率为$p$，则$p=\frac{1}{6} + \frac{5}{6}(1-p) \Rightarrow p = \frac{6}{11}.$所以应该选第二个开枪。</p>

<p><strong>如果装了两发子弹，对手第一个开枪并且没事，给你选择是否转动枪管再开枪，你该怎么选择？</strong></p>

<p>转了的话这轮活的那就是$\frac{2}{3}$，不转的话这轮活的概率是$\frac{2}{5}.$因此需要转。</p>

<p><strong>如果两个子弹被装在了连续的两个位置，对手第一个开枪并且没事，给你选择是否转动枪管再开枪，你该怎么选择？</strong></p>

<p>转的话活的概率还是$\frac{2}{3}$，不转的话，活的概率为$\frac{3}{4}$，因此不要转。</p>

<h3 id="ace">Ace</h3>
<p><strong>52张牌发给4个人，每人13张，他们每个人都有一个A的概率是多少？</strong></p>

<p>给4个人发牌总共有$\frac{52!}{13!13!13!13!}$种情况，如果每人都有一个A，可以先考虑先发A，共有$4!$种可能，再发剩余48张牌，共有$\frac{48!}{12!12!12!12!}$种可能，因此概率为$\frac{52}{52}\times \frac{39}{51} \times \frac{26}{50} \times \frac{13}{49}$.</p>

<p>如果用条件概率的话逻辑会更清晰，第一张A肯定有$\frac{52}{52}$的概率属于一个人，第二张A在另一个人手里的概率为$\frac{39}{51}$，以此类推，即可得到最终概率。</p>

<h3 id="赌博问题">赌博问题</h3>

<p><strong>一个赌博的人初始有$i$元，每一轮游戏，他有p的概率赢1元，有q=1-p的概率输1元，他要么有了N元或者输光才会停止，请问他最后拥有N元的概率为多少？</strong></p>

<p>设$P_i$为初始为$i$元时赢到N的概率，那么有</p>

\[P_i = pP_{i+1}+qP_{i-1} \Rightarrow P_{i+1}-P_i = \frac{q}{p}(P_i-P_{i-1}) = \cdots = (\frac{q}{p})^i(P_1-P_0)\]

<p>我们有$P_0=0,P_N=1$,我们可以开始计算
$P_1 = pP_2 + qP_0 \Rightarrow P_2=(1+\frac{q}{p})P_1$
$P_3 = (1+\frac{q}{p} + (\frac{q}{p})^2)P_1$
以此类推，
$P_N = 1 = [1+\frac{q}{p}+\cdots + (\frac{q}{p})^{N-1}]P_1 =\begin{cases}
    \frac{1-(q/p)^N}{1-q/p}P_1,\ q/p\neq 1 <br />
    NP_1,\ q/p = 1
\end{cases}$
可以求出$P_1$再求出$P_i$.</p>

<h3 id="篮球分数">篮球分数</h3>

<p><strong>运动员投100个球，投进得一分，她又中了第一个，第二个没投中，后续她的命中率是她过去投中的比例，那么她刚好得到50分的概率为多少？</strong></p>

<p>令$P_{n,k}$为投n个球后得到k分的概率，可以观察到$P_{3,1} = \frac{1}{2}, P_{3,2}=\frac{1}{2}.$</p>

\[\begin{cases}
    P_{4,1} = P((4,1)|(3,1))P_{3,1} + P((4,1)|(3,2))P_{3,2} = \frac{1}{3} \\
    P_{4,2} = P((4,2)|(3,1))P_{3,1} + P((4,2)|(3,2))P_{3,2} = \frac{1}{3} \\ 
    P_{4,3} = P((4,3)|(3,1))P_{3,1} + P((4,3)|(3,2))P_{3,2} = \frac{1}{3} 
\end{cases}\]

<p>因此可以用数学归纳法证明$P_{n,k}=\frac{1}{n-1}\Rightarrow P_{100,50} = \frac{1}{99}.$</p>

<h3 id="路上的车">路上的车</h3>

<p>如果在任意20分钟时间段观察到高速上至少有一辆车的概率为$\frac{609}{625}$，那么在任意5分钟时间段观察到至少有一辆车的概率为多少？假设在20分钟内的任意时间观察到一辆车的概率都是一致的。</p>

<p>$1 - \frac{609}{625} = (1-p)^4 \Rightarrow p=\frac{3}{5}.$</p>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="量化绿皮书" /><summary type="html"><![CDATA[事件及其概率]]></summary></entry><entry><title type="html">绿皮书第二章：Brain Teasers</title><link href="http://localhost:4000/2024/09/10/QuantitiveChap2/" rel="alternate" type="text/html" title="绿皮书第二章：Brain Teasers" /><published>2024-09-10T10:00:00+08:00</published><updated>2024-09-10T10:00:00+08:00</updated><id>http://localhost:4000/2024/09/10/QuantitiveChap2</id><content type="html" xml:base="http://localhost:4000/2024/09/10/QuantitiveChap2/"><![CDATA[<h2 id="问题简化">问题简化</h2>

<h3 id="海盗分金">海盗分金</h3>

<p>五名海盗抢劫了一个装满 100 枚金币的箱子。 作为一群民主海盗，他们同意以下分配战利品的方法：最资深的海盗将提议分配硬币。 所有海盗，包括最资深的海盗，都将投票。如果至少 50% 的海盗（在这种情况下为 3 名海盗）接受该提议，则按提议分配金币。 如果没有，最高级的海盗将被喂给鲨鱼，这个过程从下一个最高级的海盗开始。重复这个过程，直到计划被批准。 你可以假设所有的海盗都是完全理性的：他们想先活下去，然后尽可能多地获得金币。 最后，作为嗜血的海盗，如果可以选择的话，就算自己获得的金币是一样的，他们希望船上的海盗数量越少越好。</p>

<p><strong>金币最终会如何分配？</strong></p>

<ol>
  <li>1个海盗不用分，都是自己的；</li>
  <li>2个海盗也不用分，资深的（第1个）那个肯定全分给自己，因为自己占50%的投票，所以分法是（Remaining，0）；</li>
  <li>3个海盗时，最资深的（第1个）知道2个海盗时，第3个海盗会一枚也得不到，因此会给他一枚，而第2个海盗就别想得到了，因为第1个海盗的策略已经得到2/3人的支持，因此分法是（Remaining，0,1）；</li>
  <li>4个海盗时，最资深的（第1个）知道3个海盗时，第3个海盗会一枚也得不到，因此给他一枚获得他的投票，其他两个海盗不给，投票50%也能通过，因此分法是（Remaining，0,1,0）</li>
  <li>如此动态推下去，分法是（Remaining，0，1,0,1，…, x） 如果海盗数为偶数，x 为0；否则x为1。</li>
</ol>

<h3 id="老虎和羊">老虎和羊</h3>
<p>100只老虎和1只羊被放在一个只有草的魔法岛上。 老虎可以吃草，但他们宁愿吃羊。 假设： A. 每次只有一只老虎可以吃一只羊，而那只老虎在吃完羊后自己也会变成一只羊。 B. 所有的老虎都很聪明，完全理性，它们都想活着。 那么羊会被吃掉吗？</p>

<ol>
  <li>1只老虎，羊肯定被吃，因为老虎吃完羊后变成羊，依然可以活着，没有其他老虎会吃他；</li>
  <li>2只老虎，羊不被吃，因为先吃羊的那只老虎会被后面一直老虎吃掉，所以哪一只都不会先吃羊，达成一个平衡；</li>
  <li>3只老虎，羊被吃，先想出两只老虎情况下羊会不被吃的那只老虎，会吃了羊变成羊，然后活下去；</li>
  <li>4只老虎，羊不被吃，因为剩下3只老虎会吃掉变成羊的那只老虎，所以没有老虎会去吃羊，达成平衡；</li>
  <li>如此类推，偶数只老虎时，羊不被吃，而奇数只老虎时，羊会被吃。 回到本题，100只老虎，则羊不会被吃。</li>
</ol>

<h2 id="逻辑推理">逻辑推理</h2>

<h3 id="快速过河">快速过河</h3>
<p>A、B、C、D 四个人需要过河。 过河的唯一方法是通过一座旧桥，一次最多可容纳 2 人。 天黑了，他们没有手电筒就不能过桥，而他们只有一个手电筒。 所以每一对只能以较慢的人的速度行走。 他们需要尽快将所有这些人带到另一边。 A是最慢的，需要10分钟才能通过； B 需要 5 分钟； C 需要 2 分钟； D 需要 1 分钟。</p>

<p><strong>那么过河最短的时间是多少，方案是什么？</strong></p>

<ol>
  <li>第一趟，让C、D通过，然后C或者D一个人，返回送手电筒；假设为D，则时间为 2 + 1；</li>
  <li>第二趟，让A、B通过，然后C或者D剩下的那个人返回送手电，按第一趟的假设，这次应该是C，则时间为10+2；</li>
  <li>第三趟，C、D通过，用时2分钟。
此时，全部人都到对岸，总用时3+12+2 = 17分钟。</li>
</ol>

<h3 id="猜生日">猜生日</h3>
<p>您和您的同事都知道您的老板 A 的生日是以下 10 个日期之一：
3 月 4 日、3 月 5 日、3 月 8 日
6 月 4 日，6 月 7 日
9 月 1 日，9 月 5 日
12 月 1 日、12 月 2 日、12 月 8 日</p>

<p>A 只告诉了你他生日的月份，并告诉了你的同事 C 生日的号数。 之后，你先说：“我不知道A的生日，C也不知道。” 听完你的话，C回答说：“我不知道A的生日，现在我知道了。” 你笑着说：“现在我也知道了。” 在查看了 10 个日期并听取了您的意见后，您的行政助理没有问任何问题就记下了 A 的生日。 那么助理写了什么？</p>

<ol>
  <li>“C也不知道”，说明我所知道的月份里，对应的号数都是重复的，这样6月和12月被排除，因为如果C拿到7日或者2日，那就很容易知道生日是哪天。所以现在剩下3月和9月。</li>
  <li>C已经推理到月份只有3月和9月，那么C能推出生日，说明肯定不是5号，这样 3月5日和9月5日被排除。</li>
  <li>“现在我也知道了。”这句判断的前提是知道3月5日和9月5日被排除，还剩3月两天，和9月一天。如果你拿到的是3月，肯定没有信心判断是哪天，那么唯一的可能是你拿到的是9月，所以生日是9月1号。</li>
</ol>

<h3 id="花色牌">花色牌</h3>
<p>赌场提供使用一副普通 52 张牌的纸牌游戏。 规则是你每次翻两张牌。对于每一对，如果两者都是黑色的，则进入庄家的牌堆； 如果两者都是红色的，它们会进入你的堆； 如果一黑一红，则丢弃。 重复该过程，直到你们两个通过所有 52 张卡。 如果您的牌堆中有更多牌，您将赢得 100 美元； 否则（包括牌数相同的情况）你什么也得不到。 赌场允许您协商要为游戏支付的价格。 你愿意花多少钱来玩这个游戏？</p>

<p>一毛钱都不给。因为不管怎么发牌，最终牌数都是相同的。</p>

<h3 id="烧绳计时">烧绳计时</h3>
<p>你有两根绳子，每根绳子都可以燃烧一个小时。 但是任何一根绳子密度不均，密的地方烧的慢，疏的地方烧的快，不能保证绳子不同段燃烧速度的一致性。 你如何用这两条绳子测量 45 分钟？</p>

<p>首先<strong>点燃一根的两头和另一根的一头</strong>，开始计时。当两头烧的烧完了，计时半小时，同时<strong>点燃另一个绳子的另一头</strong>，让它也两头烧，重新计时，当它烧完时，计时15分钟。两个加起来就是45分钟。</p>

<h3 id="用天平区分次品球">用天平区分次品球</h3>
<p>有12个球，其中有一个球是次品，跟其他球的重量不一样，是更重还是更轻不清楚。现有一个天平，请问用3次天平测量，如何测出次品球来，并区分是重还是轻。</p>

<div align="center"> <img src="/pic/QuantGuideBook/DefectiveBall.jpg" width="600" /> </div>
<p>这里面有规律，如果球的缺陷类别（重或轻）已知，则可以用M次测量区分3^M个球中的一个次品球；如果缺陷类别未知，则可以区分(3^M-3)/2个球中的一个次品球。</p>

<h3 id="阶乘尾0的个数">阶乘尾0的个数</h3>
<p>100！的尾部有几个0？</p>

<ol>
  <li>分析相乘产生0 的情况。2<em>5 = 10； 4</em>25 = 100 =4<em>5</em>5。 也就是一个5乘一个偶数就能得到1个0，偶数比5的个数要多得多，所以0的个数，取决于能分解出多少个5。那么（5,10，…,100）能分解出多少个5？</li>
  <li>
    <p>（5,10,…，100）除以5，有（1,2，…，20），含20个5，另外（1,2，…，20）中还有4个5，因为（5,10,15,20），除以5有（1,2,3,4），没5了，所以总共含有24个5，也就是有24个0。</p>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>那么1000！呢？ [5,1000]</td>
          <td>200 + [5,200]</td>
          <td>40 + [5,40]</td>
          <td>8 + [5,8]</td>
          <td>1 = 249个</td>
        </tr>
      </tbody>
    </table>
  </li>
</ol>

<h3 id="无限序列">无限序列</h3>
<p>$x^{x^{\cdots}} = 2$，求 x</p>

<p>解答：无限序列的情况，用迭代的思想列方程，$x^{x^{\cdots}} = x^{x^{x^{\cdots}}} = x^2 = 2 \Rightarrow x = \sqrt{2}.$</p>

<h3 id="赛马比赛">赛马比赛</h3>

<p>有25匹马，一次比赛只能跑五匹马，问最少用多少次比赛可以找到前三个最快的。</p>

<ol>
  <li>先分五组跑五次，设1，6，11，16，21为各组第一；</li>
  <li>他们五个再跑一次，假设排名就是1，6，11，16，21；</li>
  <li>1肯定是最快的，再让2，3，6，7，11跑一次就可以了。</li>
</ol>

<h2 id="跳出思维框架">跳出思维框架</h2>

<h3 id="打包箱子">打包箱子</h3>
<p>请问能否把53块1x1x4的砖块放到6x6x6的箱子里？</p>

<p>这题是国际象棋题的升级版。国际象棋的题目是二维的，而箱子是三维的，更难一些，但是解法都是一样的。从国际象棋题展开来说。如图象棋棋盘是黑白相间的64个小方格，假设都为1x1，现在拿去对角线上的两个小方块，请问，还能否放入31个1x2的方格进去？</p>

<div align="center"> <img src="/pic/QuantGuideBook/BoxPacking.jpg" width="600" /> </div>

<p>管怎么放1x2的方格，都会占据1黑1白两个方格。那么最多能放几个1x2方格，取决于黑格或者白格的数量最少的那个。本来64个，黑白各32个，但是移除对角线的两个方格，是同颜色的，那么就还剩下30个黑32个白，或者30个白32个黑，所以不论什么情况，最多是30个，占据的面积是60，有两个不相连的方格剩下。</p>

<p>按照这个套路，解决箱子问题。用小正方体给它上色，也就是2x2x2的小箱子。这样的小箱子总共有3x3x3=27个，然后他们颜色相间的话，只能是13黑14白或者13白14黑。同时因为两个黑白的小箱子能装4块砖（底面积是4倍），所以总共能装的是13x4 等于52块砖。注定有一块2x2x2的小箱子浪费。</p>

<h3 id="日历骰子">日历骰子</h3>
<p>用2个自制的骰子（6面），刻画所有月份里的天数，仅仅是天数。其中第一天为01，一个骰子显示0，一个显示1。那么请问该如何设计这两个骰子。</p>

<ol>
  <li>012345</li>
  <li>012678</li>
  <li>6和9是对称的，只要刻一个数字就可以表达2个数</li>
</ol>

<h3 id="offer之门">offer之门</h3>
<p>假如两个守卫守着两扇门，一扇通往offer，一扇“谢谢你的投递，but you failed”。两守卫一个诚实只说真话，一个狡猾只说假话。你只能问其中一个守卫一句只能用yes/or回答的问题，你如何问，才能顺利打开offer之门？</p>

<p><strong>问其中一个守卫“另一个守卫会说你守的是offer门吗？”，如果该守卫说是的，则选另一扇门，如果说No，那就是这扇门。</strong></p>

<h3 id="挂锁快递">挂锁快递</h3>
<p>你想给上海的朋友发快递送物资，但是最近时局动荡，没上锁的快递不安全，东西会丢，需要用挂锁箱子运送。但是目前你跟你朋友各自有一把锁，但是各自都只有一把钥匙，那么应该怎么送，物资才能安全送达？</p>

<p>第一趟送的时候挂你的锁，安全送到上海，但是你朋友打不开。没关系，你朋友在箱子上又挂了一把他自己的锁，然后快递送回来，你把自己的锁解开，再快递到上海，这时候，就是你朋友的锁在保护物资了。平安到上海后，你朋友就可以打开箱子获得物资了。</p>

<h3 id="最后一球的颜色">最后一球的颜色</h3>
<p>如果袋子里有20个蓝球，14个红球。每次抽两个球，不放回，扔掉。如果抽出的是同色的，往袋子里添加一个蓝球；如果是不同色的，则添加一个红球。假设球足够进行这些操作。请问，袋子里最后一个球是什么颜色的？如果是20个蓝球，13个红球呢？</p>

<p>观察各个组合带来的蓝球和红球的变动规律，蓝球奇数变动，要么加1要么减1；红球要么不变，要么减2，都是偶数变动。所以<strong>如果14个红球的话，最后肯定变成0，13个红球的话最后肯定变成1。</strong></p>

<h3 id="控制灯的开关是哪个">控制灯的开关是哪个</h3>
<p>屋外有四个开关，屋内有一盏灯，其中只有一个开关控制灯。你在屋外不能及时看到灯的状态。请问至少需要进屋几次才能分辨出控制灯的开关是哪个，该如何操作。</p>

<p>灯除了明灭的信息，还有冷热的信息，那么两种状态（亮否，热否）可以表示四种可能情况。那么我们可以先闭合1和2开关，等待一段时间。然后把开关2断开，合上开关3，立即进屋查看灯的两种状态。判断规则如下：</p>

<ol>
  <li>如果灯是亮且热的，那么开关1控制；</li>
  <li>如果灯是亮但不热的，那么开关3控制；</li>
  <li>如果灯是暗但热的，那么开关2控制；</li>
  <li>如果等是暗且不热的，那么开关4控制。</li>
</ol>

<h3 id="求量化平均工资">求量化平均工资</h3>
<p>5个量化工程师去酒吧喝酒，他们好奇量化行业的平均工资是多少，但是又不想暴露自己的收入情况。请问有什么方法可以在不暴露各自收入的情况下，求得他们的收入均值？</p>

<p>第一个工程师设置一个随机初值，写上自己的收入与初值的加和，然后传递给第二个工程师；第二个工程师也加上自己的收入，依次加总完后，将数据给第一个工程师，他将最后的总数减去随机初值，然后除以人数，就是他们收入的均值。这里并没有泄露任何人的真实收入。</p>

<h2 id="巧用对称性">巧用对称性</h2>

<h3 id="确保两堆硬币有同样数量的字面朝上">确保两堆硬币有同样数量的字面朝上</h3>
<p>假设有1000个硬币，其中有20个字面朝上，980个花面朝上；你不能通过触摸感受硬币是哪一面，但是你可以无限次数的翻转硬币。请问怎么分，才能确保分出来的两堆硬币字面朝上的硬币数量相同？</p>

<p>假设给第一堆分了n个硬币，其中有m个字面朝上的，那么另一堆则有1000-n个硬币，其中20-m个字面朝上。我们要确保两边的字面朝上，且手段只有翻面。那么</p>

<p><strong>从1000个硬币中随机选20个，不管这20个里面是否有字面朝上的硬币，都给翻转过来，就能保证这两堆里，字面朝上的硬币数量相等。</strong></p>

<h3 id="打错标签的水果袋">打错标签的水果袋</h3>
<p>有三袋水果，分别装着梨、苹果以及苹果和梨的混装。每个袋子外面打了相应的标签，但是现在水果店老板告诉你，标签都打错了，你可以拿出水果来判断袋子的正确标签，那么请问怎么拿最少次数水果，更正所有的标签？你可以拿无数次，袋子是非透明的。</p>

<ol>
  <li>一次即可，从标记为混装的袋子里拿水果，拿出来的是梨，那么这个袋子里装的就全是梨；拿出来的是苹果，那么这个袋子里装的就全是苹果。它不会出现混装的情况，因为题目告诉了，所有标签都错了。</li>
  <li>假设我们从混装袋子里拿出的是梨，那么标签为梨的袋子里装的肯定是苹果，标签为苹果的就是混装。</li>
</ol>

<h3 id="智者斗酋长">智者斗酋长</h3>
<p>野人酋长抓了50个智者。每分钟他随机抓一个智者去问话，问话前每个智者可以翻转大堂门口的一个玻璃杯，也可以不翻转。如果智者可以肯定地正确地回答“所有智者至少被酋长问过一次话”，那么酋长会放了所有人。否则，回答错误的话，也就是说不是所有人都被问过话，但有智者回答是，那么所有人会被献祭。在他们被关到各自牢房（一人一间）前，他们可以聚集一次商量对策。 那么智者该如何应对才能活下来。被问话的智者是随机且无限次抽取的。不回答不视为答错，智者在没把握的时候可以选择不回答。</p>

<ol>
  <li>非破题人初次被喊话：
    <ol>
      <li>如果杯子是正放的，倒置它（发出信号，等待破题人接收）</li>
      <li>如果杯子是倒置的，不操作；（另一个人发出的信号，且未被破题人归置，也就是信号还未传达至破题人）</li>
    </ol>
  </li>
  <li>非破题人非初次被喊话：
    <ol>
      <li>如果自己未翻转过杯子且杯子是正放的，倒置它；（发出自己的信号，等到接收）</li>
      <li>如果自己已经翻转过杯子，则不做任何操作；</li>
    </ol>
  </li>
  <li>破题人：
    <ol>
      <li>如果杯子是倒置的，计数+1，然后摆正杯子；（接收到信号，1人至少被问话一次）</li>
      <li>如果杯子是正放的，不做操作。这样计数到49时，就可以答题了。</li>
    </ol>
  </li>
</ol>

<h2 id="数列求和">数列求和</h2>

<h3 id="钟表碎片">钟表碎片</h3>
<p>一块钟表刻度为1,2，…，12，摔碎成了连续的3块，且每块的刻度数字和相同，请问碎成了哪三块？</p>

<p>第一块肯定是11,12,1,2；那么往两边推，11点前面的是10,9，加8就超过26了，然后2点往后是3,4, 所以第二块是9,10,3,4；剩下的为第三块，7,8,5,6。</p>

<h3 id="缺失的整数">缺失的整数</h3>
<p>1到100个整数里，缺了两个，问怎么快速得到这个缺失值？</p>

<p>分别求一次和和二次和，列两个方程，然后解方程。</p>

<h3 id="快速定位劣币袋子">快速定位劣币袋子</h3>
<p>有10袋子硬币，每袋100个硬币，每个真币重10克。其中有一袋的硬币全是假币，可能比真硬币重1克，也可能轻1克（全都重或者全都轻）。现在有个电子秤，请问如何用最少的次数称重，找出假币的袋子？</p>

<p><strong>第一个袋子拿1个硬币，第二个袋子拿2个硬币，如此类推，第10个袋子拿10个硬币</strong>，这样假硬币的数量就能反向指出袋子的编号。</p>

<p>类似的还有用二进制序列来区分试剂药品之类的题。比如有1000罐药，其中有一罐有毒，一点就致命，但是需要一天才能显现效果，现在有10只小白鼠，问该如何测试，才能最快把毒药辨别出来？方法是混合试剂，用2进制的方式混。如第9罐药，对应10位的2进制为“0000001001”，也就是喂第7只和第10只小白鼠喝第9罐药（一丁点）。如此类推，将药罐的编号变换为对应的10位2进制，然后为1的数对应的小白鼠喝药，最后看小白鼠的死亡pattern，转换成对应的二进制数，再换算成药罐的序号，就可以在一天内找到毒药。</p>

<p><strong>不管是连续序列，还是2进制变换，本质是要找到一种传递信息或者区分的方式。</strong></p>

<h3 id="100楼层测试玻璃球硬度">100楼层测试玻璃球硬度</h3>
<p>假设你有两颗玻璃球，楼有100层，采用楼层高度表述玻璃球的硬度。当球从小于X层往下掉时不会碎，而当从大于等于X层处下落时会碎。那么考虑最坏的情况，应该怎么测试才能最小化球下落的次数，从而测试出玻璃球的硬度。</p>

<p>假设最坏情况，我们至少要扔N次玻璃球。第一球从N层下落，如果碎了，第二个球从1层开始测到N-1层，肯定能测出X；如果第一球层N层下落，没碎，那么下一步，需要从第N+N-1层下落进行测试，因为如果碎了，另一球可以从N+1层测试到2N -2层，测试N-2次；如此类推，第一球如果没碎，则每次间隔减少1层，直到在N次测试时，覆盖100层楼，也就是 N+（N-1）+(N-2)+… + 1 &gt;=100, 求得N&gt;=14，取最小值14，也就是最少扔14次，不论怎么样，可以测出球的硬度。</p>

<h2 id="鸽笼原理">鸽笼原理</h2>
<p>n只鸽笼，mn+1只鸽子，分配到各个鸽笼里，至少有一只笼子里的鸽子不小于m+1只，也就是至少有m+1只鸽子要共享一只笼子。</p>

<h3 id="袜子成对">袜子成对</h3>
<p>假设你有黄绿红三色袜子x, y, z只（x，y，z均大于0，x+y+z&gt;3），请问随机取，取多少次一定能配上一对？</p>

<p>4次。</p>

<h3 id="是否有两人握手次数相同">是否有两人握手次数相同</h3>
<p>假如你是新上任的领导，第一次去见你的n个团队成员，他们列成一排一一跟你握手。同时他们之间也有新来的相互不认识也会互相握手打招呼。那么请问你是否能肯定地说，“这些人中，至少有两人握手的次数是相同的”。</p>

<p>n+1个人，每个人握手1到n次，因此一定至少有两人握手的次数是相同的。</p>

<h3 id="我们之前见过吗">我们之前见过吗</h3>
<p>晚会上有6人，证明要么至少3人是熟人，要么至少3人是陌生人。</p>

<p>首先，假设我是第六个人，至少有三个人见过我或者没见过我。</p>

<ol>
  <li>如果有三个人见过我：如果有两个互相见过，那加上我就是三个；否则他们三个是陌生人。</li>
  <li>如果有三个人没见过我：如果有两个是陌生人，加上我就是三个；否则他们三个是熟人。</li>
</ol>

<h3 id="正方形中的蚂蚁">正方形中的蚂蚁</h3>

<p>一个边长为1的正方形中有51个蚂蚁，你有一个1/7半径的瓶子，是否能找到一个地方放瓶子能盖住至少三个蚂蚁？</p>

<p>可以的。首先将正方形分为5x5个小正方形，肯定有一个上至少有三个蚂蚁。同时 <strong>$1/5 &lt; \sqrt{2}/7$说明瓶子能盖住这个小正方形。</strong></p>

<h3 id="找假币ii">找假币II</h3>

<p>现在有五个袋子，每个里面有100个硬币，每个袋子中的硬币都是相同的，但是有可能是9g、10g或者11g。我们不知道每个袋子里装的是哪种硬币，你需要几次测量来得到每个袋子中的硬币种类？</p>

<ol>
  <li>如果只有两个袋子的话，此时解空间有9种可能，那么我们就需要第一个袋子取1个，第二个袋子取3个，这样总和在-4到4中间，正好是9个情况：
    <div align="center"> <img src="/pic/QuantGuideBook/Coin2.jpg" width="600" /> </div>
  </li>
  <li>三个袋子的话，有27个可能，第三个袋子就需要取9个。</li>
  <li>以此类推，我们需要从每个袋子中依次取1,3,9,27,81个来测量就可以了。</li>
</ol>

<h2 id="取余运算">取余运算</h2>

<h3 id="猜帽子颜色">猜帽子颜色</h3>

<p>有100个犯人，每个人会给一个红色或者蓝色帽子，他们可以看到别人的帽子但看不到自己的，每个人都会被随机叫去猜自己帽子颜色，猜对了就放走，请问最多能让多少犯人活下来？</p>

<p>可以至少让99个活下来，第一个犯人如果看到红色帽子个数为奇数就说自己是红色的，否则说自己是蓝色的。这样其他人都能推断出自己帽子是什么颜色的。</p>

<p>三个颜色也是一样的道理。</p>

<h3 id="被9整除">被9整除</h3>
<p>给定一个整数，证明为什么各个位数相加能被9整除，原数就能被9整除。</p>

<p>$a=a_n10^n+\cdots+a_1 10^1 + a_0, a_n+\cdots+a_0 = 9x \Rightarrow 
b = a_n(10^n-1)+\cdots+a_1(10^1-1) = a - 9x$
b是可以被9整除的，因此a可以被9整除。</p>

<p>同理可证$(-1)^na_n+\cdots+(-1)a_1+a_0$ 被 11 整除 当且仅当 a 可以被11整除。</p>

<h3 id="变色龙颜色">变色龙颜色</h3>

<p>岛屿上有13个红色变色龙，15个绿色和17个蓝色，每当两只不同颜色的变色龙相遇时就会变成第三种颜色，请问最后他们会变成同一种颜色吗？</p>

<p>假如(m+1,n+1,p+1)可以变成同一种颜色，那么(m,n,p)也是可以的。因此我们考虑(0,2,4)即可，而(0,2,4)是永远变不到(0,0,6)的。</p>

<h2 id="数学归纳法">数学归纳法</h2>

<h3 id="硬币分配问题">硬币分配问题</h3>
<p>假如有1000个硬币，分为两堆，分别有x和y个，此时相乘得到xy，再分别将两堆进行划分，此时得到xy+x1x2+y1y2，以此类推直到每堆只有一个硬币，请问最后的和是多少？</p>

<p>证明$f(n)=\frac{n(n-1)}{2}$即可。</p>

<h3 id="巧克力问题">巧克力问题</h3>

<p>一个6x8的巧克力，需要多少下才能掰成48个小块呢？</p>

<p>证明$f(m,n) = mn-1$即可。</p>

<h3 id="卡车出发点">卡车出发点</h3>

<p>一个环形路上有N个加油站，每个加油站的油量总和是支撑得住车开一圈的，假设最初车没油，请问如何选取加油站作为出发点才能跑完一圈？</p>

<p>Leetcode的一道贪心问题。
设油为x_1,…,x_N，路程油耗为y_1,…,y_N。从头开始遍历，如果x_1+…+x_m &lt; y_1+…+y_m，就将起点设为m+1，再从m+1重新从0计算油量和油耗。</p>

<h2 id="反证法">反证法</h2>

<h3 id="证明sqrt2是无理数">证明$\sqrt{2}$是无理数</h3>

<p>假设$\sqrt{2} = \frac{a}{b}$并且gcd(a,b)=1，则有$a^2 = 2b^2$，a为偶数且a被4整除，因此b也是偶数，这就出现了矛盾。</p>

<h3 id="彩虹帽">彩虹帽</h3>

<p>有七个犯人，每个人带彩虹中的一个颜色的帽子，他们能看到别人的帽子但看不到自己的。让他们猜自己帽子的颜色，有一个猜对的就解放，请问是否能够做到。</p>

<p>设七个颜色分别对应0,1,2,3,4,5,6，记每个人的帽子颜色为$x_i$，他们的猜测为$g_i$，那么就让每个人$(g_i+\sum_{k\neq i}x_k) \% 7 = i$</p>

<p>如果$g_i\neq x_i$，那么 $\sum_{i=1}^7 x_i \% 7 \neq i, i=0,1,2,3,4,5,6$，这样就出现了矛盾。</p>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="量化绿皮书" /><summary type="html"><![CDATA[问题简化]]></summary></entry><entry><title type="html">Leetcode记录：Floyd算法</title><link href="http://localhost:4000/2024/09/01/Floyd/" rel="alternate" type="text/html" title="Leetcode记录：Floyd算法" /><published>2024-09-01T10:00:00+08:00</published><updated>2024-09-01T10:00:00+08:00</updated><id>http://localhost:4000/2024/09/01/Floyd</id><content type="html" xml:base="http://localhost:4000/2024/09/01/Floyd/"><![CDATA[<h2 id="floyd算法">Floyd算法</h2>

<p>小明喜欢去公园散步，公园内布置了许多的景点，相互之间通过小路连接，小明希望在观看景点的同时，能够节省体力，走最短的路径。给定一个公园景点图，图中有 N 个景点（编号为 1 到 N），以及 M 条双向道路连接着这些景点。每条道路上行走的距离都是已知的。</p>

<p>小明有 Q 个观景计划，每个计划都有一个起点 start 和一个终点 end，表示他想从景点 start 前往景点 end。由于小明希望节省体力，他想知道每个观景计划中从起点到终点的最短路径长度。 请你帮助小明计算出每个观景计划的最短路径长度。</p>

<p>这是经典的多源最短路径问题，Floyd算法对边的权值正负没有要求，都可以处理。Floyd算法核心思想是动态规划。</p>

<ol>
  <li>定义 <code class="language-plaintext highlighter-rouge">grid[i][j][k] = m</code> 表示 节点i 到 节点j 以[1…k] 集合为中间节点的最短距离为m。</li>
  <li>递推公式分为两个情况：i到j的最短路径是否经过k，因此有：
 <code class="language-plaintext highlighter-rouge">grid[i][j][k] = min(grid[i][k][k - 1] + grid[k][j][k - 1]， grid[i][j][k - 1])</code>.</li>
  <li>初始化：初始化k=0来表示没有中间节点，i直接到达j的距离，如果没有i-&gt;j的边，距离则设为一个最大值100000.</li>
  <li>递推顺序：k在最外层，i，j在内循环即可.</li>
</ol>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="数据结构与算法" /><summary type="html"><![CDATA[Floyd算法]]></summary></entry><entry><title type="html">Leetcode记录：Bellman-ford算法</title><link href="http://localhost:4000/2024/08/31/BellmanFord/" rel="alternate" type="text/html" title="Leetcode记录：Bellman-ford算法" /><published>2024-08-31T20:00:00+08:00</published><updated>2024-08-31T20:00:00+08:00</updated><id>http://localhost:4000/2024/08/31/BellmanFord</id><content type="html" xml:base="http://localhost:4000/2024/08/31/BellmanFord/"><![CDATA[<h2 id="bellman-ford算法">Bellman-ford算法</h2>

<p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。网络中的道路都有各自的运输成本和政府补贴，<strong>道路的权值计算方式为：运输成本 - 政府补贴。</strong>权值为正表示扣除了政府补贴后运输货物仍需支付的费用；权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p>

<p>请找出从城市 1 到城市 n 的所有可能路径中，综合政府补贴后的最低运输成本。如果最低运输成本是一个负数，它表示在遵循最优路径的情况下，运输过程中反而能够实现盈利。城市 1 到城市 n 之间可能会出现没有路径的情况，<strong>同时保证道路网络中不存在任何负权回路。</strong></p>

<p>Bellman-ford算法专门处理带负权值的单源最短路问题。<strong>Bellman_ford算法的核心思想是 对所有边进行松弛n-1次操作（n为节点数量），从而求得目标最短路。</strong></p>

<h3 id="松弛">松弛</h3>

<p>假设minDist[B]表示到达B节点最小权值，A可以花费value到达B，minDist[B] 有哪些状态可以推出来？</p>

<p>状态一： minDist[A] + value 可以推出 minDist[B] 状态二： minDist[B]本身就有权值 （可能是其他边链接的节点B 例如节点C，以至于 minDist[B]记录了其他边到minDist[B]的权值）。</p>

<p>那么minDist[B]应做出取舍，应该取二者最小值，这就是松弛操作。<strong>其实 Bellman_ford算法 也是采用了动态规划的思想，即：将一个问题分解成多个决策阶段，通过状态之间的递归关系最后计算出全局最优解。</strong></p>

<p><strong>对所有边松弛一次，相当于计算起点 到达 与起点一条边相连的 节点的最短距离</strong>，因此要对所有边松弛n-1次，才能得到起点到达所有节点的最短距离。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">;</span>

    <span class="c1">// 将所有边保存起来</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">p1</span> <span class="o">&gt;&gt;</span> <span class="n">p2</span> <span class="o">&gt;&gt;</span> <span class="n">val</span><span class="p">;</span>
        <span class="c1">// p1 指向 p2，权值为 val</span>
        <span class="n">grid</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">val</span><span class="p">});</span>

    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 起点</span>
    <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>    <span class="c1">// 终点</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">minDist</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>
    <span class="n">minDist</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 对所有边 松弛 n-1 次</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">side</span> <span class="o">:</span> <span class="n">grid</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 每一次松弛，都是对所有边进行松弛</span>
            <span class="kt">int</span> <span class="n">from</span> <span class="o">=</span> <span class="n">side</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// 边的出发点</span>
            <span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="n">side</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// 边的到达点</span>
            <span class="kt">int</span> <span class="n">price</span> <span class="o">=</span> <span class="n">side</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// 边的权值</span>
            <span class="c1">// 松弛操作 </span>
            <span class="c1">// minDist[from] != INT_MAX 防止从未计算过的节点出发</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">minDist</span><span class="p">[</span><span class="n">from</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INT_MAX</span> <span class="o">&amp;&amp;</span> <span class="n">minDist</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">minDist</span><span class="p">[</span><span class="n">from</span><span class="p">]</span> <span class="o">+</span> <span class="n">price</span><span class="p">)</span> <span class="p">{</span> 
                <span class="n">minDist</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="n">minDist</span><span class="p">[</span><span class="n">from</span><span class="p">]</span> <span class="o">+</span> <span class="n">price</span><span class="p">;</span>  
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">minDist</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">==</span> <span class="n">INT_MAX</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"unconnected"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 不能到达终点</span>
    <span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">minDist</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 到达终点最短路径</span>

<span class="p">}</span>
</code></pre></div></div>
<p>时间复杂度： O(N * E) , N为节点数量，E为图中边的数量
空间复杂度： O(N) ，即 minDist 数组所开辟的空间</p>

<h2 id="bellman-ford队列优化算法">Bellman-ford队列优化算法</h2>

<p>Bellman_ford 算法 每次都是对所有边进行松弛，其实是多做了一些无用功。<strong>只需要对上一次松弛的时候更新过的节点作为出发节点所连接的边 进行松弛就够了。</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Edge</span> <span class="p">{</span> <span class="c1">//邻接表</span>
    <span class="kt">int</span> <span class="n">to</span><span class="p">;</span>  <span class="c1">// 链接的节点</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span> <span class="c1">// 边的权重</span>

    <span class="n">Edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">w</span><span class="p">)</span><span class="o">:</span> <span class="n">to</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">val</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="p">{}</span>  <span class="c1">// 构造函数</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">list</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> 

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">isInQueue</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 加入优化，已经在队里里的元素不用重复添加</span>

    <span class="c1">// 将所有边保存起来</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">p1</span> <span class="o">&gt;&gt;</span> <span class="n">p2</span> <span class="o">&gt;&gt;</span> <span class="n">val</span><span class="p">;</span>
        <span class="c1">// p1 指向 p2，权值为 val</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">p1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">Edge</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">val</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 起点</span>
    <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>    <span class="c1">// 终点</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">minDist</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>
    <span class="n">minDist</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">que</span><span class="p">;</span>
    <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">start</span><span class="p">);</span> 

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>

        <span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">isInQueue</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 从队列里取出的时候，要取消标记，我们只保证已经在队列里的元素不用重复加入</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">Edge</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">grid</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">from</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="n">to</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="n">val</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">minDist</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">minDist</span><span class="p">[</span><span class="n">from</span><span class="p">]</span> <span class="o">+</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 开始松弛</span>
                <span class="n">minDist</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="n">minDist</span><span class="p">[</span><span class="n">from</span><span class="p">]</span> <span class="o">+</span> <span class="n">value</span><span class="p">;</span> 
                <span class="k">if</span> <span class="p">(</span><span class="n">isInQueue</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 已经在队列里的元素不用重复添加</span>
                    <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">to</span><span class="p">);</span>
                    <span class="n">isInQueue</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">minDist</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">==</span> <span class="n">INT_MAX</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"unconnected"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 不能到达终点</span>
    <span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">minDist</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 到达终点最短路径</span>
<span class="p">}</span>
</code></pre></div></div>

<p>队列优化版Bellman_ford 的时间复杂度 并不稳定，效率高低依赖于图的结构。一般来说，SPFA 的时间复杂度为 O(K * N) K 为不定值，因为 节点需要计入几次队列取决于图的稠密度。如果图是一条线形图且单向的话，每个节点的入度为1，那么只需要加入一次队列，这样时间复杂度就是 O(N)。</p>

<p>所以 SPFA 在最坏的情况下是 O(N * E)，但 一般情况下 时间复杂度为 O(K * N)。</p>

<p>在有环且只有正权回路的情况下，即使元素重复加入队列，最后，也会因为 所有边都松弛后，节点数值（minDist数组）不在发生变化了 而终止。（而且有重复元素加入队列是正常的，多条路径到达同一个节点，节点必要要选择一个最短的路径，而这个节点就会重复加入队列进行判断，选一个最短的）</p>

<p><strong>但是如果有负权回路的话，就会出现死循环！</strong></p>

<h2 id="bellman-ford判断负权回路">Bellman-ford判断负权回路</h2>

<p>可以在做完n-1次松弛之后再做一次，查看minDist是否会继续变化，如果发生变化则代表存在负权回路：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">p1</span> <span class="o">&gt;&gt;</span> <span class="n">p2</span> <span class="o">&gt;&gt;</span> <span class="n">val</span><span class="p">;</span>
        <span class="c1">// p1 指向 p2，权值为 val</span>
        <span class="n">grid</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">val</span><span class="p">});</span>

    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 起点</span>
    <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>    <span class="c1">// 终点</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">minDist</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>
    <span class="n">minDist</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 这里我们松弛n次，最后一次判断负权回路</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">side</span> <span class="o">:</span> <span class="n">grid</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">from</span> <span class="o">=</span> <span class="n">side</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="n">side</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">price</span> <span class="o">=</span> <span class="n">side</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">minDist</span><span class="p">[</span><span class="n">from</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INT_MAX</span> <span class="o">&amp;&amp;</span> <span class="n">minDist</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">minDist</span><span class="p">[</span><span class="n">from</span><span class="p">]</span> <span class="o">+</span> <span class="n">price</span><span class="p">)</span> <span class="n">minDist</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="n">minDist</span><span class="p">[</span><span class="n">from</span><span class="p">]</span> <span class="o">+</span> <span class="n">price</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 多加一次松弛判断负权回路</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">minDist</span><span class="p">[</span><span class="n">from</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INT_MAX</span> <span class="o">&amp;&amp;</span> <span class="n">minDist</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">minDist</span><span class="p">[</span><span class="n">from</span><span class="p">]</span> <span class="o">+</span> <span class="n">price</span><span class="p">)</span> <span class="n">flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

            <span class="p">}</span>
        <span class="p">}</span>

    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"circle"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">minDist</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">==</span> <span class="n">INT_MAX</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"unconnected"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">minDist</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>也可以用SFPA来做，多加一个count数组判断每个节点被加入了多少次队列，如果达到n次则说明存在负权回路：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Edge</span> <span class="p">{</span> <span class="c1">//邻接表</span>
    <span class="kt">int</span> <span class="n">to</span><span class="p">;</span>  <span class="c1">// 链接的节点</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span> <span class="c1">// 边的权重</span>

    <span class="n">Edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">w</span><span class="p">)</span><span class="o">:</span> <span class="n">to</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">val</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="p">{}</span>  <span class="c1">// 构造函数</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">list</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 邻接表</span>

    <span class="c1">// 将所有边保存起来</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">p1</span> <span class="o">&gt;&gt;</span> <span class="n">p2</span> <span class="o">&gt;&gt;</span> <span class="n">val</span><span class="p">;</span>
        <span class="c1">// p1 指向 p2，权值为 val</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">p1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">Edge</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">val</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 起点</span>
    <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>    <span class="c1">// 终点</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">minDist</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>
    <span class="n">minDist</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">que</span><span class="p">;</span>
    <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">start</span><span class="p">);</span> <span class="c1">// 队列里放入起点 </span>
    
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">count</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 记录节点加入队列几次</span>
    <span class="n">count</span><span class="p">[</span><span class="n">start</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>

        <span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">Edge</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">grid</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">from</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="n">to</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="n">val</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">minDist</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">minDist</span><span class="p">[</span><span class="n">from</span><span class="p">]</span> <span class="o">+</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 开始松弛</span>
                <span class="n">minDist</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="n">minDist</span><span class="p">[</span><span class="n">from</span><span class="p">]</span> <span class="o">+</span> <span class="n">value</span><span class="p">;</span>
                <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">to</span><span class="p">);</span>
                <span class="n">count</span><span class="p">[</span><span class="n">to</span><span class="p">]</span><span class="o">++</span><span class="p">;</span> 
                <span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span><span class="c1">// 如果加入队列次数超过 n-1次 就说明该图与负权回路</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"circle"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">minDist</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">==</span> <span class="n">INT_MAX</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"unconnected"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">minDist</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="bellman-ford之单源有限最短路径">Bellman-ford之单源有限最短路径</h2>

<p>例题：请计算在最多经过 k 个城市的条件下，从城市 src 到城市 dst 的最低运输成本。</p>

<p>前面讲Bellman-ford的时候提到过，对所有边松弛一次，相当于计算 起点到达 与起点<strong>一条边</strong>相连的节点 的最短距离。
最多经过k个城市就是k + 1条边相连的节点。因此我们对所有边松弛k+1次即可。</p>

<p>但是这道题可能会出现负权回路，如果我们只是简单地把松弛n-1次改成k+1次会出现错误：</p>

<div align="center"> <img src="/pic/DS/Bellman-Ford.png" width="400" /> </div>

<p>第二次松弛开始，每次松弛都会导致所有节点距离-1，这里要做的就是每次更新都要根据上一次的minDist来更新：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span><span class="n">k</span> <span class="p">,</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">val</span> <span class="p">,</span><span class="n">m</span> <span class="p">,</span> <span class="n">n</span><span class="p">;</span>
    
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">p1</span> <span class="o">&gt;&gt;</span> <span class="n">p2</span> <span class="o">&gt;&gt;</span> <span class="n">val</span><span class="p">;</span>
        <span class="n">grid</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">val</span><span class="p">});</span>
    <span class="p">}</span>

    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">src</span> <span class="o">&gt;&gt;</span> <span class="n">dst</span> <span class="o">&gt;&gt;</span> <span class="n">k</span><span class="p">;</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">minDist</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>
    <span class="n">minDist</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">minDist_copy</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 用来记录上一次遍历的结果</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">minDist_copy</span> <span class="o">=</span> <span class="n">minDist</span><span class="p">;</span> <span class="c1">// 获取上一次计算的结果</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">side</span> <span class="o">:</span> <span class="n">grid</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">from</span> <span class="o">=</span> <span class="n">side</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="n">side</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">price</span> <span class="o">=</span> <span class="n">side</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
            <span class="c1">// 注意使用 minDist_copy 来计算 minDist </span>
            <span class="k">if</span> <span class="p">(</span><span class="n">minDist_copy</span><span class="p">[</span><span class="n">from</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INT_MAX</span> <span class="o">&amp;&amp;</span> <span class="n">minDist</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">minDist_copy</span><span class="p">[</span><span class="n">from</span><span class="p">]</span> <span class="o">+</span> <span class="n">price</span><span class="p">)</span> <span class="p">{</span>  
                <span class="n">minDist</span><span class="p">[</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="n">minDist_copy</span><span class="p">[</span><span class="n">from</span><span class="p">]</span> <span class="o">+</span> <span class="n">price</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">minDist</span><span class="p">[</span><span class="n">dst</span><span class="p">]</span> <span class="o">==</span> <span class="n">INT_MAX</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"unreachable"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 不能到达终点</span>
    <span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">minDist</span><span class="p">[</span><span class="n">dst</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 到达终点最短路径</span>

<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="数据结构与算法" /><summary type="html"><![CDATA[Bellman-ford算法]]></summary></entry><entry><title type="html">Leetcode记录：拓扑排序</title><link href="http://localhost:4000/2024/08/31/TopoSort/" rel="alternate" type="text/html" title="Leetcode记录：拓扑排序" /><published>2024-08-31T15:00:00+08:00</published><updated>2024-08-31T15:00:00+08:00</updated><id>http://localhost:4000/2024/08/31/TopoSort</id><content type="html" xml:base="http://localhost:4000/2024/08/31/TopoSort/"><![CDATA[<p>例子：某个大型软件项目的构建系统拥有 N 个文件，文件编号从 0 到 N - 1，在这些文件中，某些文件依赖于其他文件的内容，这意味着如果文件 A 依赖于文件 B，则必须在处理文件 A 之前处理文件 B （0 &lt;= A, B &lt;= N - 1）。请编写一个算法，用于确定文件处理的顺序。</p>

<p>概括来说，<strong>给出一个有向图，把这个有向图转成线性的排序就叫拓扑排序。</strong></p>

<p>当然拓扑排序也要检测这个有向图 是否有环，即存在循环依赖的情况，因为这种情况是不能做线性排序的。<strong>所以拓扑排序也是图论中判断有向无环图的常用方法。</strong></p>

<p>实现拓扑排序的算法有两种：<strong>卡恩算法（BFS）和DFS</strong>，接下来我们来讲解BFS的实现思路：当我们做拓扑排序的时候，应该优先找入度为0的节点，只有入度为0，它才是出发节点。之后将其去掉，再寻找入度为0的节点即可。</p>

<p>因此，拓扑排序的过程，其实就两步：</p>
<ol>
  <li>找到入度为0 的节点，加入结果集</li>
  <li>将该节点从图中移除</li>
</ol>

<p><strong>如果我们发现结果集元素个数不等于图中节点个数，我们就可以认定图中一定有有向环！这也是拓扑排序判断有向环的方法。</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">inDegree</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 记录每个文件的入度</span>

    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">umap</span><span class="p">;</span><span class="c1">// 记录文件依赖关系</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span> <span class="c1">// 记录结果</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">m</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// s-&gt;t，先有s才能有t</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="n">t</span><span class="p">;</span>
        <span class="n">inDegree</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">++</span><span class="p">;</span> <span class="c1">// t的入度加一</span>
        <span class="n">umap</span><span class="p">[</span><span class="n">s</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="c1">// 记录s指向哪些文件</span>
    <span class="p">}</span>

    <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">que</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 入度为0的文件，可以作为开头，先加入队列</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">inDegree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="c1">//cout &lt;&lt; inDegree[i] &lt;&lt; endl;</span>
    <span class="p">}</span>
    <span class="c1">// int count = 0;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">que</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="c1">// 当前选中的文件</span>
        <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="c1">//count++;</span>
        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">files</span> <span class="o">=</span> <span class="n">umap</span><span class="p">[</span><span class="n">cur</span><span class="p">];</span> <span class="c1">//获取该文件指向的文件</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">files</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// cur有后续文件</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">files</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">inDegree</span><span class="p">[</span><span class="n">files</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">--</span><span class="p">;</span> <span class="c1">// cur的指向的文件入度-1</span>
                <span class="k">if</span><span class="p">(</span><span class="n">inDegree</span><span class="p">[</span><span class="n">files</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="数据结构与算法" /><summary type="html"><![CDATA[例子：某个大型软件项目的构建系统拥有 N 个文件，文件编号从 0 到 N - 1，在这些文件中，某些文件依赖于其他文件的内容，这意味着如果文件 A 依赖于文件 B，则必须在处理文件 A 之前处理文件 B （0 &lt;= A, B &lt;= N - 1）。请编写一个算法，用于确定文件处理的顺序。]]></summary></entry><entry><title type="html">Leetcode记录：最小生成树</title><link href="http://localhost:4000/2024/08/31/MST/" rel="alternate" type="text/html" title="Leetcode记录：最小生成树" /><published>2024-08-31T10:00:00+08:00</published><updated>2024-08-31T10:00:00+08:00</updated><id>http://localhost:4000/2024/08/31/MST</id><content type="html" xml:base="http://localhost:4000/2024/08/31/MST/"><![CDATA[<h2 id="prim算法">prim算法</h2>

<p>prim算法 是从节点的角度 采用贪心的策略 每次寻找距离 最小生成树最近的节点 并加入到最小生成树中。其算法核心就是三步：</p>

<ol>
  <li>选距离生成树最近节点</li>
  <li>最近节点加入生成树</li>
  <li>更新非生成树节点到生成树的距离（即更新minDist数组）</li>
</ol>

<p>时间复杂度为O(n^2), n为节点数量。</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="n">e</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="n">e</span><span class="p">;</span>
    <span class="c1">// 填一个默认最大值，题目描述val最大为10000</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10001</span><span class="p">));</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">e</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span> <span class="o">&gt;&gt;</span> <span class="n">k</span><span class="p">;</span>
        <span class="c1">// 因为是双向图，所以两个方向都要填上</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>

    <span class="p">}</span>
    <span class="c1">// 所有节点到最小生成树的最小距离</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">minDist</span><span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10001</span><span class="p">);</span>

    <span class="c1">// 这个节点是否在树里</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">isInTree</span><span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

     <span class="c1">//加上初始化</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

    <span class="c1">// 我们只需要循环 n-1次，建立 n - 1条边，就可以把n个节点的图连在一起</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// 1、prim三部曲，第一步：选距离生成树最近节点</span>
        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 选中哪个节点 加入最小生成树</span>
        <span class="kt">int</span> <span class="n">minVal</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">v</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 1 - v，顶点编号，这里下标从1开始</span>
            <span class="c1">//  选取最小生成树节点的条件：</span>
            <span class="c1">//  （1）不在最小生成树里</span>
            <span class="c1">//  （2）距离最小生成树最近的节点</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isInTree</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span>  <span class="n">minDist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minVal</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">minVal</span> <span class="o">=</span> <span class="n">minDist</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 2、prim三部曲，第二步：最近节点（cur）加入生成树</span>
        <span class="n">isInTree</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

        <span class="c1">// 3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新minDist数组）</span>
        <span class="c1">// cur节点加入之后， 最小生成树加入了新的节点，那么所有节点到 最小生成树的距离（即minDist数组）需要更新一下</span>
        <span class="c1">// 由于cur节点是新加入到最小生成树，那么只需要关心与 cur 相连的 非生成树节点 的距离 是否比 原来 非生成树节点到生成树节点的距离更小了呢</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">v</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 更新的条件：</span>
            <span class="c1">// （1）节点是 非生成树里的节点</span>
            <span class="c1">// （2）与cur相连的某节点的权值 比 该某节点距离最小生成树的距离小</span>
            <span class="c1">// 很多录友看到自己 就想不明白什么意思，其实就是 cur 是新加入 最小生成树的节点，那么 所有非生成树的节点距离生成树节点的最近距离 由于 cur的新加入，需要更新一下数据了</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isInTree</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="p">[</span><span class="n">cur</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minDist</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">minDist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">cur</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                <span class="n">parent</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span> <span class="c1">// 记录边</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 统计结果，minDist[i]均为最小生成树的一条边的权值</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">v</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 不计第一个顶点，因为统计的是边的权值，v个节点有 v-1条边</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">minDist</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="kruskal算法">Kruskal算法</h2>

<p><strong>prim 算法是维护节点的集合，而 Kruskal 是维护边的集合。</strong>
Kruskal的思路：</p>

<ol>
  <li>边的权值排序，因为要优先选最小的边加入到生成树里</li>
  <li>遍历排序后的边
    <ol>
      <li>如果边首尾的两个节点在同一个集合，说明如果连上这条边图中会出现环</li>
      <li>如果边首尾的两个节点不在同一个集合，加入到最小生成树，并把两个节点加入同一个集合</li>
    </ol>
  </li>
</ol>

<p>但在代码中，如果将两个节点加入同一个集合，又如何判断两个节点是否在同一个集合呢？<strong>这里就涉及到并查集。</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Edge</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10001</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">father</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> 

<span class="kt">void</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">father</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">u</span> <span class="o">==</span> <span class="n">father</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">?</span> <span class="n">u</span> <span class="o">:</span> <span class="n">father</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">father</span><span class="p">[</span><span class="n">u</span><span class="p">]);</span> 
<span class="p">}</span>

<span class="kt">void</span> <span class="n">join</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">u</span><span class="p">);</span> 
    <span class="n">v</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="k">return</span> <span class="p">;</span> 
    <span class="n">father</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="n">e</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">edges</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">result_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="n">e</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">e</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">v1</span> <span class="o">&gt;&gt;</span> <span class="n">v2</span> <span class="o">&gt;&gt;</span> <span class="n">val</span><span class="p">;</span>
        <span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">val</span><span class="p">});</span>
    <span class="p">}</span>

    <span class="n">sort</span><span class="p">(</span><span class="n">edges</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">edges</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Edge</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">val</span><span class="p">;</span>
    <span class="p">});</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span> <span class="c1">// 存储最小生成树的边</span>

    <span class="n">init</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">Edge</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>

        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">l</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">r</span><span class="p">);</span>


        <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span> <span class="c1">// 保存最小生成树的边</span>
            <span class="n">result_val</span> <span class="o">+=</span> <span class="n">edge</span><span class="p">.</span><span class="n">val</span><span class="p">;</span> 
            <span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 打印最小生成树的边</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Edge</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">edge</span><span class="p">.</span><span class="n">l</span> <span class="o">&lt;&lt;</span> <span class="s">" - "</span> <span class="o">&lt;&lt;</span> <span class="n">edge</span><span class="p">.</span><span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="s">" : "</span> <span class="o">&lt;&lt;</span> <span class="n">edge</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Kruskal 与 prim 的关键区别在于，prim维护的是节点的集合，而 Kruskal 维护的是边的集合。 如果 一个图中，节点多，但边相对较少，那么使用Kruskal 更优。</p>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="数据结构与算法" /><summary type="html"><![CDATA[prim算法]]></summary></entry><entry><title type="html">Leetcode记录：单源最短路径问题：Dijkstra算法</title><link href="http://localhost:4000/2024/08/31/MinDist/" rel="alternate" type="text/html" title="Leetcode记录：单源最短路径问题：Dijkstra算法" /><published>2024-08-31T08:00:00+08:00</published><updated>2024-08-31T08:00:00+08:00</updated><id>http://localhost:4000/2024/08/31/MinDist</id><content type="html" xml:base="http://localhost:4000/2024/08/31/MinDist/"><![CDATA[<h2 id="dijkstra算法">Dijkstra算法</h2>

<p>以一个例题为背景：小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。小明的起点是第一个车站，终点是最后一个车站。然而，途中的各个车站之间的道路状况、交通拥堵程度以及可能的自然因素（如天气变化）等不同，这些因素都会影响每条路径的通行时间。<strong>小明希望能选择一条花费时间最少的路线，以确保他能够尽快到达目的地。</strong></p>

<p>输入第一行包含两个正整数，第一个正整数 N 表示一共有 N 个公共汽车站，第二个正整数 M 表示有 M 条公路。
接下来为 M 行，每行包括三个整数，S、E 和 V，代表了从 S 车站可以单向直达 E 车站，并且需要花费 V 单位的时间。</p>

<p>dijkstra算法：<strong>在有权图（权值非负数）中求从起点到其他节点的最短路径算法</strong>。需要注意两点：</p>
<ol>
  <li>dijkstra 算法可以同时求 起点到所有节点的最短路径</li>
  <li>权值不能为负数</li>
</ol>

<p>dijkstra算法和我们之前讲解的prim算法思路非常接近，分为三步：</p>
<ol>
  <li>选源点到哪个节点近且该节点未被访问过</li>
  <li>该最近节点被标记访问过</li>
  <li>更新非访问节点到源点的距离（即更新minDist数组）</li>
</ol>

<p>在dijkstra算法中，同样有一个数组很重要，起名为：minDist。<strong>minDist数组用来记录每一个节点距离源点的最小距离。</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">));</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">p1</span> <span class="o">&gt;&gt;</span> <span class="n">p2</span> <span class="o">&gt;&gt;</span> <span class="n">val</span><span class="p">;</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">p1</span><span class="p">][</span><span class="n">p2</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">minDist</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">minDist</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 

    <span class="c1">//加上初始化</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

        <span class="kt">int</span> <span class="n">minVal</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">minDist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minVal</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">minVal</span> <span class="o">=</span> <span class="n">minDist</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">visited</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="p">[</span><span class="n">cur</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INT_MAX</span> <span class="o">&amp;&amp;</span> <span class="n">minDist</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">cur</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minDist</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">minDist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">minDist</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">cur</span><span class="p">][</span><span class="n">v</span><span class="p">];</span>
                <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span> <span class="c1">// 记录边</span>
            <span class="p">}</span>
        <span class="p">}</span>

    <span class="p">}</span>

    <span class="c1">// 输出最短情况</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">"-&gt;"</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>时间复杂度：O(n^2)
空间复杂度：O(n^2)</p>

<p>Dijkstra算法不能出现负权值，但prim算法是可以的，因为prim算法只需要将节点以最小权值和链接在一起，不涉及到单一路径。</p>

<h2 id="dijkstra堆优化">Dijkstra堆优化</h2>

<p>最小生成树的两个算法：prim算法（从点的角度来求最小生成树）、Kruskal算法（从边的角度来求最小生成树）</p>

<p>在n 很大的时候，也有另一个思考维度，即：从边的数量出发。
当 n 很大，边 的数量 也很多的时候（稠密图），那么 上述解法没问题。
但 n 很大，边 的数量 很小的时候（稀疏图），是不是可以换成从边的角度来求最短路呢？</p>

<p>我们可以利用小顶堆来处理：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 小顶堆</span>
<span class="k">class</span> <span class="nc">mycomparison</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">second</span> <span class="o">&gt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// 定义一个结构体来表示带权重的边</span>
<span class="k">struct</span> <span class="nc">Edge</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">to</span><span class="p">;</span>  <span class="c1">// 邻接顶点</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span> <span class="c1">// 边的权重</span>

    <span class="n">Edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">w</span><span class="p">)</span><span class="o">:</span> <span class="n">to</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">val</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="p">{}</span>  <span class="c1">// 构造函数</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">list</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">p1</span> <span class="o">&gt;&gt;</span> <span class="n">p2</span> <span class="o">&gt;&gt;</span> <span class="n">val</span><span class="p">;</span> 
        <span class="c1">// p1 指向 p2，权值为 val</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">p1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">Edge</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">val</span><span class="p">));</span>

    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 起点</span>
    <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>    <span class="c1">// 终点</span>

    <span class="c1">// 存储从源点到每个节点的最短距离</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">minDist</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>

    <span class="c1">// 记录顶点是否被访问过</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span> 
    
    <span class="c1">// 优先队列中存放 pair&lt;节点，源点到该节点的权值&gt;</span>
    <span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">mycomparison</span><span class="o">&gt;</span> <span class="n">pq</span><span class="p">;</span>


    <span class="c1">// 初始化队列，源点到源点的距离为0，所以初始为0</span>
    <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span> 
    
    <span class="n">minDist</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 起始点到自身的距离为0</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）</span>
        <span class="c1">// &lt;节点， 源点到该节点的距离&gt;</span>
        <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">cur</span><span class="p">.</span><span class="n">first</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>

        <span class="c1">// 2. 第二步，该最近节点被标记访问过</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">cur</span><span class="p">.</span><span class="n">first</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

        <span class="c1">// 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">Edge</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">grid</span><span class="p">[</span><span class="n">cur</span><span class="p">.</span><span class="n">first</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// 遍历 cur指向的节点，cur指向的节点为 edge</span>
            <span class="c1">// cur指向的节点edge.to，这条边的权值为 edge.val</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">edge</span><span class="p">.</span><span class="n">to</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">minDist</span><span class="p">[</span><span class="n">cur</span><span class="p">.</span><span class="n">first</span><span class="p">]</span> <span class="o">+</span> <span class="n">edge</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">minDist</span><span class="p">[</span><span class="n">edge</span><span class="p">.</span><span class="n">to</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// 更新minDist</span>
                <span class="n">minDist</span><span class="p">[</span><span class="n">edge</span><span class="p">.</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="n">minDist</span><span class="p">[</span><span class="n">cur</span><span class="p">.</span><span class="n">first</span><span class="p">]</span> <span class="o">+</span> <span class="n">edge</span><span class="p">.</span><span class="n">val</span><span class="p">;</span>
                <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="n">to</span><span class="p">,</span> <span class="n">minDist</span><span class="p">[</span><span class="n">edge</span><span class="p">.</span><span class="n">to</span><span class="p">]));</span>
            <span class="p">}</span>
        <span class="p">}</span>

    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">minDist</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">==</span> <span class="n">INT_MAX</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 不能到达终点</span>
    <span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">minDist</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 到达终点最短路径</span>
<span class="p">}</span>
</code></pre></div></div>

<p>时间复杂度：O(ElogE) E 为边的数量
空间复杂度：O(N + E) N 为节点的数量</p>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="数据结构与算法" /><summary type="html"><![CDATA[Dijkstra算法]]></summary></entry><entry><title type="html">Leetcode记录：图论dfs和bfs</title><link href="http://localhost:4000/2024/08/30/Graph/" rel="alternate" type="text/html" title="Leetcode记录：图论dfs和bfs" /><published>2024-08-30T10:00:00+08:00</published><updated>2024-08-30T10:00:00+08:00</updated><id>http://localhost:4000/2024/08/30/Graph</id><content type="html" xml:base="http://localhost:4000/2024/08/30/Graph/"><![CDATA[<p>首先通过几道基础题目了解dfs和bfs的框架：</p>

<h3 id="所有可达路径">所有可达路径</h3>
<p>Leetcode 797. 给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）</p>

<p><strong>对于找出所有路径问题，采用dfs更适合：</strong></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">;</span> <span class="c1">// 收集符合条件的路径</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span> <span class="c1">// 1节点到终点的路径</span>

<span class="kt">void</span> <span class="nf">dfs</span> <span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">graph</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 当前遍历的节点x 到达节点n </span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 找到符合条件的一条路径</span>
        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历节点x链接的所有节点</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 找到 x链接的节点</span>
            <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 遍历到的节点加入到路径中来</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="c1">// 进入下一层递归</span>
            <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span> <span class="c1">// 回溯，撤销本节点</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>

    <span class="c1">// 节点编号从1到n，所以申请 n+1 这么大的数组</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">graph</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">m</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="n">t</span><span class="p">;</span>
        <span class="c1">// 使用邻接矩阵 表示无线图，1 表示 s 与 t 是相连的</span>
        <span class="n">graph</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 无论什么路径已经是从0节点出发</span>
    <span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="c1">// 开始遍历</span>

    <span class="c1">// 输出结果</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">pa</span> <span class="o">:</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pa</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pa</span><span class="p">[</span><span class="n">pa</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>  <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="岛屿问题">岛屿问题</h2>

<h3 id="岛屿数量">岛屿数量</h3>
<p>Leetcode 200. 给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>

<p>dfs写法，<strong>注意这个版本的dfs每次处理的都是下一个节点，因此要在main函数调用dfs之前处理一下初始节点：</strong></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">dir</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span> <span class="c1">// 四个方向</span>
<span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;&amp;</span> <span class="n">visited</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">nextx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dir</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">nexty</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dir</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nextx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nextx</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="n">nexty</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nexty</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">())</span> <span class="k">continue</span><span class="p">;</span>  <span class="c1">// 越界了，直接跳过</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">nextx</span><span class="p">][</span><span class="n">nexty</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="p">[</span><span class="n">nextx</span><span class="p">][</span><span class="n">nexty</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 没有访问过的 同时 是陆地的</span>

            <span class="n">visited</span><span class="p">[</span><span class="n">nextx</span><span class="p">][</span><span class="n">nexty</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;</span> <span class="n">visited</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">false</span><span class="p">));</span>

    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">result</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 遇到没访问过的陆地，+1</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span> <span class="c1">// 将与其链接的陆地都标记上 true</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>bfs写法，要注意加入队列的时候就要标记visited</strong>：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">dir</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span> <span class="c1">// 四个方向</span>
<span class="kt">void</span> <span class="n">bfs</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;&amp;</span> <span class="n">visited</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">que</span><span class="p">;</span>
    <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">});</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 只要加入队列，立刻标记</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span> <span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">curx</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">cury</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">nextx</span> <span class="o">=</span> <span class="n">curx</span> <span class="o">+</span> <span class="n">dir</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">nexty</span> <span class="o">=</span> <span class="n">cury</span> <span class="o">+</span> <span class="n">dir</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nextx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nextx</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="n">nexty</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nexty</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">())</span> <span class="k">continue</span><span class="p">;</span>  <span class="c1">// 越界了，直接跳过</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">nextx</span><span class="p">][</span><span class="n">nexty</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="p">[</span><span class="n">nextx</span><span class="p">][</span><span class="n">nexty</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span><span class="p">});</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">nextx</span><span class="p">][</span><span class="n">nexty</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 只要加入队列立刻标记</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;</span> <span class="n">visited</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">false</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">result</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 遇到没访问过的陆地，+1</span>
                <span class="n">bfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span> <span class="c1">// 将与其链接的陆地都标记上 true</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="岛屿的最大面积">岛屿的最大面积</h3>
<p>Leetcode 695. 给定一个由 1（陆地）和 0（水）组成的矩阵，计算岛屿的最大面积。岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">dir</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span> <span class="c1">// 四个方向</span>
<span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;&amp;</span> <span class="n">visited</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">nextx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dir</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">nexty</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dir</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nextx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nextx</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="n">nexty</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nexty</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">())</span> <span class="k">continue</span><span class="p">;</span>  <span class="c1">// 越界了，直接跳过</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">nextx</span><span class="p">][</span><span class="n">nexty</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="p">[</span><span class="n">nextx</span><span class="p">][</span><span class="n">nexty</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 没有访问过的 同时 是陆地的</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">nextx</span><span class="p">][</span><span class="n">nexty</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">count</span><span class="o">++</span><span class="p">;</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;</span> <span class="n">visited</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">false</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 因为dfs处理下一个节点，所以这里遇到陆地了就先计数，dfs处理接下来的相邻陆地</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span> <span class="c1">// 将与其链接的陆地都标记上 true</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="孤岛的最大面积">孤岛的最大面积</h3>
<p>给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。</p>

<p>从边界开始dfs或bfs把所有非孤岛区域改为0，再进行dfs：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">dir</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span> <span class="c1">// 保存四个方向</span>
<span class="kt">int</span> <span class="n">count</span><span class="p">;</span> <span class="c1">// 统计符合题目要求的陆地空格数量</span>
<span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">grid</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 向四个方向遍历</span>
        <span class="kt">int</span> <span class="n">nextx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dir</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">nexty</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dir</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
        <span class="c1">// 超过边界</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nextx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nextx</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="n">nexty</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nexty</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">())</span> <span class="k">continue</span><span class="p">;</span>
        <span class="c1">// 不符合条件，不继续遍历</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">nextx</span><span class="p">][</span><span class="n">nexty</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

        <span class="n">dfs</span> <span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 从左侧边，和右侧边 向中间遍历</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 从上边和下边 向中间遍历</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="沉没孤岛">沉没孤岛</h3>
<p>给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。<strong>现在你需要将所有孤岛“沉没”，即将孤岛中的所有陆地单元格（1）转变为水域单元格（0）。</strong></p>

<p>可以标记visited来做，也可以更简单一些：
步骤一：深搜或者广搜将地图周边的 1 （陆地）全部改成 2 （特殊标记）
步骤二：将水域中间 1 （陆地）全部改成 水域（0）
步骤三：将之前标记的 2 改为 1 （陆地）</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">dir</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span> <span class="c1">// 保存四个方向</span>
<span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">grid</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 向四个方向遍历</span>
        <span class="kt">int</span> <span class="n">nextx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dir</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">nexty</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dir</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
        <span class="c1">// 超过边界</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nextx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nextx</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="n">nexty</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nexty</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">())</span> <span class="k">continue</span><span class="p">;</span>
        <span class="c1">// 不符合条件，不继续遍历</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">nextx</span><span class="p">][</span><span class="n">nexty</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">grid</span><span class="p">[</span><span class="n">nextx</span><span class="p">][</span><span class="n">nexty</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">dfs</span> <span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 步骤一：</span>
    <span class="c1">// 从左侧边，和右侧边 向中间遍历</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 从上边和下边 向中间遍历</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 步骤二、步骤三</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="水流问题">水流问题</h3>
<p>Leetcode 417. 现有一个 N × M 的矩阵，每个单元格包含一个数值，这个数值代表该位置的相对高度。矩阵的左边界和上边界被认为是第一组边界，而矩阵的右边界和下边界被视为第二组边界。</p>

<p>矩阵模拟了一个地形，当雨水落在上面时，水会根据地形的倾斜向低处流动，但<strong>只能从较高或等高的地点流向较低或等高并且相邻（上下左右方向）的地点</strong>。我们的目标是确定那些单元格，从这些单元格出发的水可以达到第一组边界和第二组边界。</p>

<p>从第一组边界上的节点 逆流而上，将遍历过的节点都标记上。同样从第二组边界的边上节点 逆流而上，将遍历过的节点也标记上。然后<strong>两方都标记过的节点就是既可以流太平洋也可以流大西洋的节点。</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">dir</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
<span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;&amp;</span> <span class="n">visited</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">])</span> <span class="k">return</span><span class="p">;</span>

    <span class="n">visited</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">nextx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dir</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">nexty</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dir</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nextx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nextx</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">nexty</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nexty</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">grid</span><span class="p">[</span><span class="n">nextx</span><span class="p">][</span><span class="n">nexty</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// 注意：这里是从低向高遍历</span>

        <span class="n">dfs</span> <span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 标记从第一组边界上的节点出发，可以遍历的节点</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;</span> <span class="n">firstBorder</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">false</span><span class="p">));</span>

    <span class="c1">// 标记从第一组边界上的节点出发，可以遍历的节点</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;</span> <span class="n">secondBorder</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">false</span><span class="p">));</span>

    <span class="c1">// 从最上和最下行的节点出发，向高处遍历</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dfs</span> <span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">firstBorder</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 遍历最左列，接触第一组边界</span>
        <span class="n">dfs</span> <span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">secondBorder</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 遍历最右列，接触第二组边界</span>
    <span class="p">}</span>

    <span class="c1">// 从最左和最右列的节点出发，向高处遍历</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dfs</span> <span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">firstBorder</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span> <span class="c1">// 遍历最上行，接触第一组边界</span>
        <span class="n">dfs</span> <span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">secondBorder</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span> <span class="c1">// 遍历最下行，接触第二组边界</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 如果这个节点，从第一组边界和第二组边界出发都遍历过，就是结果</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">firstBorder</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">secondBorder</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="建造最大岛屿">建造最大岛屿</h3>
<p>给定一个由 1（陆地）和 0（水）组成的矩阵，你最多可以将矩阵中的一格水变为一块陆地，在执行了此操作之后，矩阵中最大的岛屿面积是多少。</p>

<p>第一步：<strong>一次遍历地图，得出各个岛屿的面积，并做编号记录。</strong>可以使用map记录，key为岛屿编号，value为岛屿面积
第二步：再遍历地图，<strong>遍历0的方格（因为要将0变成1），并统计该1（由0变成的1）周边岛屿面积，将其相邻面积相加在一起</strong>，遍历所有 0 之后，就可以得出 选一个0变成1 之后的最大面积。</p>

<p><strong>注意要用一个unordered_set避免重复添加岛屿:</strong></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">dir</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span> <span class="c1">// 四个方向</span>
<span class="kt">void</span> <span class="n">dfs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;&amp;</span> <span class="n">visited</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mark</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">||</span> <span class="n">grid</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> <span class="c1">// 终止条件：访问过的节点 或者 遇到海水</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 标记访问过</span>
    <span class="n">grid</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">mark</span><span class="p">;</span> <span class="c1">// 给陆地标记新标签</span>
    <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">nextx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dir</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">nexty</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dir</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nextx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nextx</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">nexty</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nexty</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>  <span class="c1">// 越界了，直接跳过</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">nextx</span><span class="p">,</span> <span class="n">nexty</span><span class="p">,</span> <span class="n">mark</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;</span> <span class="n">visited</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">false</span><span class="p">));</span> <span class="c1">// 标记访问过的点</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span> <span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">gridNum</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">mark</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 记录每个岛屿的编号</span>
    <span class="kt">bool</span> <span class="n">isAllGrid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 标记是否整个地图都是陆地</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">isAllGrid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">mark</span><span class="p">);</span> <span class="c1">// 将与其链接的陆地都标记上 true</span>
                <span class="n">gridNum</span><span class="p">[</span><span class="n">mark</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span> <span class="c1">// 记录每一个岛屿的面积</span>
                <span class="n">mark</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 记录下一个岛屿编号</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isAllGrid</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">*</span> <span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 如果都是陆地，返回全面积</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 结束程序</span>
    <span class="p">}</span>

    <span class="c1">// 以下逻辑是根据添加陆地的位置，计算周边岛屿面积之和</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 记录最后结果</span>
    <span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">visitedGrid</span><span class="p">;</span> <span class="c1">// 标记访问过的岛屿</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 记录连接之后的岛屿数量</span>
            <span class="n">visitedGrid</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span> <span class="c1">// 每次使用时，清空</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kt">int</span> <span class="n">neari</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">dir</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// 计算相邻坐标</span>
                    <span class="kt">int</span> <span class="n">nearj</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">dir</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">neari</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">neari</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">||</span> <span class="n">nearj</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nearj</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">visitedGrid</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">neari</span><span class="p">][</span><span class="n">nearj</span><span class="p">]))</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// 添加过的岛屿不要重复添加</span>
                    <span class="c1">// 把相邻四面的岛屿数量加起来</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="n">gridNum</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="n">neari</span><span class="p">][</span><span class="n">nearj</span><span class="p">]];</span>
                    <span class="n">visitedGrid</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">neari</span><span class="p">][</span><span class="n">nearj</span><span class="p">]);</span> <span class="c1">// 标记该岛屿已经添加过</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="岛屿的周长">岛屿的周长</h3>
<p>Leetcode 463.你可以假设矩阵外均被水包围。在矩阵中恰好拥有一个岛屿，假设组成岛屿的陆地边长都为 1，请计算岛屿的周长。岛屿内部没有水域。</p>

<p>一种想法是如果一个格子的邻格是水或者越界，就有一条边：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">direction</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>       <span class="c1">// 上下左右四个方向</span>
                    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">direction</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
                    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">direction</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>    <span class="c1">// 计算周边坐标x,y</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">||</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="p">.</span><span class="n">siz</span><span class="p">()</span>
                            <span class="o">||</span> <span class="n">y</span> <span class="o">&lt;</span><span class="mi">0</span> 
                            <span class="o">||</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> 
                            <span class="o">||</span> <span class="n">grid</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">result</span><span class="o">++</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div></div>
<p>另一种想法就是有两个陆地相邻，总边数就要减2，此时在遍历的时候还要注意只遍历上和左邻格，避免重复检查：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// 陆地数量</span>
    <span class="kt">int</span> <span class="n">cover</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 相邻数量</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">sum</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 统计总的陆地数量</span>
                <span class="c1">// 统计上边相邻陆地</span>
                <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">cover</span><span class="o">++</span><span class="p">;</span>
                <span class="c1">// 统计左边相邻陆地</span>
                <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">cover</span><span class="o">++</span><span class="p">;</span>
                <span class="c1">// 为什么没统计下边和右边？ 因为避免重复计算</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="字符串接龙">字符串接龙</h3>
<p>Leetcode 127. 字典 strList 中从字符串 beginStr 和 endStr 的转换序列是一个按下述规格形成的序列：序列中第一个字符串是 beginStr。序列中最后一个字符串是 endStr。每次转换只能改变一个字符。转换过程中的中间字符串必须是字典 strList 中的字符串。</p>

<p>给你两个字符串 beginStr 和 endStr 和一个字典 strList，找到从 beginStr 到 endStr 的<strong>最短转换序列中的字符串数目</strong>。如果不存在这样的转换序列，返回 0。</p>

<p><strong>本质就是无向图中求最短路径，此时用bfs最合适，因为bfs只要搜索到了终点就一定是最短路径：</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">beginStr</span><span class="p">,</span> <span class="n">endStr</span><span class="p">,</span> <span class="n">str</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">strSet</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">beginStr</span> <span class="o">&gt;&gt;</span> <span class="n">endStr</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">;</span>
        <span class="n">strSet</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 记录strSet里的字符串是否被访问过，同时记录路径长度</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">visitMap</span><span class="p">;</span> <span class="c1">// &lt;记录的字符串，路径长度&gt;</span>

    <span class="c1">// 初始化队列</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">que</span><span class="p">;</span>
    <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">beginStr</span><span class="p">);</span>

    <span class="c1">// 初始化visitMap</span>
    <span class="n">visitMap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">beginStr</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>

    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">word</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">path</span> <span class="o">=</span> <span class="n">visitMap</span><span class="p">[</span><span class="n">word</span><span class="p">];</span> <span class="c1">// 这个字符串在路径中的长度</span>

        <span class="c1">// 开始在这个str中，挨个字符去替换</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">word</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">string</span> <span class="n">newWord</span> <span class="o">=</span> <span class="n">word</span><span class="p">;</span> <span class="c1">// 用一个新字符串替换str，因为每次要置换一个字符</span>

            <span class="c1">// 遍历26的字母</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">newWord</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="sc">'a'</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">newWord</span> <span class="o">==</span> <span class="n">endStr</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 发现替换字母后，字符串与终点字符串相同</span>
                    <span class="n">cout</span> <span class="o">&lt;&lt;</span>  <span class="n">path</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 找到了路径 </span>
                    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="c1">// 字符串集合里出现了newWord，并且newWord没有被访问过</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">strSet</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">newWord</span><span class="p">)</span> <span class="o">!=</span> <span class="n">strSet</span><span class="p">.</span><span class="n">end</span><span class="p">()</span>
                        <span class="o">&amp;&amp;</span> <span class="n">visitMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">newWord</span><span class="p">)</span> <span class="o">==</span> <span class="n">visitMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
                    <span class="c1">// 添加访问信息，并将新字符串放到队列中</span>
                    <span class="n">visitMap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">newWord</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
                    <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">newWord</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 没找到输出0</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="数据结构与算法" /><summary type="html"><![CDATA[首先通过几道基础题目了解dfs和bfs的框架：]]></summary></entry><entry><title type="html">Leetcode记录：并查集</title><link href="http://localhost:4000/2024/08/30/DisjointSet/" rel="alternate" type="text/html" title="Leetcode记录：并查集" /><published>2024-08-30T08:00:00+08:00</published><updated>2024-08-30T08:00:00+08:00</updated><id>http://localhost:4000/2024/08/30/DisjointSet</id><content type="html" xml:base="http://localhost:4000/2024/08/30/DisjointSet/"><![CDATA[<h2 id="并查集原理">并查集原理</h2>

<p>并查集常用来解决连通性问题。并查集主要有两个功能：</p>
<ol>
  <li>将两个元素添加到一个集合中；</li>
  <li>判断两个元素在不在同一个集合。</li>
</ol>

<p>我们用一个一维数组来表示，假设我们将三个元素A，B，C （分别是数字）放在同一个集合，<strong>那么只需要用father[A] = B，father[B] = C 这样就表述 A 与 B 与 C连通了（有向连通图）：</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 将v-&gt;u 这条边加入并查集</span>
<span class="kt">void</span> <span class="nf">join</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">u</span><span class="p">);</span> <span class="c1">// 寻找u的根</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">// 寻找v的根</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> <span class="c1">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span>
    <span class="n">father</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 并查集里寻根的过程</span>
<span class="kt">int</span> <span class="n">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">father</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="k">return</span> <span class="n">u</span><span class="p">;</span> <span class="c1">// 如果根就是自己，直接返回</span>
    <span class="k">else</span> <span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">father</span><span class="p">[</span><span class="n">u</span><span class="p">]);</span> <span class="c1">// 如果根不是自己，就根据数组下标一层一层向下找</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如何表示 C 也在同一个元素里呢？ 我们需要 father[C] = C，即C的根也为C，这样就方便表示 A，B，C 都在同一个集合里了。所以<strong>father数组初始化的时候要 father[i] = i，默认自己指向自己。</strong></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 并查集初始化</span>
<span class="kt">void</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">father</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最后我们如何判断两个元素是否在同一个集合里，如果通过 find函数 找到 两个元素属于同一个根的话，那么这两个元素就是同一个集合，代码如下：</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 判断 u 和 v是否找到同一个根</span>
<span class="kt">bool</span> <span class="nf">isSame</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在实现find函数的过程中，我们知道，通过递归的方式，不断获取father数组下标对应的数值，最终找到这个集合的根。<strong>搜索过程像是一个多叉树中从叶子到根节点的过程。</strong>如果这棵多叉树高度很深的话，每次find函数去寻找根的过程就要递归很多次。我们的目的<strong>只需要知道这些节点在同一个根下就可以，所以对这棵多叉树的构造只需要除了根节点其他所有节点都挂载根节点下就可以了，这样就是路径压缩：</strong></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">u</span> <span class="o">==</span> <span class="n">father</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">?</span> <span class="n">u</span> <span class="o">:</span> <span class="n">father</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">father</span><span class="p">[</span><span class="n">u</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="例题">例题</h2>

<h3 id="寻找存在的路径">寻找存在的路径</h3>
<p>Leetcode 1971. 给定一个包含 n 个节点的无向图中，节点编号从 1 到 n （含 1 和 n ）。你的任务是判断是否有一条从节点 source 出发到节点 destination 的路径存在。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">father</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">father</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">father</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">father</span><span class="p">[</span><span class="n">a</span><span class="p">]);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">join</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="n">father</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">isSame</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="n">validPath</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">edges</span><span class="p">,</span> <span class="kt">int</span> <span class="n">source</span><span class="p">,</span> <span class="kt">int</span> <span class="n">destination</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">father</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">father</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">edges</span><span class="p">){</span>
        <span class="n">join</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">isSame</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="冗余连接">冗余连接</h3>
<p>Leetcode 684. 树可以看成是一个图（拥有 n 个节点和 n - 1 条边的连通无环无向图）。现给定一个拥有 n 个节点（节点编号从 1 到 n）和 n 条边的连通无向图，请找出一条可以删除的边，删除后图可以变成一棵树。</p>

<p><strong>只要加入的边的两个顶点已经在同一个集合里了，就说明这条边的加入会构成环，删掉即可：</strong></p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">findRedundantConnection</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">edges</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">father</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">father</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">edges</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">isSame</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">return</span> <span class="n">edge</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">join</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="冗余连接ii">冗余连接II</h3>
<p>Leetcode 685. 有一种有向树,该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。有向树拥有 n 个节点和 n - 1 条边。</p>

<p>现在有一个有向图，有向图是在有向树中的两个没有直接链接的节点中间添加一条有向边。输入一个有向图，该图由一个有着 n 个节点(节点编号 从 1 到 n)，n 条边，请返回一条可以删除的边，使得删除该条边之后该有向图可以被当作一颗有向树。若有多个答案，返回最后出现在给定二维数组的答案。</p>

<p>思路：首先要找入度为2的顶点，如果存在的话尝试删除其中一边，看看是否可行，这里就<strong>需要判断删除之后是否满足有向树的条件</strong>；如果不存在的话则说明图中有环，<strong>把环的最后一条边删除即可</strong>。这两步都需要并查集来进行实现：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">father</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">father</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">father</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">father</span><span class="p">[</span><span class="n">a</span><span class="p">]);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">join</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="n">father</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">isSame</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">isTreeAfterDelete</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">edges</span><span class="p">,</span> <span class="kt">int</span> <span class="n">deleteEdge</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">edges</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">father</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">father</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">deleteEdge</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">isSame</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">join</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">getRemove</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">edges</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">edges</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">father</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">father</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">isSame</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">return</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">join</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">};</span>
<span class="p">}</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">findRedundantDirectedConnection</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">edges</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">inDegree</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">edge</span> <span class="o">:</span> <span class="n">edges</span><span class="p">){</span>
        <span class="n">inDegree</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> 
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">inDegree</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">){</span>
            <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">vec</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">isTreeAfterDelete</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">])){</span>
            <span class="k">return</span> <span class="n">edges</span><span class="p">[</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>
        <span class="p">}</span><span class="k">else</span>
            <span class="k">return</span> <span class="n">edges</span><span class="p">[</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]];</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">getRemove</span><span class="p">(</span><span class="n">edges</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="数据结构与算法" /><summary type="html"><![CDATA[并查集原理]]></summary></entry></feed>