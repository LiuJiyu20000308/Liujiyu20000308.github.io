<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-12-09T00:00:59+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Liujiyu’s blog</title><subtitle>learn &amp; record</subtitle><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><entry><title type="html">CSAPP-2:程序的机器级表示</title><link href="http://localhost:4000/2023/12/07/CSAPP-2/" rel="alternate" type="text/html" title="CSAPP-2:程序的机器级表示" /><published>2023-12-07T16:23:00+08:00</published><updated>2023-12-07T16:23:00+08:00</updated><id>http://localhost:4000/2023/12/07/CSAPP-2</id><content type="html" xml:base="http://localhost:4000/2023/12/07/CSAPP-2/"><![CDATA[<h1 id="程序的机器级表示">程序的机器级表示</h1>

<h2 id="程序编码概论">程序编码概论</h2>

<h3 id="术语介绍">术语介绍</h3>

<p>假设一个C程序有两个文件p1.c和p2.c，我们使用gcc编译这些代码，会经过以下步骤：</p>
<ol>
  <li><strong>C预处理</strong>扩展源代码，插入所有用#include命令指定的文件，并扩展所有用#define声明指定的宏；</li>
  <li><strong>编译器</strong>产生两个源文件的<strong>汇编代码</strong>，名字分别为p1.s和p2.s；</li>
  <li><strong>汇编器</strong>将汇编代码转化为二进制<strong>目标代码</strong>文件p1.o和p2.o；</li>
  <li><strong>链接器</strong>将目标代码文件和实现库函数的代码合并，并产生最终的可执行文件p。</li>
</ol>

<p>代码形式分为两种：</p>
<ol>
  <li>机器代码：byte-level的文件，包括目标代码以及可执行代码文件，目标代码中包含所有指令的二进制表示，但是还没有填入全局值的地址。</li>
  <li>汇编代码：是机器代码的文字表述。</li>
</ol>

<p>对于机器级编程来说，有两种抽象尤为重要：</p>
<ol>
  <li>第一种是由 <strong>指令集体系结构或指令集架构(Instruction Set Architecture, ISA)</strong> 来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式以及每条指令对状态的影响。大多数ISA，包括x86-64，将程序的行为描述成好像每条指令都是按顺序执行的。</li>
  <li>第二种是机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组，存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来，在后面第九章会讲到。</li>
</ol>

<p>在整个编译过程中，编译器会完成大部分的工作，将C语言提供的相对抽象的执行模型表示的程序转化为汇编代码，其主要特点是它用可读性更好的文本格式表示。</p>

<p>x86-64的机器代码和C代码差别非常大，一些通常对C语言程序员隐藏的处理器状态都是可见的：</p>
<ol>
  <li><strong>程序计数器</strong>(通常称为PC，在x86-64中用%rip表示)给出将要执行的下一条指令在内存中的地址。</li>
  <li><strong>整数寄存器文件</strong>包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址或整数数据。有的寄存器被用来记录重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量或返回值。</li>
  <li><strong>条件码寄存器</strong>保存着最近执行的算术或逻辑指令的状态信息</li>
  <li>一组<strong>向量寄存器</strong>可以存放一个或多个整数或浮点数值。</li>
</ol>

<p>虽然C语言提供了模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单地将内存看成一个很大的按字节寻址的数组，<strong>C语言中的聚合数据类型，例如数组和结构不存在于机器级代码</strong>，即使对于标量数据类型，汇编代码也不区分符号数与无符号数，不区分各种类型的指针，甚至不区分指针和整数。</p>

<p>程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块。程序内存用虚拟地址来寻址，例如x86-64的虚拟地址是由64位的字来表示的，操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。</p>

<p>一条机器指令只执行一个非常基本的操作，编译器必须产生这些指令的序列，从而实现程序结构。</p>

<h3 id="代码示例">代码示例</h3>

<p>假设我们写了一个C语言代码mstore.c</p>

<pre><code class="language-C">long mult2(long, long);

void multstore(long x, long y, long *dest) {
    long t = mult2(x,y);
    *dest = t;
}
</code></pre>

<p>使用gcc命令<code class="language-plaintext highlighter-rouge">gcc -Og -S mstore.c</code>可以产生汇编代码文件，包含以下几行：</p>

<pre><code class="language-asm">multstore:
    pushq   %rbx
    movq    %rdx, %rbx
    call    mult2
    movq    %rax, (%rbx)
    popq    %rbx
    ret
</code></pre>

<p>如果我们使用命令<code class="language-plaintext highlighter-rouge">gcc -Og -c mstore.c</code>，可以产生目标代码文件，它是二进制格式的，可以利用GDB命令<code class="language-plaintext highlighter-rouge">(gdb) x/14xb mulstore</code>查看。由此可见，机器对产生这些指令的源代码一无所知。</p>

<p>要查看机器代码文件的内容，有一类称为 <strong>反汇编器(disassembler)</strong>的程序非常有用，这些程序根据机器代码产生一种类似于汇编代码的格式，在Linux系统中可以使用<code class="language-plaintext highlighter-rouge">objdump -d mstore.o</code>命令实现，结果如下：</p>

<pre><code class="language-asm">0000000000000000 &lt;multstore&gt;:
    0:  53                  push    %rbx
    1:  48  89  d3          mov     %rdx, %rbx
    4： e8  00  00  00  00  callq   9 &lt;multstore+0x9&gt;
    9:  48  89  03          mov    %rax, (%rbx)
    c:  5b                  pop    %rbx
    d:  c3                  retq
</code></pre>

<p>其中一些关于机器代码和他的反汇编表示特性值得注意：</p>
<ol>
  <li>x86-64的指令长度从1到15个字节不等。</li>
  <li>设计指令格式的方式是从某个给定位置开始，可以将字节唯一解码成机器指令。例如，只有<code class="language-plaintext highlighter-rouge">pushq %rbx</code>是以字节值53开头的。</li>
  <li>反汇编器只是基于机器代码文件中的字节序列来确定汇编代码，它无需访问源代码或汇编代码。</li>
  <li>反汇编器使用的指令命令规则与gcc生成的汇编代码有细微差别，它省略了后缀的大小指示符。</li>
  <li>源程序所有名称在汇编代码级别完全消失，变成了寄存器或内存的某个位置。</li>
</ol>

<p>链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置，将代码的地址移到不同的地址范围中并在callq指令调用中填入需要使用的地址；另外，它也会插入一些nop指令使得函数代码变为16字节，使得就存储器系统性能而言，能更好地放置下一个代码块。</p>

<h4 id="数据格式">数据格式</h4>

<p>由于是从16位体系结构扩展到现在的，Intel用术语 <strong>字(word)</strong>来表示16位(2字节)数据类型，称32位为 <strong>双字(double words)</strong>，称64位为 <strong>四字(quad words)</strong>，下图给出了语言基本数据类型对应的x86-64表示。</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>C声明</td>
      <td>Intel数据类型</td>
      <td>汇编代码后缀</td>
      <td>大小（字节）</td>
    </tr>
    <tr>
      <td>char</td>
      <td>字节</td>
      <td>b</td>
      <td>1</td>
    </tr>
    <tr>
      <td>short</td>
      <td>字</td>
      <td>w</td>
      <td>2</td>
    </tr>
    <tr>
      <td>int</td>
      <td>双字</td>
      <td>l</td>
      <td>4</td>
    </tr>
    <tr>
      <td>long</td>
      <td>四字</td>
      <td>q</td>
      <td>8</td>
    </tr>
    <tr>
      <td>char*</td>
      <td>四字</td>
      <td>q</td>
      <td>8</td>
    </tr>
    <tr>
      <td>float</td>
      <td>单精度</td>
      <td>s</td>
      <td>4</td>
    </tr>
    <tr>
      <td>double</td>
      <td>双精度</td>
      <td>l</td>
      <td>8</td>
    </tr>
  </tbody>
</table>

<h3 id="访问信息">访问信息</h3>

<p>一个x86-64的CPU包含一组16个存储64位值的 <strong>通用目的寄存器</strong>，用于存储整数数据和指针，如下图所示。</p>

<div align="center"> <img src="/pic/register.png" width="500" /> </div>

<p>最初的8086中有8个16位的寄存器，即图中的%ax到%sp，它们的名字反映了不同的用途，分别是accumulate, base, counter, data, source index, destination index, base pointer, stack pointer.</p>

<p>目前它们已经和过去的功能几乎毫无关系，只是保留了名字。新扩充的8个寄存器则命名为%r8到%r15。</p>

<p>图中嵌套的方框表明，指令可以对这些寄存器的低位字节存放的不同大小的数据进行操作。当指令以寄存器为目标时，对于生成小于8字节结果的指令，有两个规则：</p>
<ol>
  <li>生成1字节和2字节数字的指令会保持剩下的字节不变，</li>
  <li>生成4字节数字的指令会把高位4个字节置为0。</li>
</ol>

<p>在常见的程序里，不同的寄存器扮演着不同的角色，有一组标准的变成规范控制着如何使用寄存器来管理栈、传递函数参数、从函数返回值以及存储局部和临时数据。</p>

<h4 id="操作数指示符">操作数指示符</h4>

<p>大多数指令有一个或多个 <strong>操作数(operand)</strong>，指示出执行一个操作要使用的源数据值以及放置结果的目的为止。<strong>源数据值可以以常数形式给出，或是寄存器或内存中读出，结果可以存放在寄存器或者内存中。</strong>因此，操作数分为3种类型：</p>
<ol>
  <li><strong>立即数(immediate)</strong>用来表示常数值，书写方式为$后面跟一个用C表示法表示的整数，例如<code class="language-plaintext highlighter-rouge">$-557, $0x1F</code></li>
  <li><strong>寄存器(register)</strong>表示某个寄存器的内容，我们用符号 $r_a$ 来表示任意寄存器a，用引用 $R[r_a]$ 表示它的值，这是将寄存器集合看成一个数组 $R$，用寄存器标识符作为索引。</li>
  <li><strong>内存引用</strong>，它会根据计算出来的地址访问某个内存位置，我们用符号$M_b[Addr]$ 表示对存储在内存中从地址Addr开始$b$个字节值的引用。</li>
</ol>

<p>如下图所示，有多种不同的寻址模式，允许不同形式的内存引用。其中最底部的 $Imm(r_b,r_i,s)$ 为最常用的形式，这里基址寄存器 $r_b$ 可以是任意寄存器，变址寄存器 $r_i$ 可以是除 \%rsp 外的任意寄存器，s必须为1、2、4或者8。<strong>有效地址被计算为</strong> $Imm+ R[r_b]+R[r_i]\cdot s$。</p>

<div align="center"> <img src="/pic/Mem.png" width="600" /> </div>

<h4 id="数据传送指令">数据传送指令</h4>

<p>最简单形式的数据传送指令为MOV类，这类指令把数据从源位置复制到目的位置，如下图所示：</p>
<div align="center"> <img src="/pic/MOV.png" width="400" /> </div>

<p>源操作数指定的值可以是立即数，也可以存储在寄存器或者内存中。目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址。 <strong>x86-64限制传送指令的两操作数不能都指向内存为止</strong>，如果想这样做需要先将源值加载到寄存器然后再写入目的位置。</p>

<p>大多数情况中MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置，唯一的例外是 <strong><code class="language-plaintext highlighter-rouge">movl</code>指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0。</strong>这是由于x86-64惯例为任何为寄存器生成32位值的指令都会把高位设置为0。</p>

<p>另外，常规的<code class="language-plaintext highlighter-rouge">movq</code>指令以立即数为源操作数时，只能表示32位补码数字再将其扩展到64位的值，<strong><code class="language-plaintext highlighter-rouge">movabsq</code>指令能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的。</strong></p>

<p>下面两个图记录的是另外两类数据移动指令，在将较小的源值复制到较大的目的时使用。</p>

<div align="center"> <img src="/pic/MOVZ.png" width="500" /> </div>

<div align="center"> <img src="/pic/MOVS.png" width="500" /> </div>

<p>注意到并没有一条明确的指令把4字节源值扩展到8字节目的，因为这个可以依靠<code class="language-plaintext highlighter-rouge">movl</code>指令实现。</p>

<p>例子：
|    |    |
| – | – |
| <code class="language-plaintext highlighter-rouge">movabsq $0x0011223344556677, %rax</code> | %rax = 0x0011223344556677 |
| <code class="language-plaintext highlighter-rouge">movb $-1, %al</code>  | %rax = 0x00112233445566FF |
| <code class="language-plaintext highlighter-rouge">movw $-1, %ax</code>  | %rax = 0x001122334455FFFF |
| <code class="language-plaintext highlighter-rouge">movl $-1, %eax</code> | %rax = 0x00000000FFFFFFFF |
| <code class="language-plaintext highlighter-rouge">movq $-1, %rax</code> | %rax = 0xFFFFFFFFFFFFFFFF |</p>

<p>反例：
|       |       |
| –    | –    |
| <code class="language-plaintext highlighter-rouge">movb $0xF, (%ebx)</code>   | <strong>内存引用要用4字节寄存器</strong>  |
| <code class="language-plaintext highlighter-rouge">movl %rax, (%rsp)</code>   | <code class="language-plaintext highlighter-rouge">movl</code>改为<code class="language-plaintext highlighter-rouge">movq</code>，<strong>MOV指令以源操作数字长为准</strong> |
| <code class="language-plaintext highlighter-rouge">movb (%rax), 4(%rsp)</code>| <strong>两操作数不能同时为内存引用</strong> |
| <code class="language-plaintext highlighter-rouge">movb %al,  %sl</code>      | 不存在%sl这个寄存器 |
| <code class="language-plaintext highlighter-rouge">movb %rax, $0x123</code>   | 立即数不能作为目的地址，去掉$是可以的 |
| <code class="language-plaintext highlighter-rouge">movb %eax, %rdx</code>     | 从小到大需要扩展 |
| <code class="language-plaintext highlighter-rouge">movb %si, 8(%rbp)</code>   | <code class="language-plaintext highlighter-rouge">movb</code>改为<code class="language-plaintext highlighter-rouge">movw</code> |</p>

<p>注释：</p>
<ol>
  <li>从小字长复制到大字长寄存器或内存都需要扩展；</li>
  <li>MOV指令一定确保能将源操作数完整地传送；</li>
  <li>从大字长类型内存复制到小字长内存需要先利用寄存器存值，再用寄存器的低位传递到小字长类型的内存中；
例子：
    <ol>
      <li><code class="language-plaintext highlighter-rouge">int *sp, char *dp, *dp = (char) *sp</code>
        <pre><code class="language-ams">  movl    (%rdi), %eax
  movb    %al, (%rsi)
</code></pre>
      </li>
      <li><code class="language-plaintext highlighter-rouge">char *sp, int *dp, *dp = (int) *sp</code>
        <pre><code class="language-ams">  movsbl    (%rdi), %eax
  movl    %eax, (%rsi)
</code></pre>
      </li>
    </ol>
  </li>
</ol>

<h4 id="压入和弹出栈数据">压入和弹出栈数据</h4>

<p>栈遵循后进先出的原则，弹出的值永远是最近被压入而且仍然在栈中的值。栈可以实现为一个数组，总是从数组的一端插入和删除元素，称为栈顶。</p>

<p>在x86-64中栈存放在内存的某个区域，如下图所示，栈向下增长。对栈可以进行两个操作：</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">pushq %rbp</code>指令首先将栈指针减8，然后将值写入新的栈顶位置，等价于
    <pre><code class="language-ams"> subq    $8, %rsp
 movq    %rbp, (%rsp)
</code></pre>
  </li>
  <li><code class="language-plaintext highlighter-rouge">popq</code>指令首先从栈顶位置读出数据，再将栈指针加8，等价于
    <pre><code class="language-ams"> movq    (%rsp), %rax
 addq    $8, %rsp
</code></pre>
  </li>
</ol>

<div align="center"> <img src="/pic/PushPop.png" width="500" /> </div>

<div align="center"> <img src="/pic/StackOp.png" width="500" /> </div>

<h3 id="算术和逻辑操作">算术和逻辑操作</h3>

<p>操作指令主要分为四组：加载有效地址、一元操作、二元操作和移位，如下图所示：</p>

<div align="center"> <img src="/pic/amsArith.png" width="400" /> </div>

<h4 id="加载有效地址">加载有效地址</h4>

<p>加载有效地址(load effective address)指令<code class="language-plaintext highlighter-rouge">leaq</code>实际上是<code class="language-plaintext highlighter-rouge">movq</code>指令的变形，它的指令形式是从内存读数据到寄存器，但 <strong>实际上它根本没有引用该内存，而是将有效地址写入到目的操作数</strong>。另外，他也可以简洁地表述普通的算术操作，例如，如果寄存器\%rdx存有 $x$，那么<code class="language-plaintext highlighter-rouge">leaq 7(%rdx,%rdx,4), %rax</code>就是将寄存器 \%rax的值设置为 $5x+7$。</p>

<p><strong><code class="language-plaintext highlighter-rouge">leaq</code>指令的目的操作数必须是一个寄存器</strong>，下面将<code class="language-plaintext highlighter-rouge">movq,leaq</code>与数组进行类比：</p>

<p><code class="language-plaintext highlighter-rouge">movq</code>相当于<code class="language-plaintext highlighter-rouge">array[i]</code>，<code class="language-plaintext highlighter-rouge">movq (%rdi,%rsi,8), %rbp</code>是将源内存地址的值传给\%rbp；
<code class="language-plaintext highlighter-rouge">leaq</code>相当于<code class="language-plaintext highlighter-rouge">&amp;array[i]</code>，<code class="language-plaintext highlighter-rouge">leaq (%rdi,%rsi,8), %rbp</code>是将源内存地址直接传给\%rbp。</p>

<h4 id="一元和二元操作">一元和二元操作</h4>

<p>二元操作的第二个操作数既是源又是目的，类似于<code class="language-plaintext highlighter-rouge">x-=y</code>，第一个操作数可以是立即数、寄存器或者内存，第二个操作数可以是寄存器或者内存， <strong>当第二个操作数为内存时，处理器必须从内存读出值，执行操作，再把结果写回内存。</strong></p>

<h4 id="移位操作">移位操作</h4>

<p><strong>移位量可以是一个立即数，或者放在单字节寄存器\%cl中。</strong>(这些指令很特别，因为只允许以这个特定的寄存器为操作数。)</p>

<p>原则上来说1个字节的移位量使得移位量的编码范围可以达到 $2^8-1=255$，<strong>移位操作对 $w$ 位长的数据值进行操作，移位量是由\%cl寄存器的低m位决定的，这里 $2^m=w$，高位会被忽略。</strong></p>

<p>例如，当寄存器\%cl的十六进制的值为0xFF时，指令<code class="language-plaintext highlighter-rouge">salb</code>会左移7位，而指令<code class="language-plaintext highlighter-rouge">salw</code>会左移15位，<code class="language-plaintext highlighter-rouge">salq</code>会左移63位。</p>

<p>移位操作的目的操作数可以是一个寄存器或是一个内存位置。</p>

<h4 id="特殊的算术操作">特殊的算术操作</h4>

<p>两个64位有符号或无符号整数相乘需要128位来表示，Intel把16字节的数称为 <strong>八字(oct word)</strong>，下图为支持两个64位数字的全128位乘积和除法的指令：</p>

<div align="center"> <img src="/pic/64ArithOp.png" width="500" /> </div>

<p><code class="language-plaintext highlighter-rouge">imulq</code>指令有两种不同形式:</p>
<ol>
  <li>一种是前面的双操作数乘法指令，实现了前一章的操作 $\times_{64}^u, \times_{64}^t$；</li>
  <li>另外一种是上图中的单操作数乘法指令—-一个是无符号数乘法(<code class="language-plaintext highlighter-rouge">mulq</code>)，而另一个是补码乘法(<code class="language-plaintext highlighter-rouge">imulq</code>)，<strong>这两种指令都要求都要求一个参数必须在寄存器\%rax中，而另一个作为指令的源操作数给出，最后乘积存放在寄存器\%rdx(高64位)和\%rax(低64位)中。</strong> 例：
    <pre><code class="language-C">typedef unsigned __int128 uint128_t;
void store_uprod(uint128_t *dest, uint64_t x, uint64_t y){
 *dest = x * (uint128_t) y;
}
</code></pre>
  </li>
</ol>

<p>GCC生成的汇编代码如下：</p>
<pre><code class="language-asm">% dest in %rdi, x in %rsi, y in %rdx
store_uprod:
    movq    %rsi, %rax          Copy x to multiplicand
    mulq    %rdx                Multiply by y
    movq    %rax, (%rdi)        Store lower 8 bytes at dest
    movq    %rdx, 8(%rdi)       Store upper 8 bytes at dest+8
</code></pre>
<p><strong>因为我们针对的是小端法机器，所以高位字节存储在大地址。</strong></p>

<p>类似的，有符号除法指令<code class="language-plaintext highlighter-rouge">idivl</code>将寄存器\%rdx(高64位)和\%rax(低64位)中的128位数作为被除数，而 <strong>除数作为指令的操作数给出，指令将商存在寄存器\%rax中，将余数存在寄存器\%rdx中。</strong></p>

<p>对于大多数64位除法应用来说，被除数也常常是64位的值，这个时候值应该存在\%rax中，<strong>\%rdx的位应该设置为0(无符号运算)或者\%rax的符号位(有符号运算)，这个操作可以用<code class="language-plaintext highlighter-rouge">cqto</code>完成。</strong> 以有符号64位整数除法运算为例：</p>

<pre><code class="language-C">void remdiv(long x, long y, long *qp, long *rp){
    long q = x/y;
    long r = x%y;
    *qp = q;
    *rp = r;
}
</code></pre>

<p>GCC编译得到如下汇编代码：</p>

<pre><code class="language-asm">% x in %rdi, y in %rsi, qp in %rdx, rp in %rcx
remdiv:
    movq    %rdx, %r8
    movq    %rdi, %rax
    cqto
    idivq   %rsi
    movq    %rax, (%r8)
    movq    %rdx, (%rcx)
    ret
</code></pre>

<p>上述代码中，必须先把qp保存到另一个寄存器中，因为除法操作需要使用。</p>

<p>再考虑无符号64位数的除法：</p>

<pre><code class="language-C">void remdiv(unsigned long x, unsigned long y,
            unsigned long *qp, unsigned long *rp){
    unsigned long q = x/y;
    unsigned long r = x%y;
    *qp = q;
    *rp = r;
}
</code></pre>

<p>GCC编译得到如下汇编代码：</p>

<pre><code class="language-asm">% x in %rdi, y in %rsi, qp in %rdx, rp in %rcx
remdiv:
    movq    %rdx, %r8
    movq    %rdi, %rax
    movl    $0, %edx
    divq   %rsi
    movq    %rax, (%r8)
    movq    %rdx, (%rcx)
    ret
</code></pre>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="CSAPP" /><category term="汇编" /><summary type="html"><![CDATA[程序的机器级表示]]></summary></entry><entry><title type="html">CSAPP-1:信息的表示和处理</title><link href="http://localhost:4000/2023/11/24/CSAPP-1/" rel="alternate" type="text/html" title="CSAPP-1:信息的表示和处理" /><published>2023-11-24T14:23:00+08:00</published><updated>2023-11-24T14:23:00+08:00</updated><id>http://localhost:4000/2023/11/24/CSAPP-1</id><content type="html" xml:base="http://localhost:4000/2023/11/24/CSAPP-1/"><![CDATA[<h1 id="信息的表示和处理">信息的表示和处理</h1>

<h2 id="信息存储">信息存储</h2>

<h3 id="基本概念">基本概念</h3>

<p><strong>位(bit)</strong> 为计算机方位内存中单独的位，<strong>字节(byte)</strong> 为计算机中最小的可寻址的内存单位，大多数计算机使用8-Bit的字节。机器级程序将内存视为一个非常大的字节数，称为<strong>虚拟内存(virtual memory)</strong>。内存的每个字节都由一个唯一的数字来标识，被称为它的<strong>地址(address)</strong>，所有可能地址的集合被称为<strong>虚拟地址空间</strong>。</p>

<p>每台计算机都有一个<strong>字长(word size)</strong>，指明指针数据的标准大小(normal size)，对于一个字长为 $w$ 的机器而言，虚拟地址的范围为 $0\sim 2^w-1$，程序最多访问 $2^w$ 个字节。</p>

<div align="center"> <img src="/pic/WordSize.png" width="300" /> </div>
<center><p>基本C数据类型的典型大小(以字节为单位)</p></center>

<h3 id="寻址和字节顺序">寻址和字节顺序</h3>
<p>在几乎所有的机器上，多字节对象都被存储为连续的字节，但排列表示一个对象的字节有两种通用规则：</p>
<ol>
  <li>最低有效字节在前面的方式称为<strong>小端法(little endian)</strong>，大多数Intel兼容机，Android和IOS都只用小端模式，</li>
  <li>最高有效字节在前面的方式称为<strong>大端法(big endian)</strong>，网络传送数据时要求使用大端法规则。</li>
</ol>

<p>假设变量 $x$ 类型为int，位于地址0x100处，十六进制的值为0x01234567，下图表示两种方法排列表示的规则：</p>
<div align="center"> <img src="/pic/LHEndian.png" width="600" /> </div>

<p>对于大多数情况下，及其所使用的字节顺序是完全不可见的，但在一些情况下，字节顺序会成为问题：</p>
<ol>
  <li>当小端法机器产生的数据被发送到大端法机器时，接收程序会发现字节反序，为避免这类问题，网络应用程序的代码编写必须遵守大端法规则（<strong>见11章</strong>）。</li>
  <li>当阅读表示整数数据的字节序列时字节顺序很重要，这通常发生在检查机器级程序时，例如阅读反汇编器生成的代码时（<strong>见3章</strong>）。</li>
  <li>
    <p>当编写规避正常的类型系统的程序时字节顺序变得重要，例如：我们将byte_pointer定义为一个指向类型为unsigned char的对象的指针，这样一个字节指针引用一个字节序列，其中每一个字节都被认为是一个非负整数，</p>

    <pre><code class="language-C"> typedef unsigned char *byte_pointer;

 void show_bytes(byte_pointer start, size_t len) {
     size_t i;
     for (i = 0; i &lt; len; i++)
     printf(" %.2x", start[i]);
     printf("\n");
 }

 void show_int(int x) {
     show_bytes((byte_pointer) &amp;x, sizeof(int)); 
 }

 void show_float(float x) {
     show_bytes((byte_pointer) &amp;x, sizeof(float)); 
 }

 void show_pointer(void *x) {
     show_bytes((byte_pointer) &amp;x, sizeof(void *));
 }

 void test_show_bytes(int val) {
     int ival = val;
     float fval = (float) ival;
     int *pval = &amp;ival;
     show_int(ival);
     show_float(fval);
     show_pointer(pval);
 }
</code></pre>
    <p>在不同机器上得到的结果并不相同，如下图所示：</p>
  </li>
</ol>
<div align="center"> <img src="/pic/Show_Bytes.png" width="500" /> </div>
<p>这里注意每输出一次都是两位十六进制数，因为一个字节是8Bit，对应两位十六进制数。</p>

<h3 id="字符串表示">字符串表示</h3>

<p>C语言中字符串被编码为一个以null(其值为0)字符结尾的字符数组，例如我们以参数<code class="language-plaintext highlighter-rouge">12345</code>和<code class="language-plaintext highlighter-rouge">6</code>来运行<code class="language-plaintext highlighter-rouge">show_bytes</code>，我们会得到结果 <code class="language-plaintext highlighter-rouge">31 32 33 34 35 00</code>.</p>

<h2 id="布尔代数简介">布尔代数简介</h2>

<p>最简单的布尔代数是在二元集合{0,1}上定义的:</p>
<ol>
  <li>布尔运算 $\sim$ 对应于逻辑运算 <code class="language-plaintext highlighter-rouge">NOT</code>，在命题逻辑中用符号 $\lnot$ 表示，</li>
  <li>布尔运算 $\And$ 对应于逻辑运算 <code class="language-plaintext highlighter-rouge">AND</code>，在命题逻辑中用符号 $\land$ 表示，</li>
  <li>布尔运算 $\vert$ 对应于逻辑运算 <code class="language-plaintext highlighter-rouge">OR</code>，在命题逻辑中用符号 $\lor$ 表示，</li>
  <li>布尔运算 ^ 对应于逻辑运算异或(Exlusive or)，在命题逻辑中用符号用 $\oplus$ 表示。
具体规则如下图所示：</li>
</ol>
<div align="center"> <img src="/pic/Boolean.png" width="400" /> </div>

<p>以上布尔运算可以扩展到<strong>位向量</strong>的运算，其中位向量就是固定长度为w，由0和1组成的串，它一个很有用的应用就是表示有限集合。</p>

<h3 id="c语言中的位级运算">C语言中的位级运算</h3>

<p>位级运算的一个常见用法就是<strong>掩码运算</strong>，例如：</p>
<ol>
  <li>掩码<code class="language-plaintext highlighter-rouge">0xFF</code>表示一个字的低位字节，位级运算<code class="language-plaintext highlighter-rouge">x &amp; 0xFF</code>生成一个由 $x$ 的最低有效字节组成的值，而其他的字节都被置为0，</li>
  <li>位级运算<code class="language-plaintext highlighter-rouge">x | 0xFF</code>将x的最低有效字节设为1，其他字节保持不变，</li>
  <li><code class="language-plaintext highlighter-rouge">x ^ 0xFFFFFFFF</code>等价于<code class="language-plaintext highlighter-rouge">~x</code>，<code class="language-plaintext highlighter-rouge">x ^ 0</code>不发生改变，</li>
  <li><code class="language-plaintext highlighter-rouge">x ^ ~0xFF</code>使得x最低有效字节不变，其他位都取补。</li>
  <li><strong>注意是最低有效字节，8位，所以是0xFF。</strong></li>
</ol>

<p>关于异或运算还有两点注意：</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">x ^ y = (x &amp; ~y) | (~x &amp; y)</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">a ^ a = 0</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">y = x^y, x = x^y, y = x^y</code>即可做到不需要第三个位置就可以交换 $x$ 和 $y$ 的值。</li>
  <li><code class="language-plaintext highlighter-rouge">!(x^y)</code>满足当 $x,y$ 相等时返回1，否则返回0。</li>
</ol>

<p><strong>三个二元位级运算都具有交换律和结合律。</strong></p>

<h3 id="c语言中的逻辑运算">C语言中的逻辑运算</h3>

<p>逻辑运算有三种: <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>, <code class="language-plaintext highlighter-rouge">||</code>, <code class="language-plaintext highlighter-rouge">!</code>，注意别和位级运算混淆即可，另外<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>和<code class="language-plaintext highlighter-rouge">||</code>具有短路性。</p>

<h3 id="c语言中的移位运算">C语言中的移位运算</h3>

<p>对于一个位表示为 $[x_{w-1},x_{w-2},\ldots,x_0]$ 的操作数 $x$，左移运算<code class="language-plaintext highlighter-rouge">x&lt;&lt;k</code>使得 $x$ 向左移动 $k$ 位，丢弃最高的 $k$ 位，并在右端补上 $k$ 个0。并且<strong>移位运算从左到右是可结合的。</strong></p>

<p>相应地，右移运算<code class="language-plaintext highlighter-rouge">x&gt;&gt;k</code>分为两种:</p>
<ol>
  <li>对无符号数使用逻辑右移，即在左端补 $k$ 个0，得到 $[0,\ldots,0,x_{w-1},\ldots,x_k]$ .</li>
  <li>对有符号数使用算术右移，即在左端补 $k$ 个最高有效位的值，得到 $[x_{w-1},\ldots,x_{w-1},x_{w-1},x_{w-2},\ldots,x_{k}]$.</li>
</ol>

<p>注意:</p>
<ol>
  <li>对于一个 $w$ 位组成的数据类型，当 $k\geq w$ 很大的时候，实际上的位移量就是<code class="language-plaintext highlighter-rouge">k mod w</code>位。</li>
  <li>加减法的优先级比移位运算要高，因此在拿不准的时候记得加括号。</li>
</ol>

<h2 id="整数表示">整数表示</h2>

<h3 id="整数编码">整数编码</h3>

<p>对于位向量 $\mathbf{x} = [x_{w-1},x_{w-2},\ldots,x_0]$, 无符号数编码定义为
\(\text{B2U}_w(\mathbf{x}) = \sum\limits_{i=0}^{w-1} x_i 2^i\)</p>

<p>补码编码的定义为 \(\text{B2T}_w(\mathbf{x}) = -x_{w-1}2^{w-1} - \sum\limits_{i=0}^{w-2} x_i 2^i\)</p>

<p>可以证明当 $0\leq x \leq 2^w-1$ 时，无符号数编码是唯一的，
当 $\text{TMin}_w = -2^{w-1} \leq x \leq 2^{w-1}-1 = \text{TMax}_w$ 时，补码编码是唯一的。</p>

<p>关于这些数字，有几点值得注意：</p>
<ol>
  <li>补码的范围是不对称的，即 <code class="language-plaintext highlighter-rouge">|TMin| = |TMax| + 1</code>，</li>
  <li>最大的无符号数刚好比补码的最大数的两倍大1，即<code class="language-plaintext highlighter-rouge">UMax = 2TMax +1</code>，</li>
  <li>-1和 UMax 有同样的位表示，即一个全1的串。</li>
</ol>

<h3 id="有符号数和无符号数的转换">有符号数和无符号数的转换</h3>

<ol>
  <li>对于满足 $\text{TMin}_w \leq x \leq \text{TMax}_w$ 的 $x$ 有，</li>
</ol>

\[\text{T2U}_w(x) = \begin{cases}
    x+2^w ,\quad &amp;x &lt; 0 \\
    x,\quad &amp;x \geq 0    
\end{cases}\]

<ol>
  <li>对于满足 $0 \leq u \leq \text{UMax}_w$ 的$u$有，</li>
</ol>

\[\text{U2T}_w(u) = \begin{cases}
    u-2^w ,\quad &amp; u &gt; \text{TMax}_w \\
    u,\quad &amp; u \leq \text{TMax}_w   
\end{cases}\]

<p>当 $u&gt;\text{TMax}_w$ 时，$u$的最高位有效数字为1，转化为补码表示就相当于最高位权重从+1变为-1，因此少了 $2^w$，反之同理，越靠近0的负数映射为越大的无符号数。</p>

<p>另外，可以证明U2T和T2U两个函数都是双射，两个函数的行为如下图所示：</p>
<div align="center"> <img src="/pic/U2T_T2U.png" width="500" /> </div>

<p>在C语言中允许两者之间相互转换，主要有四种情况：</p>
<ol>
  <li>显示的强制类型转换就会导致转换发生，例如
    <pre><code class="language-C"> int tx; 
 unsigned ux; 
 tx = (int)ux;
</code></pre>
  </li>
  <li>一种类型的表达式被赋值给另外一种类型的变量，例如
    <pre><code class="language-C"> tx = ux;
</code></pre>
  </li>
  <li>当用printf输出数值时，分别用<code class="language-plaintext highlighter-rouge">%d</code>,<code class="language-plaintext highlighter-rouge">%u</code>和`%x%表示有符号十进制、无符号十进制和十六进制格式输出一个数字，例如
    <pre><code class="language-C"> int x = -1;
 printf("x = %u = %d\n", x, x); \\ x = 4294967295 = -1.
</code></pre>
  </li>
  <li><strong>当执行一个两侧分别为有符号和无符号数的运算时，会隐式地将有符号数转换为无符号数</strong>，例如
    <ol>
      <li><code class="language-plaintext highlighter-rouge">-1 &lt; 0U</code>是错误的，</li>
      <li><code class="language-plaintext highlighter-rouge">-1 &gt; (unsigned)-2</code>是正确的，</li>
      <li><code class="language-plaintext highlighter-rouge">2147483647 &gt; (int)2147483648U</code>是正确的。</li>
    </ol>
  </li>
</ol>

<p>在C头文件<code class="language-plaintext highlighter-rouge">limit.h</code>中是这样定义TMin和TMax的：</p>
<pre><code class="language-C">#define INT_MAX 2147483647
#define INT_MIN (-INT_MAX - 1)
</code></pre>
<p>因为在某些编译器中可能会把-2147482648认为是正数，这里不深究，了解即可。</p>

<h3 id="扩展一个数字的位表示">扩展一个数字的位表示</h3>

<ol>
  <li>
    <p>宽度为 $w$ 的位向量 $\mathbf{u} = [u_{w-1},\ldots,u_0]$ 扩展到 $w’$ 位的 $\mathbf{u}’ = [0,\ldots,0,u_{w-1},\ldots,u_0]$，则有
\(\text{B2U}_w(\mathbf{u}) == \text{B2U}_{w'}(\mathbf{u}')\)</p>
  </li>
  <li>
    <p>宽度为 $w$ 的位向量 $\mathbf{x} = [x_{w-1},\ldots,x_0]$ 扩展到 $w’$ 位的 $\mathbf{x}’ = [x_{w-1},\ldots,x_{w-1},x_{w-1},\ldots,x_0]$，则有
\(\text{B2T}_w(\mathbf{x}) == \text{B2T}_{w'}(\mathbf{x}')\)</p>
  </li>
</ol>

<p>举个例子，有符号数<code class="language-plaintext highlighter-rouge">1001 -&gt; -7</code>，扩展到8位时<code class="language-plaintext highlighter-rouge">11111001 -&gt; -7</code>，因为 \(-2^{p+k}+2^{p+k-1}+\ldots+2^p = -2^p.\)</p>

<p>值得注意的是，从一个数据大小到另一个数据大小的转换，以及无符号和有符号之间的转换的相对顺序能够影响一个程序的行为，例如</p>

<pre><code class="language-C">short sx = -12345;
unsigned uy = sx; /* Mystery! */
printf("uy = %u:\t", uy);
show_bytes( (byte_pointer)&amp;uy, sizeof(unsigned));
\\ uy = 4294954951: ff ff cf c7.
</code></pre>

<p>这表明<strong>当short转换成unsigned时，我们先要改变大小，然后再完成有符号到无符号的转换</strong>，即<code class="language-plaintext highlighter-rouge">(unsigned)sx</code>等价于<code class="language-plaintext highlighter-rouge">(unsigned)(int)sx</code>而不是<code class="language-plaintext highlighter-rouge">(unsigned)(unsigned short)sx</code>。</p>

<h3 id="截断数字">截断数字</h3>

<p>截断一个数字可能会改变它的值，这也是溢出的一种形式。</p>

<ol>
  <li>
    <p>令 $\mathbf{x} = [x_{w-1},\ldots,x_0]$，将其阶段为k位有 $\mathbf{x}’ = [x_{k-1},\ldots,x_0]$, 
记 $x=\text{B2U}<em>w(\mathbf{x}), x’ = \text{B2U}</em>{k}(\mathbf{x}’)$， 则有 $x’ = x\mod\ 2^k$.</p>
  </li>
  <li>
    <p>令 $\mathbf{x} = [x_{w-1},\ldots,x_0]$，将其阶段为k位有 $\mathbf{x}’ = [x_{k-1},\ldots,x_0]$, 
记 $x=\text{B2U}<em>w(\mathbf{x}), x’ = \text{B2T}</em>{k}(\mathbf{x}’)$, 则有 $x’ = \text{U2T}_k(x\mod\ 2^k)$.</p>
  </li>
</ol>

<p>其实<strong>两个操作在位级别上是相同的，只是最后按照不同编码表示而已</strong>。</p>

<h2 id="整数运算">整数运算</h2>

<h3 id="整数加法">整数加法</h3>

<ol>
  <li>对于满足 $0\leq x,y &lt; 2^w$ 的整数 $x,\ y$ 有:</li>
</ol>

\[x+_w^u y = \begin{cases}
    x+y,\quad &amp;x+y&lt;2^w\quad &amp;\text{正常} \\
    x+y - 2^w,\quad &amp;2^w \leq x+y &lt; 2^{w+1}\quad &amp;\text{溢出}
\end{cases}\]

<ol>
  <li>对于满足 $-2^{w-1} \leq x,y \leq 2^{w-1}-1$ 的整数 $x,\ y$，有:</li>
</ol>

\[x +_w^t y = \begin{cases}
    x + y - 2^w, \quad &amp; 2^{w-1}\leq x+y \quad &amp;\text{正溢出} \\
    x + y, \quad &amp; -2^{w-1} \leq x+y &lt; 2^{w-1} \quad &amp;\text{正常} \\
    x + y + 2^w, \quad &amp; x+y &lt; -2^{w-1} \quad &amp;\text{负溢出}
\end{cases}\]

<p>负溢出的情况下截断后最高位有效数字必为0，否则就不会出现溢出了。</p>

<p>这里值得注意的是<strong>补码加法与无符号数加法有相同的位级表示</strong>，用数学语言表示就是</p>

\[x +_w^t y = \text{U2T}_w(\text{T2U}_w(x) +_w^u \text{T2U}_w(y)) = \text{U2T}_w[(x+y) mod 2^w]\]

<p>这样计算机就可以用同一个算法进行加法，之后的乘法也是如此。</p>

<p>另外，<strong>模数加法形成了阿贝尔群</strong>，它是可交换的并且可结合的，存在单位元0，并且每个元素有一个加法逆元（<strong>位级操作上为取反后+1</strong>）：</p>
<ol>
  <li>对于满足 $0\leq x&lt; 2^w$ 的整数 $x$ 有:</li>
</ol>

\[-_w^u x = \begin{cases}
    x, \quad &amp; x=0 \\
    2^w-x, \quad &amp; x&gt;0
\end{cases}\]

<ol>
  <li>对于满足 $-2^{w-1} \leq x\leq 2^{w-1}-1$ 的整数 $x$，有:</li>
</ol>

\[-_w^t x = \begin{cases}
    \text{TMin}_x, \quad &amp; x = \text{TMin}_w \\
    -x, \quad &amp; x &gt; \text{TMin}_w
\end{cases}\]

<p>判断是否出现溢出的方法如下:</p>
<ol>
  <li>
    <p>对于在范围 $0\leq x,y \leq \text{UMax}_w$ 的 $x,\ y$, 令 $s=x +_w^u y$，则计算发生溢出当且仅当 $s&lt;x$(或者等价地$s&lt;y$)。</p>
  </li>
  <li>
    <p>对于在范围 $\text{TMin}_w \leq x,y \leq \text{TMax}_w$的 $x,\ y$, 令$s=x +_w^t y$，则</p>
    <ol>
      <li>发生正溢出当且仅当 $x&gt;0,y&gt;0,s\leq 0$，</li>
      <li>发生负溢出当且仅当 $x&lt;0,y&lt;0,s\geq 0$.</li>
    </ol>
  </li>
</ol>

<p>对于补码而言，判断是否发生溢出的代码如下：</p>

<pre><code class="language-C">int tadd_ok(int x, int y){
    int sum = x + y;
    int neg_over = x &lt; 0 &amp;&amp; y &lt; 0 &amp;&amp; sum &gt;=0;
    int pos_over = x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; sum &lt; 0;
    return !neg_over &amp;&amp; !pos_over;
}
</code></pre>

<p>注意以下写法是不对的：</p>

<pre><code class="language-C">int tadd_ok(int x, int y){
    int sum = x + y;
    return (sum - x == y) &amp;&amp; (sum -y == x);
}
</code></pre>

<p>因为模数加法构成阿贝尔群，$(x+y-x)$ 的结果永远都是$y$.</p>

<p>虽然我们现在可以判断加法是否溢出，我们是无法直接简单地通过加法来判断减法是否溢出的：</p>

<pre><code class="language-C">int tsub_ok(int x, int y){
    return tadd_ok(x, -y);
}
</code></pre>

<p>当 $x&gt;0,\ y = \text{TMin}_w$ 时，$-y = \text{TMin}_w$，此时一正一负判断为不溢出，然而实际是溢出的。</p>

<h3 id="整数乘法">整数乘法</h3>

<ol>
  <li>
    <p>对于满足 $0\leq x,y &lt; 2^w$ 的整数$x,\ y$ 有:</p>

\[x *_w^u y = (x\cdot y)\ \text{mod}\ 2^w.\]
  </li>
  <li>
    <p>对于满足 $-2^{w-1} \leq x,y \leq 2^{w-1}-1$的整数$x,\ y$，有:</p>

\[x *_w^t y = \text{U2T}_w((x\cdot y)\ \text{mod}\ 2^w).\]
  </li>
</ol>

<p>无符号和补码乘法的位级操作是等价的，即给定长度为$w$的位向量 $\mathbf{x}, \mathbf{y}$，用补码形式来定义整数 $x,y$，用无符号形式来定义整数 $x’, y’$，则有</p>

\[\text{T2B}_w(x *_w^t y) = \text{U2B}_w(x' *_w^u y').\]

<p>检测整数乘法是否溢出的代码如下：</p>

<pre><code class="language-C">int tmult_ok(int x, int y){
    // first way:
    int p = x * y;
    return !x || p/x == y;

    // second way:
    int64_t p = x*y;
    return p == (int)p;
}
</code></pre>

<p>证明思路如下：</p>
<ol>
  <li>$x$和$y$的乘积可以写作 $x\cdot y = p + t2^w$, 计算溢出当且仅当 $t\neq 0$.</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>$p$ 可以写作 $p = xq +r$，其中 $</td>
          <td>r</td>
          <td>&lt;</td>
          <td>x</td>
          <td>$.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>可证明 $q=y$ 当且仅当 $r=t=0$.</li>
</ol>

<p><strong>在分配内存的时候尤其要注意溢出的情况，由此会产生很多安全漏洞！</strong></p>

<h3 id="乘以常数">乘以常数</h3>

<ol>
  <li>C中变量x和k有无符号数$x$和$k$，且 $0\leq k &lt; w$，则有<code class="language-plaintext highlighter-rouge">x&lt;&lt;k</code>得到数值 $x *_w^u 2^k$.</li>
  <li>C中变量x和k有补码值$x$和无符号数$k$，且 $0\leq k &lt; w$，则有<code class="language-plaintext highlighter-rouge">x&lt;&lt;k</code>得到数值 $x *_w^t 2^k$.</li>
</ol>

<p>对于某个常数$K$，编译器会将$K$的二进制表达为一组01序列: $[(0\ldots 0)(1\ldots 1)(0\ldots 0)\ldots(1\ldots 1)]$，考虑一组从位置$n$到位置$m$的连续的1，我们可以用下面两种不同形式的一种来计算这些位对乘积的影响：</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">(x&lt;&lt;n) + (x&lt;&lt;(n-1)) + ... + (x&lt;&lt;m)</code></li>
  <li><code class="language-plaintext highlighter-rouge">(x&lt;&lt;(n+1)) - (x&lt;&lt;m)</code></li>
</ol>

<p>例：</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">x*17 == (x&lt;&lt;4) + x</code></li>
  <li><code class="language-plaintext highlighter-rouge">x*(-7) == x - (x &lt;&lt; 3)</code></li>
  <li><code class="language-plaintext highlighter-rouge">x*60 == (x&lt;&lt;6) + (x&lt;&lt;2)</code></li>
  <li><code class="language-plaintext highlighter-rouge">x*-112 == (x&lt;&lt;4) - (x&lt;&lt;7)</code></li>
</ol>

<h3 id="除以2的幂">除以2的幂</h3>

<ol>
  <li>C中变量x和k有无符号数$x$和$k$，且 $0\leq k &lt; w$，则有<code class="language-plaintext highlighter-rouge">x&gt;&gt;k</code>得到数值 $\lfloor x/2^k \rfloor$.</li>
  <li>C中变量x和k有补码值$x$和无符号数$k$，且 $0\leq k &lt; w$，则有<code class="language-plaintext highlighter-rouge">x&gt;&gt;k</code>得到数值 $\lfloor x/2^k \rfloor$.</li>
</ol>

<p>然而对于负数而言，移位会导致结果向下舍入，但我们更希望向零舍入，此时我们利用<strong>偏移(biasing)</strong>的方法来进行修正：</p>

<p>C中变量x和k有补码值$x$和无符号数$k$，且 $0\leq k &lt; w$，则有<code class="language-plaintext highlighter-rouge">(x+ (1&lt;&lt;k) - 1) &gt;&gt; k</code>得到数值 $\lceil x/2^k \rceil$.</p>

<p>这里利用了性质：对于整数 $x,y(y&gt;0)$，有 $\rceil x/y \rceil = \rfloor (x+y-1)/y \lfloor.$ 由此我们可以写出C语言计算 $x/2^k$的代码</p>

<pre><code class="language-C">(x &lt; 0 ? x + (1&lt;&lt;k) - 1 : x) &gt;&gt; k
</code></pre>

<p>例题：写一个函数计算$x/16$:</p>

<pre><code class="language-C">int bias = (x &gt;&gt; 31) &amp; 0xF;
x = (x + bias) &gt;&gt; 4;
</code></pre>

<p><strong>注意这里利用了算术右移以及掩码的性质。</strong></p>

<h3 id="一些c语言interger-puzzles">一些C语言Interger puzzles</h3>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1. $x&lt;0 \nRightarrow(x*2)&lt;0$</td>
      <td>可能会出现溢出</td>
    </tr>
    <tr>
      <td>2. $ux \geq 0$</td>
      <td>正确</td>
    </tr>
    <tr>
      <td>3. $x \&amp; 7 == 7 \Rightarrow (x«30)&lt;0$</td>
      <td>正确</td>
    </tr>
    <tr>
      <td>4. $ux &gt; -1$是错的</td>
      <td>隐含的int转换为unsigned</td>
    </tr>
    <tr>
      <td>5. $x&gt;y \nRightarrow -x&lt;-y$，注意TMin的情况</td>
      <td>-(Tmin)=TMin</td>
    </tr>
    <tr>
      <td>6. $x*x\geq 0$是错的</td>
      <td>可能会出现溢出</td>
    </tr>
    <tr>
      <td>7. $x&gt;0 \&amp;\&amp; y&gt;0 \nRightarrow x+y &gt; 0 $</td>
      <td>可能会出现溢出</td>
    </tr>
    <tr>
      <td>8. $x\geq 0 \Rightarrow -x\leq 0$</td>
      <td>正确</td>
    </tr>
    <tr>
      <td>9. $x\leq 0 \nRightarrow -x \geq 0$</td>
      <td>TMin</td>
    </tr>
    <tr>
      <td>10. $(x \vert -x)»31 == -1$ 当$x\neq 0$的情况下成立</td>
      <td>正确</td>
    </tr>
    <tr>
      <td>11. $ux»3 == ux/8$</td>
      <td>正确</td>
    </tr>
    <tr>
      <td>12. $x»3 == x/8$ 当$x$为负数的时候不成立</td>
      <td>正确</td>
    </tr>
    <tr>
      <td>13. $x\&amp; (x-1)!=0$当$x==2^k$的时候不成立</td>
      <td>正确</td>
    </tr>
    <tr>
      <td>14. $x+y == ux + uy$</td>
      <td>正确，隐含转换</td>
    </tr>
    <tr>
      <td>15. $x * \sim y + uy*ux == -x$</td>
      <td>~y=-y-1,模数加乘具有交换性</td>
    </tr>
    <tr>
      <td>16. $(x&lt;y) == (-x&gt;-y)$</td>
      <td>注意y=TMin</td>
    </tr>
    <tr>
      <td>17. $((x+y)«4)+y-x = 17<em>y+15</em>x$</td>
      <td><strong>正确</strong>，模数加乘具有交换性</td>
    </tr>
    <tr>
      <td>18. $(ux-uy) == -(unsigned)(y-x)$</td>
      <td><strong>正确</strong></td>
    </tr>
    <tr>
      <td>19. $((x»2)«2) \leq x$</td>
      <td><strong>正确</strong></td>
    </tr>
  </tbody>
</table>

<h2 id="浮点数">浮点数</h2>

<h3 id="ieee浮点表示">IEEE浮点表示</h3>

<p>IEEE浮点标准用 $V=(-1)^s\times M \times 2^E$ 的形式来表示一个数：</p>
<ol>
  <li><strong>符号(sign)</strong>: $s$ 决定这个数是负数$(s=1)还是正数 $(s=0)$，而对于数值0的符号位解释作为特殊情况处理。</li>
  <li><strong>尾数(significand)</strong>: $M$是一个二进制小数，它的范围是 $[1, 2-\epsilon]$或者是 $[0, 1-\epsilon]$。</li>
  <li><strong>阶码(exponent)</strong>: $E$的作用是对浮点数加权，这个权重是2的$E$次幂（可能是负数）。</li>
</ol>

<p>由此将浮点数的位分为三个字段，分别对这些值进行编码：</p>
<ol>
  <li>一个单独的符号位 $s$ 编码符号 $s$，</li>
  <li>$k$ 位的阶码字段exp $=e_{k-1}\ldots e_0$ 编码阶数 $E$，</li>
  <li>$n$ 位小数字段frac $=f_{n-1}\ldots f_0$ 编码尾数 $M$，但是编码出来的值也依赖于阶码字段的值是否为0.</li>
</ol>

<p>在单精度浮点格式中，$s$,exp,frac字段分别为1位，$k=8$位，$n=23$位；在双精度浮点格式中，$s$,exp,frac字段分别为1位，$k=11$位，$n=52$位。</p>

<div align="center"> <img src="/pic/IEEE.png" width="500" /> </div>

<p>给定位表示，根据exp的值，被编码的值分为三种情况：</p>
<ol>
  <li>
    <p><strong>规格化的值</strong>：
 当exp的位模式既不全为0，也不全为1的时候，称为规格化的值，阶码字段被解释为<strong>偏置(<em>bias</em>)形式</strong>表示的有符号整数，阶码的值为 $\mathbf{E=e-bias}$，其中 $e$ 是无符号数，其位表示为 $e_{k-1}\ldots e_1e_0$(1-254,1-2046)，而<em>bias</em>是一个等于 $2^{k-1}-1$ (127,1023)的偏置值。
 由此产生的指数取值范围对于单精度是 $[-126,127]$，对于双精度为 $[-1022,1023]$。</p>

    <p>小数字段frac被解释为描述小数值 $0\leq f &lt; 1$，其二进制表示为 $0.f_{n-1}\ldots f_1f_0$，尾数定义为 $\mathbf{M=1+f}$，这样也叫做<strong>隐含的以1开头的表示(implied leading 1)</strong>，这样我们就可以轻松获得一个额外精度位。</p>
  </li>
  <li>
    <p><strong>非规格化的值</strong>
 当阶码域全为0时，所表示的数是非规格化形式，在这种情况下，阶码值为$\mathbf{E=1-Bias}$，而尾数值为 $\mathbf{M=f}$，也就是不包含隐含的开头的1。</p>

    <p>这种数有两个用途：</p>
    <ol>
      <li>提供了一种表示0的方法，因为使用规格化数必须使 $M\geq 1$,因此我们不能表示0，此时有+0.0和-0.0，在一些数值运算下被认为是不同的。</li>
      <li>非规格化数也用来表示那些非常接近于0.0的数，他们提供了一种属性称为<em>逐渐下溢</em>，其中，可能的数值分布均匀地接近于0.0.</li>
    </ol>
  </li>
  <li>
    <p><strong>特殊值</strong>
当阶码全为1时，如果小数域全为0，表示的则是无穷；如果小数域非零，表示的则是NaN，通常一些运算的结果不能是实数或者无穷的时候就会返回NaN。</p>
  </li>
</ol>

<p>下图是三种情况的位表示图例：</p>
<div align="center"> <img src="/pic/IEEEcate.png" width="500" /> </div>

<h4 id="数字示例">数字示例</h4>

<p>假如我们有8位格式，阶码位 $k=4$ 位，尾数位 $n=3$ 位，则偏置量为 $2^{4-1}-1=7$，部分可能结果如下：</p>
<div align="center"> <img src="/pic/IEEEexample.png" width="700" /> </div>

<p>可以观察到<strong>最大非规格数和最小规格化数之间的平滑转变</strong>，这归功于我们对<strong>非规格化数$E$的定义</strong>。另外，阶数越高，两个数之间的间距越大。</p>

<p>还可以发现，假如我们将浮点数的位表达式解释为无符号整数，那么对于所有正数而言，<strong>它们就是升序排列的</strong>，负数正好相反，IEEE这样设计就是为了浮点数能够使用整数排序函数来进行排序。</p>

<p>这里举一些特殊的值：</p>
<ol>
  <li>值+0.0总有一个全为0的位表示。</li>
  <li>最小的正非规格化值的位表示是最低有效位为1而其他所有位为0构成的，此时尾码值$M=f=2^{-n}$，阶码值 $E=-2^{k-1}+2$，因此 $V=2^{-n-2^{k-1}+2}$。</li>
  <li>最大的正非规格化值的位表示是全为0的阶码字段和最低有效位为1而其他所有位为0构成的，此时尾码值 $M=f=1-2^{-n}$，阶码值 $E=-2^{k-1}+2$，因此 $V=(1-2^{-n})\times 2^{-2^{k-1}+2}$。</li>
  <li>最小的正规格化值的位模式的阶码的最低有效位为1，其他为0，此时尾码值$M=1$，阶码值为 $E=-2^{k-1}+2$，因此 $V=2^{-2^{k-1}+2}$。</li>
  <li>最大的正规格化值的位模式的阶码的最低有效位为0，其他为1，此时尾码值 $M=2-2^{-n}$，阶码值为 $E=2^{k-1}-1$，因此 $V=(2-2^{-n})\times 2^{2^{k-1}-1} = 2^{2^{k-1}}(1-2^{-n-1})$。</li>
  <li>值1.0的位表示的阶码字段除了最高有效位为0外，其他位均为1，尾码字段均为0，此时 $M=1,E=0$。</li>
</ol>

<p>例子：12345具有二进制表示[11000000111001] = $1.1000000111001_2\times 2^{12}$，此时我们丢掉开头的1，并且在末尾加10个0，来构造小数字段，得到二进制表示[10000001110010000000000]，位构造阶码字段，我们用13加上偏置值127得到140，二进制表示为[10001100]，再加上符号位0，就得到了二进制的浮点数表示[0 10001100 10000001110010000000000],观察到整数值二进制[11000000111001]，正好对应于等于1的最高有效位之前（这就是隐含的开头1）。</p>

<p><strong>对于一个具有$n$位小数的浮点格式，不能准确描述的最小正整数为 $2^{n+1}+1$</strong>：当表示到 $2^{n+1}$ 之后，下一个数为 $2^{n+1}+2^{n+1}\times 2^{-n}=2^{n+1}+10$。</p>

<p><strong>能够被准确描述的最大奇整数位 $2^{n+1}-1$</strong>。</p>

<h3 id="舍入">舍入</h3>

<p>舍入共有四种形式：向偶数舍入、向零舍入、向上舍入、向下舍入。</p>

<p>向偶数舍入可以叫做“四舍六入五留双”，例如，可以将1.234999舍入为1.23，1.235001舍入为1.24，1.235000舍入为1.24，因为4是偶数。</p>

<p>同样的，向偶数舍入可以应用到二进制小数上，我们将最低有效位的值0认为是偶数，1认为是奇数。一般来说，只有形如XXXXX.YYYY10000的二进制位模式才会向偶数舍入，其中最右边的Y是被舍入的位置。</p>

<p>例：</p>
<ol>
  <li>$10.010_2\Rightarrow 10.0$</li>
  <li>$10.011_2\Rightarrow 10.1$</li>
  <li>$10.110_2\Rightarrow 11.0$</li>
  <li>$11.001_2\Rightarrow 11.0$</li>
</ol>

<h3 id="浮点运算">浮点运算</h3>

<p>前面我们看到了整数加法形成了阿贝尔群，实数的加法同样如此，但是我们要考虑舍入的影响。我们定义 $x+^f y = \text{Round}(x+y)$。</p>

<p>加法运算过程：$(-1)^{s_1}M_12^{E_1} +^f (-1)^{s_2}M_2 2^{E_2} \rightarrow (-1)^sM2^E(E_1\geq E_2)$:</p>
<ol>
  <li>$S,M$位对齐后的加法，$E=E_1$.</li>
  <li>如果$M\geq 2$，$M$右移一位，$E$加1.</li>
  <li>如果$M&lt;1$，$M$左移$k$位，$E$减$k$.</li>
  <li>如果$E$超出范围则溢出，</li>
  <li>舍入到frac精度范围。</li>
</ol>

<p>可以看到它有以下性质：</p>
<ol>
  <li>运算是可交换的，即$x+^f y = y +^f x$，</li>
  <li>运算是<strong>不可结合</strong>的，例如$(3,14+1e10)-1e10=0.0,\ 3.14+(1e10-1e10)=3.14$，</li>
  <li>大多数值在浮点加法下存在逆元，但是无穷和NaN是例外，</li>
  <li>浮点加法满足单调性：如果$a\geq b$，那么除了NaN，对于任何$x$的值都有$x+a\geq x+b$。<strong>整数加法是不具备这个性质的</strong>，</li>
  <li>0是加法的单位元。</li>
</ol>

<p>浮点数乘法的定义也是类似的$x\times^fy=\text{Round}(x\times y)$，浮点乘法有以下性质：</p>
<ol>
  <li>乘法是封闭的，是可交换的，有乘法单位元1.0，</li>
  <li>不可结合的，例如$(1e20<em>1e20)</em>1e-20$为正无穷，而$1e20<em>(1e20</em>1e-20)$为$1e20$.</li>
  <li>对于加法没有分配性，例如$1e20<em>1e20-1e20</em>1e20$会得到NaN，</li>
  <li>对于任何$a,b,c$，并且都不为NaN，则乘法也满足单调性。</li>
</ol>

<h3 id="c语言中的浮点数">C语言中的浮点数</h3>

<ol>
  <li>int转换为double，数字不会溢出但是可能被舍入。</li>
  <li>int或float转换为double，能够保留精确数值。</li>
  <li>double转换成float，可能会溢出，也可能会舍入。</li>
  <li>float或double转换为int，如果没有溢出的话，<strong>值会向零舍入</strong>。</li>
</ol>

<p>例子：x,f,d分别为int, float, double.</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">x==(int)(double)x</code></li>
  <li><code class="language-plaintext highlighter-rouge">x!=(int)(float)x</code></li>
  <li><code class="language-plaintext highlighter-rouge">d != (double)(float)d</code></li>
  <li><code class="language-plaintext highlighter-rouge">f == (float)(double)f</code></li>
  <li><code class="language-plaintext highlighter-rouge">f == -(-f)</code></li>
  <li><code class="language-plaintext highlighter-rouge">1.0/2 = 1/2.0</code></li>
  <li><code class="language-plaintext highlighter-rouge">d*d&gt;=0</code></li>
  <li><code class="language-plaintext highlighter-rouge">(f+d)-f != d</code>：浮点加法不存在结合律（后面的-f无法移动到前边）</li>
  <li><code class="language-plaintext highlighter-rouge">d&gt;f =&gt; -d &lt; -f</code></li>
</ol>

<p>x,y,z为int，dx,dy,dz = (double)x,y,z.</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">(float) x == (float)dx</code>  dx保留了x的所有精度，所以转化为float是一样的。</li>
  <li><code class="language-plaintext highlighter-rouge">dx-dy == (double)(x-y)</code> <strong>错误</strong>，x-y有可能会溢出</li>
  <li><code class="language-plaintext highlighter-rouge">(dx+dy)+dz == dx+(dy+dz)</code> <strong>正确</strong>，因为三个int相加不会出现舍入误差</li>
  <li><code class="language-plaintext highlighter-rouge">(dx*dy)*dz == dx*(dy*dz)</code> <strong>正确</strong></li>
  <li><code class="language-plaintext highlighter-rouge">dx/dx == dz/dz</code> <strong>错误</strong>，当dx为0，dz不为0的时候不相等。</li>
</ol>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="CSAPP" /><summary type="html"><![CDATA[信息的表示和处理]]></summary></entry><entry><title type="html">CSAPP-1:家庭作业以及Data Lab要点</title><link href="http://localhost:4000/2023/11/24/CSAPP-hm1/" rel="alternate" type="text/html" title="CSAPP-1:家庭作业以及Data Lab要点" /><published>2023-11-24T14:23:00+08:00</published><updated>2023-11-24T14:23:00+08:00</updated><id>http://localhost:4000/2023/11/24/CSAPP-hm1</id><content type="html" xml:base="http://localhost:4000/2023/11/24/CSAPP-hm1/"><![CDATA[<h2 id="信息存储">信息存储</h2>

<ol>
  <li>
    <p>将一个$w$位的字中的字节0(最低位)开始编号，并将参数$x$的字节$i$替换为字节$b$，<strong>要考虑大小端</strong>：</p>

    <pre><code class="language-C"> unsigned replace_byte(unsigned x, int i, unsigned char b)
 {
     unsigned int *p = &amp;x;
     unsigned char *v = (unsigned char *) p;
        
     if (is_little_endian())
         v[i] = b;
     else 
         v[sizeof(unsigned) - i - 1] = b;
        
     return *p;
 }

 int is_little_endian(void)
 {
     int n = 1;
     int *p = &amp;n;
     int *v = (void *) p;
        
     if (*v == 0x01)
         return 1;
     else
         return 0;
 }
</code></pre>
  </li>
  <li>判断表达式是否满足以下任一条件： <strong>通过逻辑反的判断来确保任何结果都是对的</strong>
    <ol>
      <li>$x$的任何位都为1                <code class="language-plaintext highlighter-rouge">!(x ^ 0xffffffff)</code></li>
      <li>$x$的任何位都为0                <code class="language-plaintext highlighter-rouge">!(x ^ 0x0)</code></li>
      <li>$x$的最低有效字节的位都为1       <code class="language-plaintext highlighter-rouge">!((x &amp; 0xff) ^ 0xff)</code></li>
      <li>$x$的最低有效字节的位都为0       <code class="language-plaintext highlighter-rouge">!((x &amp; 0xff) ^ 0x0)</code></li>
    </ol>
  </li>
  <li>
    <p>判断机器是否为算术右移：</p>

    <pre><code class="language-C"> int int_shifts_are_arithmetic()
 {
     int n = -1;
     int shifts = (n&gt;&gt;2);
     return shifts == n;
 }
</code></pre>
  </li>
  <li>
    <p>用算术右移来完成逻辑右移以及用逻辑右移完成算术右移，后面其他操作不能包含右移和除法。
在实现算术右移的时候注意 <strong>如何判断x的最高位是否为1</strong></p>

    <pre><code class="language-C"> // 算术右移到逻辑右移
 unsigned srl(unsigned x, int k)
 {
     /* perform shift arithmetically */
     unsigned xsra = (int) x &gt;&gt; k;
        
     int mask = -1;
        
     mask = mask &lt;&lt; ((sizeof(int) &lt;&lt; 3) - k);
     return ~mask &amp; xsra;
 }

 unsigned sra(int x, int k)
 {
     /* perform shift logically */
     int xsrl = (unsigned) x &gt;&gt; k;
        
     unsigned mask = 1;
     int *p = &amp;x;
     char *temp = (void *) p;
        
     // 判断x的最高位是否为1
     int h = (((mask &lt;&lt; 7) &amp; temp[sizeof(int) - 1]) == 128);
        
     h = (-h) &lt;&lt; ((sizeof(int) &lt;&lt; 3) - k);
     return h | xsrl;
 }
</code></pre>
  </li>
  <li>
    <p>判断是否$x$的任一奇数位为1：<code class="language-plaintext highlighter-rouge">!(x &amp; 0x55555555)</code>. <strong>这里要用<code class="language-plaintext highlighter-rouge">&amp;</code>是因为避免$x$偶数位的影响。</strong></p>
  </li>
  <li>
    <p>判断$x$的位表示中是否有奇数个1：</p>

    <pre><code class="language-C"> int odd_ones(unsigned x)
 {
     x ^= x &gt;&gt; 1;
     x ^= x &gt;&gt; 2;
     x ^= x &gt;&gt; 4;
     x ^= x &gt;&gt; 8;
     x ^= x &gt;&gt; 16;
     return x &amp; 0x1;
 }
</code></pre>

    <p>第一次异或的结果，第$i$个位置上是1代表原数中第$i$位和第$i+1$位有一个为1，也就是奇数个1。也就是说，某个位为1，代表从它开始向左连续两位中1的个数是奇数（异或的本质）。第二次异或，就是两位两位的比较了，比如，若结果第6位为1，那么代表上一次的结果的第6位和第8位有奇数个1，也就是原数中第6,7,8,9位中有奇数个1。
 <strong>整个过程就是不断的压缩信息。</strong></p>
  </li>
  <li>
    <p>得到暗示x最左侧的1的掩码，例如<code class="language-plaintext highlighter-rouge">0xFF00 -&gt; 0x8000</code></p>

    <pre><code class="language-C"> int leftmost_one(unsigned int x)
 {
     unsigned int base = 0x80000000;
     while(base)
     {
         if((x &amp; base))
             break;
         base &gt;&gt;= 1;
     }
 }
</code></pre>

    <p>这样做可以返回<code class="language-plaintext highlighter-rouge">0x8000</code>，但是没有涉及到掩码：</p>

    <pre><code class="language-C"> int leftmost_one(unsigned x)
 {
     x |= x &gt;&gt; 1;
     x |= x &gt;&gt; 2;
     x |= x &gt;&gt; 4;
     x |= x &gt;&gt; 8;
     x |= x &gt;&gt; 16;
     return (x &amp; (~(x &gt;&gt; 1)));
 }
</code></pre>

    <p>假设此时的字长$w$ = 8，假设 <code class="language-plaintext highlighter-rouge">x = 00010110</code>，首先<strong>前五步将$x$最左侧的1的右侧全置为1</strong>，得到<code class="language-plaintext highlighter-rouge">0x00011111</code>，在此基础上右移一位再取反就可以得到掩码了。</p>
  </li>
  <li>
    <p>得到最低侧$n$位均为1的值：<code class="language-plaintext highlighter-rouge">-1 &gt;&gt; (w-n)</code><strong>注意当$n=w$的情况，此时右移$n$位的实际操作是不变</strong></p>
  </li>
  <li>
    <p>将$x$的最高$n$位交换到末尾，例如: <code class="language-plaintext highlighter-rouge">n=4, x=0x12345678 -&gt; 0x23456781</code></p>

    <pre><code class="language-C"> unsigned rotate_left(unsigned x, int n)
 {
     int w = sizeof(int) &lt;&lt; 3;
     unsigned temp = x &gt;&gt; (w - n - 1) &gt;&gt; 1;
        
     return (x &lt;&lt; n) + temp;
 }
</code></pre>
  </li>
  <li>
    <p>判断一个数能否用$n$位补码来表示：</p>

    <p><strong>正数需要要求第$n$位不为1，例如2是无法用2位来表示的。</strong>
<strong>负数要求$n$到$w$位均为1才可以。</strong></p>

    <pre><code class="language-C">int fits_bits(int x, int n)
{
    int neg = x &gt;&gt; (n - 1); //考虑算术右移
    int pos = x &gt;&gt; (n - 1); 
    return neg == -1 || pos == 0;
}
</code></pre>
  </li>
  <li>$a^k$表示$a$重复$k$次，假设一个$w$位的类型，如何不适用$w$得到以下数值
    <ol>
      <li>$1^{w-k}0^{k}$:             <code class="language-plaintext highlighter-rouge">(-1) &lt;&lt; k</code></li>
      <li>$0^{w-k-j}1^k0^j$:          <code class="language-plaintext highlighter-rouge">a = -1 &lt;&lt; (k-j), b = -1 &lt;&lt; j,  ~(a|~b)</code></li>
    </ol>
  </li>
</ol>

<h2 id="整数运算">整数运算</h2>

<ol>
  <li>
    <p>符号整数饱和加法（正溢出返回TMax，负溢出返回TMin）以及对应的判断减法是否溢出（<strong>注意y=TMin的情况</strong>）</p>

    <pre><code class="language-C"> int asturating_add(int x, int y)
 {
     int sum = x + y;
     int w = sizeof(int) &lt;&lt; 3;
        
     // x, y, sum的最高位
     int h_x = (unsigned) x &gt;&gt; (w - 1);
     int h_y = (unsigned) y &gt;&gt; (w - 1);
     int h_sum = (unsigned) sum &gt;&gt; (w - 1);
        
     // neg = 1 表示负溢出， pos = 1 表示正溢出
     int neg = h_x &amp;&amp; h_y &amp;&amp; !h_sum;
     int pos = !h_x &amp;&amp; !h_y &amp;&amp; h_sum;
        
     return (-neg &amp; INT_MIN) + (-pos &amp; INT_MAX);
 }

 int tsub_ok(int x, int y)
 {
     if(y == INT_MIN){
         return x &lt; 0;
     }
     int temp = asturating_add(x, -y);
     return temp != INT_MIN &amp;&amp; temp != INT_MAX;
 }
</code></pre>
  </li>
  <li>
    <p>假设我们已有用于计算$x$和$y$采用补码形式下$x\cdot y$的高$w$位的函数</p>

    <pre><code class="language-C"> int signed_high_prod(int x, int y);
</code></pre>
    <p>现在计算无符号变量$x\cdot y$的高$w$位：</p>

    <p>这里用到$x’\cdot y’ = x\cdot y + (x_{w-1}y+y_{w-1}x)2^w + x_{w-1}y_{w-1}2^{2w}$.</p>

    <pre><code class="language-C"> int signed_high_prod(int x, int y) 
 {
 int64_t mul = (int64_t) x * y;
 return mul &gt;&gt; 32;
 }

 unsigned unsigned_high_prod(unsigned x, unsigned y)
 {
     int w = sizeof(int) &lt;&lt; 3;
     int x_highest_bit = x &gt;&gt; w - 1;
     int y_highest_bit = y &gt;&gt; w - 1;
     return signed_high_prod(x, y) + (-y_highest_bit &amp; x) + (-x_highest_bit &amp; y);
 }
</code></pre>
  </li>
  <li>
    <p>实现<code class="language-plaintext highlighter-rouge">calloc</code>函数为一个数组分配内存，该数组有nmemb个元素，每个元素size字节：<strong>判断是否发生溢出！</strong></p>

    <pre><code class="language-C"> void *calloc(size_t nmemb, size_t size)
 {
     if (nmemb == 0 || size == 0)
         return NULL;
     size_t bytes = nmemb * size;
     if (nmemb == bytes / size) // 判断是否溢出
     {
         void* ptr = malloc(bytes);
         memset(ptr, 0, bytes);
         return ptr;
     }
     return NULL;
 }
</code></pre>
  </li>
  <li>
    <p>实现整数除以2的幂数：
<strong>如何不适用判断来做到合理偏置（-1\0 &amp; mask）</strong></p>

    <pre><code class="language-C"> int divide_power2(int x, int k)
 {
     int sign = (x &amp; INT_MIN) == INT_MIN;
     int mask = (1 &lt;&lt; k) - 1;
     int bias = -sign &amp; mask;
        
     return (x + bias) &gt;&gt; k;
 }
</code></pre>
  </li>
  <li>
    <p>对于整数参数$x$，分两种方式计算$3*x/4$的值：1.会出现溢出；2.向零舍入，不会溢出。
<strong>不溢出就需要用更大的类型来存储，计算完毕后再进行舍入。</strong></p>

    <pre><code class="language-C"> int mul3div4(int x)
 {
     int result = (x &lt;&lt; 1) + x;
     return divide_power2(result, 2);
 }

 int threefourths(int x)
 {
     int64_t result = ((int64_t) x &lt;&lt; 1) + x;
     int sign = (x &amp; INT_MIN) == INT_MIN;
     int mask = (1 &lt;&lt; 2) - 1;
     int bias = -sign &amp; mask;
     return (result + bias) &gt;&gt; 2;
 }

</code></pre>
  </li>
</ol>

<h2 id="浮点数运算">浮点数运算</h2>

<ol>
  <li>实现浮点数小于号判断（假设两个参数都不是NaN）：
    <ol>
      <li>+0.0等于-0.0</li>
      <li>考虑NaN（默认比任何数都大）</li>
      <li>考虑正负号</li>
      <li>正数升序，负数降序（正负无穷也可以按照此规律）</li>
    </ol>

    <pre><code class="language-C"> unsigned f2u(float x) 
 {
 return *(unsigned*)&amp;x;
 }

 int float_le(float x, float y) 
 {
 unsigned ux = f2u(x);
 unsigned uy = f2u(y);

 unsigned sx = ux &gt;&gt; 31;
 unsigned sy = uy &gt;&gt; 31;
    
 return (ux &lt;&lt; 1 == 0 &amp;&amp; uy &lt;&lt; 1 == 0) ||
         (sx &gt; sy) ||
         (sx &amp;&amp; sy &amp;&amp; ux &gt;= uy) ||
         (!sx &amp;&amp; !sy &amp;&amp; ux &lt;= uy);
 }
</code></pre>
  </li>
  <li>
    <p>实现$2^x$的浮点表示：</p>

    <pre><code class="language-C"> float u2f(unsigned u)
 {
     return *(float *) &amp;u;
 }
 float fpwr2(int x)
 {
     /* Result exponent and fraction */
     unsigned exp, frac;
     unsigned u;
     if (x &lt; -126 - 23)
     {
         /* Too small. Return 0.0 */
         exp = 0;
         frac = 0;
     }
     else if (x &lt; -126)
     {
         /* Denormalized result */
         exp = 0;
         frac = 1 &lt;&lt; (23 + x + 126);
     }
     else if (x &lt; 128)
     {
         /* Normalized result. */
         exp = x + 127;
         frac = 0;
     }
     else
     {
         /* Too big. Return +oo */
         exp = 255;
         frac = 0;
     }
     /* Pack exp and frac into 32 bits */
     u = exp &lt;&lt; 23 | frac;
     return u2f(u);
 }
</code></pre>
  </li>
  <li>
    <p>实现对一个浮点数求相反数：
 <strong>关键是符号，阶码，尾码的获取与重组</strong></p>

    <pre><code class="language-C"> typedef unsigned float_bits;
    
 /* Compute -f. If f is NaN, then return f. */
 float_bits float_negate(float_bits f)
 {
     float_bits sign, exp, frac;
        
     sign = f &gt;&gt; 31;
     exp = f &gt;&gt; 23 &amp; 0xff;
     frac = f &amp; 0x7fffff;
        
     if (exp == 0xff &amp;&amp; frac)
         return f;
     else
         return (~sign &lt;&lt; 31) | (exp &lt;&lt; 23) | frac;
 }
</code></pre>
  </li>
  <li>
    <p>实现浮点数绝对值函数：</p>

    <pre><code class="language-C"> float_bits float_absval(float_bits f)
 {
     float_bits exp, frac;
        
     exp = f &gt;&gt; 23 &amp; 0xff;
     frac = f &amp; 0x7fffff;
        
     if (exp == 0xff &amp;&amp; frac)
         return f;
     else
         return 0 &lt;&lt; 31 | (exp &lt;&lt; 23) | frac;
 }
</code></pre>
  </li>
  <li>实现$2.0*f$：
    <ol>
      <li>考虑NaN</li>
      <li>考虑非规格化： <strong>frac左移一位就相当于exp最低位有1</strong></li>
      <li>考虑2f溢出的情况，即exp=0xff或0xff-1</li>
      <li>考虑规格化</li>
    </ol>

    <pre><code class="language-C"> float_bits float_twice(float_bits f)
 {
     float_bits sign, exp, frac;
        
     sign = f &gt;&gt; 31;
     exp = f &gt;&gt; 23 &amp; 0xff;
     frac = f &amp; 0x7fffff;
        
     if (exp == 0xff &amp;&amp; frac)
         return f;
        
     if (exp == 0)  // 非规格化的值
         frac &lt;&lt;= 1;
     else if (exp == 0xff - 1)  //无穷大时
     {
         frac = 0;
         exp = 0xff;
     }
     else
         exp += 1;
        
     return (sign &lt;&lt; 31) | (exp &lt;&lt; 23) | frac;
 }
</code></pre>
  </li>
  <li>实现$0.5*f$：
    <ol>
      <li>考虑NaN</li>
      <li>考虑非规格化时的舍入 <strong>学习如何向偶数舍入（只有11的情况才需要+1）</strong></li>
      <li>考虑exp=1 <strong>抛开符号位，整体右移一位再舍入</strong></li>
      <li>考虑其他规格化情况</li>
    </ol>

    <pre><code class="language-C"> float_bits float_half(float_bits f)
 {
     float_bits sign, exp, frac, rest;
        
     sign = f &gt;&gt; 31;
     exp = f &gt;&gt; 23 &amp; 0xff;
     frac = f &amp; 0x7fffff;
     rest = f &amp; 0x7FFFFFFF;
        
     if (exp == 0xff)
         return f;
        
     /* 向偶数舍入
     * round to even, we care about last 2 bits of frac
     *
     * 00 =&gt; 0 just &gt;&gt;1
     * 01 =&gt; 0 (round to even) just &gt;&gt;1
     * 10 =&gt; 1 just &gt;&gt;1
     * 11 =&gt; 1 + 1 (round to even) just &gt;&gt;1 and plus 1
     */
     int addition = (frac &amp; 0x3) == 0x3;

     if (exp == 0) {
         /* Denormalized */
         frac &gt;&gt;= 1;
         frac += addition;
     } else if (exp == 1) {
         /* Normalized to denormalized */
         rest &gt;&gt;= 1;
         rest += addition;
         exp = rest &gt;&gt; 23 &amp; 0xFF;
         frac = rest &amp; 0x7FFFFF;
     } else {
         /* Normalized */
         exp -= 1;
     }

     return (sign &lt;&lt; 31) | (exp &lt;&lt; 23) | frac;
 }
</code></pre>
  </li>
  <li>实现float到int的转换，向零舍入，如果超出表示范围则返回0x80000000：
    <ol>
      <li>考虑溢出或者NaN（<strong>int 最大只能表示$2^{31}$</strong>）</li>
      <li>当exp &lt; bias时，浮点数f的绝对值小于1，直接返回0</li>
      <li>此时bias &lt;= exp &lt; 31+bias, 即 0 &lt;= E &lt; 31 时，由于浮点数小数部分只有23位，此时分为两种情况：
        <ol>
          <li>E &gt; 23 时，rest 左移 E-23位</li>
          <li>E &lt;= 23 时，rest 右移 23-E位（<strong>将精确数字舍去一部分就是向零舍入</strong>）</li>
        </ol>
      </li>
    </ol>

    <pre><code class="language-C"> int float_f2i(float_bits f)
 {
     float_bits sign, exp, frac;
     float_bits M, E, bias;
        
     sign = f &gt;&gt; 31;
     exp = f &gt;&gt; 23 &amp; 0xff;
     frac = f &amp; 0x7fffff;
     bias = 0x7f;
        
     if (exp&gt;= 31 + bias || exp == 0xff)  // overflow or f is NaN
         return 0x80000000;
     else if (exp &lt; bias)  // 结果小于1
         return 0;
     else
     {
         M = frac | 0x800000;
         E = exp - bias;
         if (E &gt; 23)
             return pow(-1, sign) * (M &lt;&lt; (E - 23));
         else
             return pow(-1, sign) * (M &gt;&gt; (23 - E));
     }
 }
</code></pre>
  </li>
  <li>实现int到float的转换：
    <ol>
      <li>0直接返回</li>
      <li>如果是负数，先确定sign，然后取反+1获得其绝对值</li>
      <li><strong>算出最左侧的1在第k位，则exp = k+bias</strong></li>
      <li>如果k &gt; 23，<strong>需要考虑如何舍入</strong>：
        <ol>
          <li>截断的部分大于截断的一半，向上舍入</li>
          <li>截断的部分等于截断的一半，向偶数舍入 <strong>i&amp;hide == hide是判断某一位是否为1，与判断符号数是否是负数一样</strong></li>
          <li>截断的部分小于截断的一半，向下舍入</li>
        </ol>
      </li>
    </ol>

    <pre><code class="language-C"> float_bits float_i2f(int i)
 {
         unsigned sign, exp, frac;
         unsigned leftmost, rightmost, t;

         if (i == 0)
                 return i;

         sign = (i &amp; INT_MIN) == INT_MIN;
         if (sign)
                 i = ~i + 1;
         for (rightmost = 1, t = INT_MIN; (t &amp; i) != t; t &gt;&gt;= 1)
                 rightmost++;
         leftmost = (sizeof(int) &lt;&lt; 3) - rightmost; //最左侧的1的位置
         exp = leftmost + 127;

         int shift;
         if (leftmost &gt; 23) { // 考虑舍入
                 shift = leftmost - 23;
                 int mask = ((1 &lt;&lt; shift) - 1) &amp; i;
                 int half = 1 &lt;&lt; (shift - 1);
                 int hide = 1 &lt;&lt; shift;
                 //mask == half时只有舍入位为1时才加1
                 int round = mask&gt;half || (mask==half &amp;&amp; (i&amp;hide)==hide); 
                 frac = (i &gt;&gt; shift) &amp; 0x7FFFFF; //考虑算术右移的影响
                 if (frac == 0x7FFFFF &amp;&amp; round == 1) //+1有可能导致进位
                         frac = 0, exp++;
                 else
                         frac += round;
         } else { // 补满23位
                 shift = 23 - leftmost;
                 frac = (i &lt;&lt; shift) &amp; 0x7FFFFF;
         }

         return (sign &lt;&lt; 31) | (exp &lt;&lt; 23) | frac;
 }
</code></pre>
  </li>
</ol>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="CSAPP" /><summary type="html"><![CDATA[信息存储]]></summary></entry><entry><title type="html">A Good start</title><link href="http://localhost:4000/2023/11/04/A-good-start/" rel="alternate" type="text/html" title="A Good start" /><published>2023-11-04T21:43:00+08:00</published><updated>2023-11-04T21:43:00+08:00</updated><id>http://localhost:4000/2023/11/04/A-good-start</id><content type="html" xml:base="http://localhost:4000/2023/11/04/A-good-start/"><![CDATA[<p>之后会在这个主页上更新自己学习的总结。</p>]]></content><author><name>liujiyu</name><email>liujiyu_at_zju.edu.cn</email></author><category term="life" /><summary type="html"><![CDATA[之后会在这个主页上更新自己学习的总结。]]></summary></entry></feed>