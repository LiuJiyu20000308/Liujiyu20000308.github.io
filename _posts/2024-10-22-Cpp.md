---
layout: post
title: C++补充
date: 2024-10-21 10:00 +0800
tags: [C++]
toc: true
---

### 内存分区

C++内存主要分为以下几个部分：

栈（Stack）：用于存储局部变量、函数参数、返回地址等。栈是自动管理的，数据进入作用域分配空间，离开作用域自动释放。

堆（Heap）：用于动态分配内存，如使用new或malloc分配的内存。堆内存需要手动释放，否则会导致内存泄露。

全局/静态存储区：存储全局变量和静态变量。全局/静态存储区的内存在程序编译时就已经分配好，且在程序整个运行期间都存在。

常量存储区：存储常量字符串等。该区域的内存在程序编译时就已经分配好，并且内容不可更改。

代码区：存储程序的可执行代码。


### 多态的实现原理（实现方式）是什么？以及多态的优点（特点）？
实现方式：多态分为动态多态和静态多态（又称编译期多态，即在系统编译期间就可以确定程序将要执行哪个函数）

其中动态多态是通过虚函数实现的，虚函数是类的成员函数，存在存储虚函数指针的表叫做虚函数表，虚函数表是一个存储类成员虚函数的指针，每个指针都指向调用它的地方，当子类调用虚函数时，就会去虚表里面找自己对应的函数指针，从而实现“谁调用、实现谁”从而实现多态。

静态多态则是通过函数重载（函数名相同，参数不同，两个函数在同一作用域），运算符重载，和重定义（又叫隐藏，指的是在继承关系中，子类实现了一个和父类名字一样的函数，（只关注函数名，和参数与返回值无关）这样的话子类的函数就把父类的同名函数隐藏了。隐藏只与函数名有关，与参数没有关系）来实现的。

优点：加强代码的可扩展性，可替换性，增强程序的灵活性，提高使用效率，简化对应用代码的编写和修改过程。

### final标识符的作用
放在类的后面表示该类无法被继承，也就是阻止了从类的继承，放在虚函数后面该虚函数无法被重写，表示阻止虚函数的重载


### explicit关键字
只能用于修饰只有一个参数的类构造函数（有一个例外就是，当除了第一个参数以外的其他参数都有默认值的时候此关键字依然有效），它的作用是表明该构造函数是显示的，而非隐式的，跟它对应的另一个关键字是implicit，意思是隐藏的，类构造函数默认情况下声明为implicit。作用是防止类构造函数的隐式自动转换。

在`std::vector`中，`push_back()`和`emplace_back()`都用于在末尾添加元素，但它们的实现和适用场景有所不同。

### `push_back()`

- **功能**：将一个元素拷贝或移动到容器的末尾。
- **实现方式**：`push_back()`会创建一个临时对象（如果传入的是构造参数），然后将该对象拷贝或移动到`vector`的末尾。对于已存在的对象传递，是直接拷贝或移动的。
- **适用场景**：在需要添加一个已经创建好的对象（例如一个临时变量或函数返回的对象）时使用`push_back()`更直观。

```cpp
std::vector<std::string> vec;
std::string str = "hello";
vec.push_back(str);           // 拷贝 str
vec.push_back("world");        // 创建临时对象并拷贝
vec.push_back(std::move(str)); // 移动 str
```

### `emplace_back()`

- **功能**：直接在`vector`的末尾构造对象，避免不必要的拷贝或移动操作。
- **实现方式**：`emplace_back()`会将传入的参数直接用于调用对象的构造函数，因此不会额外创建临时对象。这在效率上更高，特别是对于复杂对象来说。
- **适用场景**：在需要添加新对象且不希望额外拷贝时，使用`emplace_back()`更合适，尤其在构造的过程中可以直接传入参数。

```cpp
std::vector<std::string> vec;
vec.emplace_back("hello");    // 直接构造字符串，无需拷贝
vec.emplace_back(10, 'a');    // 调用 std::string(10, 'a') 构造字符串
```
- **`push_back()`**适用于已有对象或简单对象的插入，能更直观表达意图。
- **`emplace_back()`**适合在需要构造复杂对象时使用，因为它可以避免临时对象的创建，提高效率。

### 类中static函数是否能声明为虚函数？
不能，因为类中的static函数是所有类实例化对象所共有的，没有this指针，而虚函数依靠vptr和vtable来处理，vptr是一个指针，在类中的构造函数中生成，并且只能通过this指针访问，对于静态成员函数来说，他没有this指针，无法访问vptr，因此static函数无法声明为虚函数


### 为什么存在this指针？
类和对象中的成员函数存储在公共的代码段，不同的对象调用成员函数时编译器为了知道具体操作的是哪一个对象给每个“非静态的成员函数”增加了一个隐藏的指针参数，让该指针指向当前对象，在函数体中所有成员变量的操作，都是通过这个指针来完成的由编译器自动完成。

C++ 中有四种主要的强制类型转换方式：`static_cast`、`dynamic_cast`、`const_cast` 和 `reinterpret_cast`，它们各自有不同的功能和适用场景。以下是每种类型转换的特点和实现原理：


### 四个类型强制转换
##### 1. `static_cast`

- **特点**：用于在编译时执行显式的类型转换。它可以在已知不会引发错误的情况下，用于安全类型转换。
  - 支持基本数据类型之间的转换，如`int`到`float`。
  - 支持指针或引用在类层次结构中的转换，但只能用于已知类型的上下层关系（例如父类到子类的转换）。
  - 支持 void* 到其他指针类型的转换。
- **原理**：在编译时执行，转换过程中不会进行运行时检查，因此效率较高，但不适用于多态类型的安全转换。
- **适用场景**：当确定转换是合法且安全时，如基本类型之间转换、类层次结构中父类指针转换为子类指针（前提是确知转换有效）。

  ```cpp
  float f = 3.14;
  int i = static_cast<int>(f); // 浮点转为整数
  ```

##### 2. `dynamic_cast`

- **特点**：用于在运行时执行安全的类型转换，主要用于指针或引用之间的转换。只能用于带有虚函数的多态类（即 RTTI，运行时类型识别）。
  - 如果转换失败，指针类型会返回 `nullptr`，引用类型会抛出 `bad_cast` 异常。
  - 只能用于类层次结构中基类和派生类之间的转换。
- **原理**：依赖于 RTTI 机制，在运行时检查类型安全性，适用于基类指针向派生类指针的转换（即向下转型）。
- **适用场景**：当需要在类层次结构中安全地进行向下转换，并且类是多态类（带有虚函数表）时。

  ```cpp
  class Base { virtual void func() {} }; // 必须是多态类
  class Derived : public Base {};

  Base* b = new Derived;
  Derived* d = dynamic_cast<Derived*>(b); // 转换成功
  ```

##### 3. `const_cast`

- **特点**：用于去掉或添加 `const` 或 `volatile` 修饰符，通常用于处理需要修改 `const` 对象的场景。
  - 只能更改对象的`const`或`volatile`属性，不能用于其他类型的转换。
- **原理**：编译时直接更改类型的`const`或`volatile`修饰，不影响数据在内存中的布局。
- **适用场景**：当需要在调用接口时移除`const`属性，如需要对`const`对象进行某些不可更改操作，或需要传递`const`对象给非`const`函数。

  ```cpp
  const int a = 10;
  int* p = const_cast<int*>(&a); // 去掉 const 修饰
  ```

##### 4. `reinterpret_cast`

- **特点**：用于进行极为底层的、类型上不安全的强制转换。它可以将任何指针类型转换为其他指针类型，或将整数转换为指针类型。
  - 不同类型的指针之间、整数和指针之间可以相互转换。
  - 该转换并不更改数据的底层二进制表示。
- **原理**：直接重新解释内存中的二进制内容，将指针或数据的类型重新解释为目标类型。转换后数据的行为可能无法预测，因此需慎重使用。
- **适用场景**：当需要进行底层数据操作（如位操作或字节处理）时，或者需要将指针类型和整数类型之间转换时。

  ```cpp
  int i = 65;
  char* p = reinterpret_cast<char*>(&i); // 将 int* 转为 char*
  ```


| 转换类型          | 适用范围                                       | 运行时检查   | 主要功能                                                 |
| ----------------- | ---------------------------------------------- | ------------ | -------------------------------------------------------- |
| `static_cast`     | 编译时可确定的安全转换                         | 否           | 基本类型转换、类层次结构的向上转换                       |
| `dynamic_cast`    | 类层次结构中的向下转换，适用于多态类型         | 是           | 多态类的运行时类型检查，确保转换安全                     |
| `const_cast`      | 去掉或添加`const`或`volatile`修饰              | 否           | 改变`const`或`volatile`修饰，主要用于修改`const`对象     |
| `reinterpret_cast`| 低层次、不安全的类型转换                       | 否           | 直接重新解释数据的二进制表示，适用于指针和整数之间的转换 | 

##### 使用建议

- 优先选择 **`static_cast`** 和 **`dynamic_cast`**，因为它们更安全、用途更清晰。
- **`const_cast`** 仅在必要时使用（如函数接口限制）。
- **`reinterpret_cast`** 应慎用，避免带来不易预期的错误和不稳定因素。


### string实现

```cpp
#include <iostream>
#include <cstring> // for strlen, strcpy

class MyString {
private:
    char* data;
    size_t len;
    size_t capacity;

public:
    // 默认构造函数
    MyString() : data(nullptr), len(0), capacity(0) {}

    // 带参数构造函数
    MyString(const char* str) {
        len = strlen(str);
        capacity = len;
        data = new char[capacity + 1];
        strcpy(data, str);
    }

    // 拷贝构造函数（深拷贝）
    MyString(const MyString& other) {
        len = other.len;
        capacity = other.capacity;
        data = new char[capacity + 1];
        strcpy(data, other.data);
    }

    // 移动构造函数
    MyString(MyString&& other) noexcept : data(other.data), len(other.len), capacity(other.capacity) {
        other.data = nullptr;
        other.len = 0;
        other.capacity = 0;
    }

    // 析构函数
    ~MyString() {
        delete[] data;
    }

    // 赋值运算符重载
    MyString& operator=(const MyString& other) {
        if (this != &other) {
            delete[] data; // 释放旧的内存

            len = other.len;
            capacity = other.capacity;
            data = new char[capacity + 1];
            strcpy(data, other.data);
        }
        return *this;
    }

    // 移动赋值运算符
    MyString& operator=(MyString&& other) noexcept {
        if (this != &other) {
            delete[] data;

            data = other.data;
            len = other.len;
            capacity = other.capacity;

            other.data = nullptr;
            other.len = 0;
            other.capacity = 0;
        }
        return *this;
    }

    // 获取字符串长度
    size_t size() const {
        return len;
    }

    // 获取容量
    size_t getCapacity() const {
        return capacity;
    }

    // 检索字符串中的字符
    char& operator[](size_t index) {
        if (index >= len) {
            throw std::out_of_range("Index out of range");
        }
        return data[index];
    }

    const char& operator[](size_t index) const {
        if (index >= len) {
            throw std::out_of_range("Index out of range");
        }
        return data[index];
    }

    // 添加字符到末尾
    void push_back(char c) {
        if (len + 1 >= capacity) {
            resize(capacity == 0 ? 1 : capacity * 2);
        }
        data[len++] = c;
        data[len] = '\0';
    }

    // 追加字符串
    void append(const MyString& other) {
        if (len + other.len >= capacity) {
            resize(len + other.len);
        }
        strcat(data, other.data);
        len += other.len;
    }

    // 打印字符串
    void print() const {
        if (data) {
            std::cout << data << std::endl;
        } else {
            std::cout << "(empty)" << std::endl;
        }
    }

private:
    // 重新分配内存
    void resize(size_t new_capacity) {
        char* new_data = new char[new_capacity + 1];
        if (data) {
            strcpy(new_data, data);
        }
        delete[] data;
        data = new_data;
        capacity = new_capacity;
    }
};

```

### 什么是模板的全特化？
模板的全特化是在模板的原始定义之外针对某个特定类型，提供模板的特定实现。当我们为一个模板指定了所有模板参数的具体类型时，就是全特化。全特化完全替代了通用模板，对于特定的类型，编译器将使用全特化的版本。

为什么要使用全特化？
1. 定制化特定类型的行为：对于某些特殊类型，需要不同于通用模板的实现。
2. 优化性能：针对特定类型，提供更高效的实现。
3. 解决特定类型的特殊需求：处理某些类型无法在通用模板中处理的特殊情况。

### 什么是模板的偏特化？
模板的偏特化是对模板参数进行部分特化，即不需要指定所有模板参数，而是针对某些参数或某些参数特性（如指针、引用、特定的类型模式）进行特化。

为什么要使用偏特化？
1. 更灵活的特化方式：可以针对一类类型进行特化，而不局限于某个具体类型。
2. 处理类型的某些特征：如指针类型、引用类型、数组类型等。
3. 提高代码的复用性和可维护性：通过偏特化，可以减少重复代码。

**偏特化只能用于类模板**，不能直接对函数模板进行偏特化（但可以通过重载实现类似效果）。在偏特化时，需要在模板参数列表和类名中同时体现特化的部分。
编译器会优先选择最匹配的特化版本。如果有多个特化版本可以匹配，可能会导致编译错误，需要避免这种情况。

### const关键字

1. 修饰变量：`const` 变量的值在初始化后不能被更改。
2. 修饰指针，可以细分为三种情况：
   - **指向常量的指针**：指针指向的内容不可更改，但指针本身可以指向其他地址。
   - **常量指针**：指针本身不可更改，但指向的内容可以更改。
3. 修饰函数参数，可以避免在函数内部修改该参数的值，这在传递引用或指针参数时尤为重要。
    ```cpp
    void printValue(const int &value) {
        // value = 10; // 错误，value 被 const 修饰
        std::cout << value << std::endl;
    }
    ```
4. 修饰类成员函数，表示该函数不会修改类的成员变量。只能在不修改类状态的成员函数上使用 `const`，适用于如 get 函数等。
5. 修饰返回值，在函数返回类型前加 `const` 可防止返回值在调用处被修改，例如返回对象的引用时防止被调用方修改。
    ```cpp
    const int& getConstReference() {
        static int x = 10;
        return x;
    }
    ```

### volatile 关键字
`volatile` 告知编译器不要对变量进行优化，使程序在每次访问变量时重新从内存中读取数据。这种关键字通常用于特殊情况下，如硬件寄存器访问、多线程共享标志或中断处理程序中，以确保读取到的值是最新的。

例如：在多线程编程中，某些变量可能会被多个线程共享，可能会在一个线程中修改并在另一个线程中读取。如果没有 volatile 关键字，编译器可能会将该变量缓存到寄存器中，导致其他线程无法读取到最新的值。

### const volatile什么意思
`const volatile` 修饰的变量是只读的（不能被程序代码修改）并且易变的（编译器不能优化读取操作，必须每次都从内存中读取最新值）。常见于需要频繁读取最新值但不修改的场景，例如硬件寄存器或跨线程共享的只读标志。

例如：在多线程环境中，如果一个共享标志变量仅用于指示某种状态（如停止信号），一个线程可能会设置该标志，而其他线程只能读取该标志的值且不应修改它。将这个变量声明为 `const volatile` 可以避免优化，并确保读取到最新的值。

### C++内存模型，堆里面的内部碎片和外部碎片

在 C++ 中，内存模型描述了程序如何管理和使用内存的布局。通常来说，C++ 内存模型分为以下几个区域：

1. **栈区（Stack）**：用于存储局部变量、函数调用时的参数和返回地址等。栈的内存是自动管理的，遵循“后进先出”的原则，即函数结束后栈内的局部变量自动销毁。栈内存分配效率高，但空间有限。

2. **堆区（Heap）**：用于动态分配的内存（例如通过 `new`、`malloc` 等）。堆内存由程序员手动管理，必须显式分配和释放。堆的大小仅受系统内存限制，适用于大数据结构和需要跨函数保留的数据。

3. **全局区（静态存储区）**：用于存储全局变量、静态变量和常量字符串，程序在启动时分配，直到程序结束才释放。

4. **常量存储区**：存放常量字符串，程序结束后由编译器释放。
   
5. **代码区**：存放程序的机器指令，由操作系统分配，用于存储程序的可执行代码，通常只读。

#### 堆内存中的内部碎片和外部碎片

在堆内存中，碎片化是指内存管理系统由于分配和释放不同大小的内存块而导致的空闲内存片段。碎片化分为 **内部碎片** 和 **外部碎片**。

##### 1. 内部碎片

**内部碎片**是指分配的内存块中，因分配粒度或对齐的原因，实际使用的内存少于分配的内存，造成内存浪费。例如，当分配一个较小的对象（如 5 字节），但由于内存对齐的要求，分配器可能会为它分配 8 字节，这其中多余的 3 字节就是内部碎片。

内部碎片主要发生在以下情况下：

- **内存对齐**：为确保内存访问的效率，很多系统要求内存按照特定的字节对齐（如 4 字节、8 字节）。如果请求的内存块不满足对齐要求，分配器会分配比请求更多的内存。
- **固定大小的分配单元**：某些分配器使用固定大小的内存块进行分配，如果请求的内存小于这个块的大小，则剩余部分形成内部碎片。

##### 2. 外部碎片

**外部碎片**是指堆中存在很多小的、相互分散的空闲内存块，但这些内存块彼此不连续，因此无法满足较大的内存分配请求。例如，如果程序频繁分配和释放不同大小的内存块，可能会留下分散的小空闲块。这些空闲块的总和足够大，但因为不连续，导致无法分配较大的内存块。

外部碎片会影响程序性能，降低内存分配效率，可能导致内存不足的假象。堆内存的外部碎片主要通过以下方式产生：

- **不规则的内存分配与释放**：程序频繁分配和释放不同大小的内存块，导致空闲块分散。
- **缺乏内存整理**：一些内存分配器不会自动合并相邻的空闲内存块，从而导致外部碎片。

### 内存碎片的处理方法

- **内存池**：预分配一定数量的内存块以满足相似大小的内存请求，从而减少内存碎片。
- **紧凑分配**：一些内存管理器会自动合并相邻的空闲块，减少外部碎片。
- **自定义分配器**：对特定数据结构自定义内存分配器，以便更有效地管理内存分配。

### 一般C++的类的memory layout有哪些成分，C++的对象在内存上长什么样？如果涉及到继承呢？
1. **基本类的内存布局**
    一个没有继承关系、虚函数或虚继承的简单 C++ 类的内存布局由以下成分组成：
    - **成员变量：** 按照声明顺序存储在对象内存布局中，但编译器可能会根据内存对齐要求调整实际顺序。
    - **对齐填充：** 为了满足内存对齐要求，编译器会在成员变量之间或对象的结尾填充一些字节，以确保对象在内存中对齐。

2. **带有虚函数的类的内存布局**
    当一个类包含虚函数时，编译器会在该类的对象布局中添加一个 **虚函数表指针（vptr）**，指向该类的虚函数表（`vtable`）。`vtable` 是一个指针数组，指向类的虚函数实现。这使得运行时可以通过多态性动态调用不同的函数。在这种情况下，Base 类对象的内存布局会包含以下成分：

    - vptr：指向虚函数表的指针，存储在对象的头部或其他位置。
    - 成员变量：x。
    虚函数表（vtable）则存储在程序的只读区域（常量存储区）中。

3. **带有单继承的类的内存布局**
    在单继承情况下，派生类继承基类的成员变量和 vptr（如果基类有虚函数）。派生类对象的布局如下：
    - vptr：如果基类或派生类定义了虚函数，那么 vptr 会在对象中存在。如果基类已有虚函数表，派生类会复用或重写这个 vptr。
    - 基类成员：继承基类的成员变量，保持基类的布局。
    - 派生类自己的成员：存储在基类成员之后。
    
    ```cpp
    class Derived : public Base {
    public:
        double y;
        virtual void func3();
    };
    ```
    在这种情况下，Derived 的内存布局包括：

    - vptr：指向 Derived 类的 vtable，因为 Derived 覆盖了或增加了虚函数。
    - 基类成员：继承的 x。
    - 派生类成员：y。

4. **多重继承的内存布局**
    ```cpp
    class Base1 {
    public:
        int a;
        virtual void func1();
    };

    class Base2 {
    public:
        int b;
        virtual void func2();
    };

    class Derived : public Base1, public Base2 {
    public:
        double c;
    };
    ```
    在这种情况下，Derived 的布局如下：

    - Base1 的 vptr：指向 Base1 的 vtable。
    - Base1 的成员：a。
    - Base2 的 vptr：指向 Base2 的 vtable。
    - Base2 的成员：b。
    - Derived 的成员：c。

5. **虚继承的内存布局**
    在虚继承中，派生类会共享基类的一个实例，从而避免多重继承中的菱形继承问题。编译器会为虚继承类添加一个 **虚基类指针（vptr）** 或 **虚基类表指针（vbptr）**，用于定位虚基类在对象内存中的位置。
    ```cpp
    class Base {
    public:
        int x;
    };

    class Derived1 : virtual public Base { /* ... */ };

    class Derived2 : virtual public Base { /* ... */ };

    class MostDerived : public Derived1, public Derived2 {
        // ...
    };
    ```
    在这种情况下，MostDerived 的布局可能包含：

    - Derived1的 vfptr
    - Derived1 的 vbptr：用于指向 Base 类的虚基类位置。
    - Derived1的类成员
    - Derived2的 vfptr
    - Derived2 的 vbptr：用于指向 Base 类的虚基类位置。
    - Derived2的类成员
    - Base vfptr
    - 虚基类 Base：Base 的实例在内存中只有一份，且通过 vbptr 进行定位。

### 虚继承
虚继承（Virtual Inheritance）是一种特殊的继承方式，主要用于解决多重继承中的菱形继承（或称钻石继承）问题。菱形继承问题通常会导致重复继承基类成员，造成 **冗余和二义性**，而虚继承可以确保派生类共享基类的唯一实例。

```cpp
class Base {
public:
    int value;
};

class Derived1 : public virtual Base { /* ... */ };
class Derived2 : public virtual Base { /* ... */ };

class MostDerived : public Derived1, public Derived2 { /* ... */ };
```

在启用虚继承后，C++ 编译器会在 Derived1 和 Derived2 中添加一个虚基类表指针（vbptr），指向 Base 的唯一实例位置。在实例化 MostDerived 时，编译器会根据虚基类表找到并共享 Base 的实例。

因此，MostDerived 的内存布局可能如下：

- Derived1 的 vbptr：用于指向 Base 的唯一实例。
- Derived2 的 vbptr：用于指向 Base 的唯一实例。
- 唯一的 Base 实例。
- MostDerived 自己的成员（如果有）

### 如果一个类继承了有虚函数的类，父类会存在在子类中吗
会的，派生类对象中包含基类的数据成员，因此在派生类对象中基类的部分会存在。

### 父类转子类安全吗？子类转父类呢？
**基类指针或引用转换为派生类指针或引用通常是不安全的**，因为基类对象不一定包含派生类的所有成员。如果直接将一个基类对象的指针或引用转换为派生类类型，并尝试访问派生类的成员，可能会导致未定义行为。

如果基类指针或引用实际上指向的是一个派生类对象，则可以通过 `dynamic_cast` 进行安全的转换。`dynamic_cast` 会在运行时检查类型，如果转换失败会返回 `nullptr`（对于指针）或抛出 `bad_cast` 异常（对于引用）。

**将派生类指针或引用转换为基类指针或引用通常是安全的**。因为派生类包含基类的所有成员，因此将派生类对象视为基类对象不会导致内存或成员访问问题。这种转换可以通过 **隐式转换** 或 **static_cast** 安全地完成。
### 假设是64位的机器，一个空的类占多大内存，如果这个类包含一个虚函数呢？如果有一个类继承了空类，大小是多少（分类讨论）？

- **空类**：通常占 `1` 字节。
- **含虚函数的空类**：占 `8` 字节（在 64 位系统上，为虚函数表指针大小）。
- **继承自空类的类**：
  - 如果没有额外成员，通常应用空基类优化，占 `1` 字节。
  - 如果包含其他成员，则仅占成员的大小（空基类不增加额外空间）。
- **继承自含虚函数的空类的类**：大小至少为 `8` 字节（包含 `vptr`），即使派生类本身没有增加成员。
- 
### 虚表里除了可能有虚函数，还可能有什么？
1. 虚表通常包含一个指向类型信息的指针，用于支持 typeid 和 dynamic_cast 等操作。这个指针指向的结构包含了当前类的类型信息，以便在运行时能够识别对象的实际类型。
2. 在涉及 **虚继承** 的多重继承中，虚表还可能包含 虚基类偏移指针，用于支持虚基类的定位。当派生类通过虚继承的方式继承基类时，虚基类在对象布局中的位置并不是固定的，因为不同的派生路径会共享同一个虚基类实例。


### 如果一个函数是成员模板函数，可以被声明为虚函数吗？
在 C++ 中，**成员模板函数不能被声明为虚函数**。这是因为模板函数的机制和虚函数的机制在设计和实现上存在冲突。

1. **模板函数的编译时多态性**：  
   模板函数是通过 **编译时多态** 实现的。编译器会在编译期间根据模板的具体类型生成函数的代码，即模板函数的实例化发生在编译时。这意味着，模板函数在编译时会根据使用的类型参数生成特定版本的代码。

2. **虚函数的运行时多态性**：  
   虚函数依赖于 **运行时多态**，通过虚函数表（vtable）在运行时动态绑定函数。这要求在程序执行时通过虚表指针（`vptr`）来调用合适的虚函数实现。

由于模板函数在编译时实例化，其生成的具体函数可能是无限多种类型的组合，无法在虚表中预先创建一个模板函数的实例。因此，C++ 标准不允许将模板成员函数声明为虚函数。

### 虚函数可以内联吗？
在 C++ 中，**虚函数可以被声明为内联函数**，但是在实际调用中是否会被内联展开，**取决于编译器是否能够在编译时确定具体的调用目标**。虚函数的运行时多态性机制使得它们通常不符合内联的条件，但在特定情况下，虚函数可以被内联。

1. **虚函数的运行时多态性**：  
   虚函数是通过虚函数表（vtable）实现运行时多态性的，在调用时根据对象的实际类型选择具体的函数实现。这种机制通常需要在运行时确定调用的具体实现，因此通常通过基类指针或引用调用虚函数时，编译器在编译期无法确定具体的实现。

2. **内联的编译时展开**：  
   内联函数的目的是在编译时直接用函数体替换函数调用，从而避免函数调用的开销（如栈帧管理和参数传递）。这要求编译器在编译期就知道函数的具体实现，以便将其展开。

虚函数的运行时多态特性和内联函数的编译时展开机制存在矛盾，因此虚函数通常难以被内联。

- **虚函数可以声明为内联**，但实际内联展开取决于编译器的判断。
- 如果通过具体对象（非指针或引用）调用虚函数，编译器可能会内联。
- 非多态调用（例如派生类中直接调用基类的虚函数）也可能被内联。
- 典型的多态调用（通过基类指针或引用调用虚函数）通常无法内联，因为编译器在编译期无法确定具体实现。
### optional<bool>取size是多大？

### 描述一下C++编译的整个过程

### 如果头文件定义了函数，源文件不实现，会在哪个环节报错？如果构建的是静态库，会报错吗？

### 对静态库和动态库的理解

### 一个shared_ptr大小是多大，unique_ptr呢？不同智能指针性能上有什么区别？如果只是用指针解引用，性能上有区别吗？

### 手动实现shared_ptr和unique_ptr

### C++多线程中常用的mutex是怎么实现的，和自旋锁有什么区别？

### atomic内部实现？是有锁还是没锁的？所有的原子变量都没锁吗？对于原子变量的memory order有了解吗？

### 无锁队列

### STL容器的线程安全

### 红黑树和哈希表的区别（时间和空间的性能上）

### 在交易场景中，哈希表和红黑树各自应当在什么时候使用？deque和vector有哪些使用场景

### 实现一个订单簿系统，有挂单吃单撤单的功能