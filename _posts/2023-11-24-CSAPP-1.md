---
layout: post
title: CSAPP-1:信息的表示和处理
date: 2023-11-24 14:23 +0800
tags: [CSAPP]
toc: true
---

## 信息的表示和处理

### 信息存储

#### 基本概念

**位(bit)** 为计算机方位内存中单独的位，**字节(byte)** 为计算机中最小的可寻址的内存单位，大多数计算机使用8-Bit的字节。机器级程序将内存视为一个非常大的字节数，称为**虚拟内存(virtual memory)**。内存的每个字节都由一个唯一的数字来标识，被称为它的**地址(address)**，所有可能地址的集合被称为**虚拟地址空间**。

每台计算机都有一个**字长(word size)**，指明指针数据的标准大小(normal size)，对于一个字长为$w$的机器而言，虚拟地址的范围为 $0\sim 2^w-1$，程序最多访问 $2^w$ 个字节。

<div align="center"> <img src="/pic/WordSize.png" width = 300/> </div>
<center><p>基本C数据类型的典型大小(以字节为单位)</p></center>

#### 寻址和字节顺序
在几乎所有的机器上，多字节对象都被存储为连续的字节，但排列表示一个对象的字节有两种通用规则：
1. 最低有效字节在前面的方式称为**小端法(little endian)**，大多数Intel兼容机，Android和IOS都只用小端模式，
2. 最高有效字节在前面的方式称为**大端法(big endian)**，网络传送数据时要求使用大端法规则。

假设变量$x$类型为int，位于地址0x100处，十六进制的值为0x01234567，下图表示两种方法排列表示的规则：
<div align="center"> <img src="/pic/LHEndian.png" width = 600/> </div>

对于大多数情况下，及其所使用的字节顺序是完全不可见的，但在一些情况下，字节顺序会成为问题：
1. 当小端法机器产生的数据被发送到大端法机器时，接收程序会发现字节反序，为避免这类问题，网络应用程序的代码编写必须遵守大端法规则（**见11章**）。
2. 当阅读表示整数数据的字节序列时字节顺序很重要，这通常发生在检查机器级程序时，例如阅读反汇编器生成的代码时（**见3章**）。
3. 当编写规避正常的类型系统的程序时字节顺序变得重要，例如：我们将byte_pointer定义为一个指向类型为unsigned char的对象的指针，这样一个字节指针引用一个字节序列，其中每一个字节都被认为是一个非负整数，
   
   ```C
    typedef unsigned char *byte_pointer;

    void show_bytes(byte_pointer start, size_t len) {
        size_t i;
        for (i = 0; i < len; i++)
        printf(" %.2x", start[i]);
        printf("\n");
    }

    void show_int(int x) {
        show_bytes((byte_pointer) &x, sizeof(int)); 
    }

    void show_float(float x) {
        show_bytes((byte_pointer) &x, sizeof(float)); 
    }

    void show_pointer(void *x) {
        show_bytes((byte_pointer) &x, sizeof(void *));
    }

    void test_show_bytes(int val) {
        int ival = val;
        float fval = (float) ival;
        int *pval = &ival;
        show_int(ival);
        show_float(fval);
        show_pointer(pval);
    }
   ```
在不同机器上得到的结果并不相同，如下图所示：
<div align="center"> <img src="/pic/Show_Bytes.png" width = 500/> </div>
这里注意每输出一次都是两位十六进制数，因为一个字节是8Bit，对应两位十六进制数。

#### 字符串表示

C语言中字符串被编码为一个以null(其值为0)字符结尾的字符数组，例如我们以参数`12345`和`6`来运行`show_bytes`，我们会得到结果 `31 32 33 34 35 00`.

### 布尔代数简介

最简单的布尔代数是在二元集合{0,1}上定义的:
1. 布尔运算 $\sim$ 对应于逻辑运算 `NOT`，在命题逻辑中用符号$\lnot$表示，
2. 布尔运算 $\And$ 对应于逻辑运算 `AND`，在命题逻辑中用符号$\land$表示，
3. 布尔运算 $\vert$ 对应于逻辑运算 `OR`，在命题逻辑中用符号$\lor$表示，
4. 布尔运算 ^ 对应于逻辑运算异或(Exlusive or)，在命题逻辑中用符号用$\oplus$表示。
具体规则如下图所示：
<div align="center"> <img src="/pic/Boolean.png" width = 400/> </div>

以上布尔运算可以扩展到**位向量**的运算，其中位向量就是固定长度为w，由0和1组成的串，它一个很有用的应用就是表示有限集合。

#### C语言中的位级运算

位级运算的一个常见用法就是**掩码运算**，例如：
1. 掩码`0xFF`表示一个字的低位字节，位级运算`x & 0xFF`生成一个由$x$的最低有效字节组成的值，而其他的字节都被置为0，
2. 位级运算`x | 0xFF`将x的最低有效字节设为1，其他字节保持不变，
3. `x ^ 0xFFFFFFFF`等价于`~x`，`x ^ 0`不发生改变，
4. `x ^ ~0xFF`使得x最低有效字节不变，其他位都取补。

关于异或运算还有两点注意：
1. `x ^ y = (x & ~y) | (~x & y)`.
2. `a ^ a = 0`.
3. `y = x^y, x = x^y, y = x^y`即可做到不需要第三个位置就可以交换$x$和$y$的值。
4. `!(x^y)`满足当$x,y$相等时返回1，否则返回0。

**三个二元位级运算都具有交换律和结合律。**

#### C语言中的逻辑运算

逻辑运算有三种: `&&`, `||`, `!`，注意别和位级运算混淆即可，另外`&&`和`||`具有短路性。

#### C语言中的移位运算

对于一个位表示为$[x_{w-1},x_{w-2},\ldots,x_0]$的操作数$x$，左移运算`x<<k`使得$x$向左移动$k$位，丢弃最高的$k$位，并在右端补上$k$个0。并且**移位运算从左到右是可结合的。**

相应地，右移运算`x>>k`分为两种:
1. 对无符号数使用逻辑右移，即在左端补$k$个0，得到$[0,\ldots,0,x_{w-1},\ldots,x_k]$.
2. 对有符号数使用算术右移，即在左端补$k$个最高有效位的值，得到$[x_{w-1},\ldots,x_{w-1},x_{w-1},x_{w-2},\ldots,x_{k}]$.

注意:
1. 对于一个$w$位组成的数据类型，当$k\geq w$很大的时候，实际上的位移量就是`k mod w`位。
2. 加减法的优先级比移位运算要高，因此在拿不准的时候记得加括号。


### 整数表示

#### 整数编码

对于位向量$\mathbf{x} = [x_{w-1},x_{w-2},\ldots,x_0]$,无符号数编码定义为
$$\text{B2U}_w(\mathbf{x}) = \sum\limits_{i=0}^{w-1} x_i 2^i$$

补码编码的定义为 $$\text{B2T}_w(\mathbf{x}) = -x_{w-1}2^{w-1} - \sum\limits_{i=0}^{w-2} x_i 2^i$$

可以证明当 $0\leq x \leq 2^w-1$时，无符号数编码是唯一的，
当 $\text{TMin}_w = -2^{w-1} \leq x \leq 2^{w-1}-1 = \text{TMax}_w$时，补码编码是唯一的。

关于这些数字，有几点值得注意：
1. 补码的范围是不对称的，即 `|TMin| = |TMax| + 1`，
2. 最大的无符号数刚好比补码的最大数的两倍大1，即`UMax = 2TMax +1`，
3. -1和 UMax 有同样的位表示，即一个全1的串。