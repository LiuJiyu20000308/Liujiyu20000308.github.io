---
layout: post
title: CSAPP-1:信息的表示和处理
date: 2023-11-24 14:23 +0800
tags: [CSAPP]
toc: true
---

## 信息的表示和处理

### 信息存储

#### 基本概念

**位(bit)** 为计算机方位内存中单独的位，**字节(byte)** 为计算机中最小的可寻址的内存单位，大多数计算机使用8-Bit的字节。机器级程序将内存视为一个非常大的字节数，称为**虚拟内存(virtual memory)**。内存的每个字节都由一个唯一的数字来标识，被称为它的**地址(address)**，所有可能地址的集合被称为**虚拟地址空间**。

每台计算机都有一个**字长(word size)**，指明指针数据的标准大小(normal size)，对于一个字长为$w$的机器而言，虚拟地址的范围为 $0\sim 2^w-1$，程序最多访问 $2^w$ 个字节。

<div align="center"> <img src="/pic/WordSize.png" width = 300/> </div>
<center><p>基本C数据类型的典型大小(以字节为单位)</p></center>

#### 寻址和字节顺序
在几乎所有的机器上，多字节对象都被存储为连续的字节，但排列表示一个对象的字节有两种通用规则：
1. 最低有效字节在前面的方式称为**小端法(little endian)**，大多数Intel兼容机，Android和IOS都只用小端模式，
2. 最高有效字节在前面的方式称为**大端法(big endian)**，网络传送数据时要求使用大端法规则。

假设变量$x$类型为int，位于地址0x100处，十六进制的值为0x01234567，下图表示两种方法排列表示的规则：
<div align="center"> <img src="/pic/LHEndian.png" width = 600/> </div>

对于大多数情况下，及其所使用的字节顺序是完全不可见的，但在一些情况下，字节顺序会成为问题：
1. 当小端法机器产生的数据被发送到大端法机器时，接收程序会发现字节反序，为避免这类问题，网络应用程序的代码编写必须遵守大端法规则（**见11章**）。
2. 当阅读表示整数数据的字节序列时字节顺序很重要，这通常发生在检查机器级程序时，例如阅读反汇编器生成的代码时（**见3章**）。
3. 当编写规避正常的类型系统的程序时字节顺序变得重要，例如：我们将byte_pointer定义为一个指向类型为unsigned char的对象的指针，这样一个字节指针引用一个字节序列，其中每一个字节都被认为是一个非负整数，
   
   ```C
    typedef unsigned char *byte_pointer;

    void show_bytes(byte_pointer start, size_t len) {
        size_t i;
        for (i = 0; i < len; i++)
        printf(" %.2x", start[i]);
        printf("\n");
    }

    void show_int(int x) {
        show_bytes((byte_pointer) &x, sizeof(int)); 
    }

    void show_float(float x) {
        show_bytes((byte_pointer) &x, sizeof(float)); 
    }

    void show_pointer(void *x) {
        show_bytes((byte_pointer) &x, sizeof(void *));
    }

    void test_show_bytes(int val) {
        int ival = val;
        float fval = (float) ival;
        int *pval = &ival;
        show_int(ival);
        show_float(fval);
        show_pointer(pval);
    }
   ```
在不同机器上得到的结果并不相同，如下图所示：
<div align="center"> <img src="/pic/Show_Bytes.png" width = 500/> </div>
这里注意每输出一次都是两位十六进制数，因为一个字节是8Bit，对应两位十六进制数。

#### 字符串表示

C语言中字符串被编码为一个以null(其值为0)字符结尾的字符数组，例如我们以参数`12345`和`6`来运行`show_bytes`，我们会得到结果 `31 32 33 34 35 00`.

### 布尔代数简介

最简单的布尔代数是在二元集合{0,1}上定义的:
1. 布尔运算 $\sim$ 对应于逻辑运算 `NOT`，在命题逻辑中用符号$\lnot$表示，
2. 布尔运算 $\And$ 对应于逻辑运算 `AND`，在命题逻辑中用符号$\land$表示，
3. 布尔运算 $\vert$ 对应于逻辑运算 `OR`，在命题逻辑中用符号$\lor$表示，
4. 布尔运算 ^ 对应于逻辑运算异或(Exlusive or)，在命题逻辑中用符号用$\oplus$表示。
具体规则如下图所示：
<div align="center"> <img src="/pic/Boolean.png" width = 400/> </div>

以上布尔运算可以扩展到**位向量**的运算，其中位向量就是固定长度为w，由0和1组成的串，它一个很有用的应用就是表示有限集合。

#### C语言中的位级运算

位级运算的一个常见用法就是**掩码运算**，例如：
1. 掩码`0xFF`表示一个字的低位字节，位级运算`x & 0xFF`生成一个由$x$的最低有效字节组成的值，而其他的字节都被置为0，
2. 位级运算`x | 0xFF`将x的最低有效字节设为1，其他字节保持不变，
3. `x ^ 0xFFFFFFFF`等价于`~x`，`x ^ 0`不发生改变，
4. `x ^ ~0xFF`使得x最低有效字节不变，其他位都取补。

关于异或运算还有两点注意：
1. `x ^ y = (x & ~y) | (~x & y)`.
2. `a ^ a = 0`.
3. `y = x^y, x = x^y, y = x^y`即可做到不需要第三个位置就可以交换$x$和$y$的值。
4. `!(x^y)`满足当$x,y$相等时返回1，否则返回0。

**三个二元位级运算都具有交换律和结合律。**

#### C语言中的逻辑运算

逻辑运算有三种: `&&`, `||`, `!`，注意别和位级运算混淆即可，另外`&&`和`||`具有短路性。

#### C语言中的移位运算

对于一个位表示为$[x_{w-1},x_{w-2},\ldots,x_0]$的操作数$x$，左移运算`x<<k`使得$x$向左移动$k$位，丢弃最高的$k$位，并在右端补上$k$个0。并且**移位运算从左到右是可结合的。**

相应地，右移运算`x>>k`分为两种:
1. 对无符号数使用逻辑右移，即在左端补$k$个0，得到$[0,\ldots,0,x_{w-1},\ldots,x_k]$.
2. 对有符号数使用算术右移，即在左端补$k$个最高有效位的值，得到$[x_{w-1},\ldots,x_{w-1},x_{w-1},x_{w-2},\ldots,x_{k}]$.

注意:
1. 对于一个$w$位组成的数据类型，当$k\geq w$很大的时候，实际上的位移量就是`k mod w`位。
2. 加减法的优先级比移位运算要高，因此在拿不准的时候记得加括号。


### 整数表示

#### 整数编码

对于位向量$\mathbf{x} = [x_{w-1},x_{w-2},\ldots,x_0]$,无符号数编码定义为
$$\text{B2U}_w(\mathbf{x}) = \sum\limits_{i=0}^{w-1} x_i 2^i$$

补码编码的定义为 $$\text{B2T}_w(\mathbf{x}) = -x_{w-1}2^{w-1} - \sum\limits_{i=0}^{w-2} x_i 2^i$$

可以证明当 $0\leq x \leq 2^w-1$时，无符号数编码是唯一的，
当 $\text{TMin}_w = -2^{w-1} \leq x \leq 2^{w-1}-1 = \text{TMax}_w$时，补码编码是唯一的。

关于这些数字，有几点值得注意：
1. 补码的范围是不对称的，即 `|TMin| = |TMax| + 1`，
2. 最大的无符号数刚好比补码的最大数的两倍大1，即`UMax = 2TMax +1`，
3. -1和 UMax 有同样的位表示，即一个全1的串。

#### 有符号数和无符号数的转换

1. 对于满足$\text{TMin}_w \leq x \leq \text{TMax}_w$的$x$有，

$$\text{T2U}_w(x) = \begin{cases}
    x+2^w ,\quad &x < 0 \\
    x,\quad &x \geq 0    
\end{cases}
$$

2. 对于满足$0 \leq u \leq \text{UMax}_w$的$u$有，

$$\text{U2T}_w(u) = \begin{cases}
    u-2^w ,\quad & u > \text{TMax}_w \\
    u,\quad & u \leq \text{TMax}_w   
\end{cases}
$$

当$u>\text{TMax}_w$时，$u$的最高位有效数字为1，转化为补码表示就相当于最高位权重从+1变为-1，因此少了$2^w$，反之同理，越靠近0的负数映射为越大的无符号数。

另外，可以证明U2T和T2U两个函数都是双射，两个函数的行为如下图所示：
<div align="center"> <img src="/pic/U2T_T2U.png" width = 500/> </div>

在C语言中允许两者之间相互转换，主要有四种情况：
1. 显示的强制类型转换就会导致转换发生，例如
    ```C
    int tx; 
    unsigned ux; 
    tx = (int)ux;
    ```
2. 一种类型的表达式被赋值给另外一种类型的变量，例如
    ```C
    tx = ux;
    ```
3. 当用printf输出数值时，分别用`%d`,`%u`和`%x%表示有符号十进制、无符号十进制和十六进制格式输出一个数字，例如
    ```C
    int x = -1;
    printf("x = %u = %d\n", x, x); \\ x = 4294967295 = -1.
    ```
4. **当执行一个两侧分别为有符号和无符号数的运算时，会隐式地将有符号数转换为无符号数**，例如
    1. `-1 < 0U`是错误的，
    2. `-1 > (unsigned)-2`是正确的，
    3. `2147483647 > (int)2147483648U`是正确的。

在C头文件`limit.h`中是这样定义TMin和TMax的：
```C
#define INT_MAX 2147483647
#define INT_MIN (-INT_MAX - 1)
```
因为在某些编译器中可能会把-2147482648认为是正数，这里不深究，了解即可。

#### 扩展一个数字的位表示

1. 宽度为$w$的位向量 $\mathbf{u} = [u_{w-1},\ldots,u_0]$ 扩展到$w'$位的$\mathbf{u}' = [0,\ldots,0,u_{w-1},\ldots,u_0]$，则有
$$\text{B2U}_w(\mathbf{u}) == \text{B2U}_{w'}(\mathbf{u}')$$

2. 宽度为$w$的位向量 $\mathbf{x} = [x_{w-1},\ldots,x_0]$ 扩展到$w'$位的$\mathbf{x}' = [x_{w-1},\ldots,x_{w-1},x_{w-1},\ldots,x_0]$，则有
$$\text{B2T}_w(\mathbf{x}) == \text{B2T}_{w'}(\mathbf{x}')$$

举个例子，有符号数`1001 -> -7`，扩展到8位时`11111001 -> -7`，因为 $$-2^{p+k}+2^{p+k-1}+\ldots+2^p = -2^p.$$

值得注意的是，从一个数据大小到另一个数据大小的转换，以及无符号和有符号之间的转换的相对顺序能够影响一个程序的行为，例如
```C
short sx = -12345;
unsigned uy = sx; /* Mystery! */
printf("uy = %u:\t", uy);
show_bytes( (byte_pointer)&uy, sizeof(unsigned));
\\ uy = 4294954951: ff ff cf c7.
```
这表明**当short转换成unsigned时，我们先要改变大小，然后再完成有符号到无符号的转换**，即`(unsigned)sx`等价于`(unsigned)(int)sx`而不是`(unsigned)(unsigned short)sx`。

#### 截断数字

截断一个数字可能会改变它的值，这也是溢出的一种形式。

1. 令 $\mathbf{x} = [x_{w-1},\ldots,x_0]$，将其阶段为k位有$\mathbf{x}' = [x_{k-1},\ldots,x_0]$, 
   记$x=\text{B2U}_w(\mathbf{x}), x' = \text{B2U}_{k}(\mathbf{x}')$，则有 $x' = x\mod\ 2^k$.

2. 令 $\mathbf{x} = [x_{w-1},\ldots,x_0]$，将其阶段为k位有$\mathbf{x}' = [x_{k-1},\ldots,x_0]$, 
   记$x=\text{B2U}_w(\mathbf{x}), x' = \text{B2T}_{k}(\mathbf{x}')$，则有 $x' = \text{U2T}_k(x\mod\ 2^k)$.

其实**两个操作在位级别上是相同的，只是最后按照不同编码表示而已**。

### 整数运算

#### 整数加法

1. 对于满足$0\leq x,y < 2^w$的整数$x,\ y$ 有:

$$ x+_w^u y = \begin{cases}
    x+y,\quad &x+y<2^w\quad &\text{正常} \\
    x+y - 2^w,\quad &2^w \leq x+y < 2^{w+1}\quad &\text{溢出}
\end{cases}$$

2. 对于满足 $-2^{w-1} \leq x,y \leq 2^{w-1}-1$的整数$x,\ y$，有:

$$x +_w^t y = \begin{cases}
    x + y - 2^w, \quad & 2^{w-1}\leq x+y \quad &\text{正溢出} \\
    x + y, \quad & -2^{w-1} \leq x+y < 2^{w-1} \quad &\text{正常} \\
    x + y + 2^w, \quad & x+y < -2^{w-1} \quad &\text{负溢出}
\end{cases}$$

负溢出的情况下截断后最高位有效数字必为0，否则就不会出现溢出了。

这里值得注意的是**补码加法与无符号数加法有相同的位级表示**，用数学语言表示就是

$$x +_w^t y = \text{U2T}_w(\text{T2U}_w(x) +_w^u \text{T2U}_w(y)) = \text{U2T}_w[(x+y) mod 2^w]$$

这样计算机就可以用同一个算法进行加法，之后的乘法也是如此。

另外，**模数加法形成了阿贝尔群**，它是可交换的并且可结合的，存在单位元0，并且每个元素有一个加法逆元（**位级操作上为取反后+1**）：
1. 对于满足$0\leq x< 2^w$的整数$x$ 有:

$$-_w^u x = \begin{cases}
    x, \quad & x=0 \\
    2^w-x, \quad & x>0
\end{cases}$$

2. 对于满足 $-2^{w-1} \leq x\leq 2^{w-1}-1$的整数$x$，有:

$$-_w^t x = \begin{cases}
    \text{TMin}_x, \quad & x = \text{TMin}_w \\
    -x, \quad & x > \text{TMin}_w
\end{cases}$$

判断是否出现溢出的方法如下:
1. 对于在范围$0\leq x,y \leq \text{UMax}_w$的 $x,\ y$, 令$s=x +_w^u y$，则计算发生溢出当且仅当$s<x$(或者等价地$s<y$)。

2. 对于在范围$\text{TMin}_w \leq x,y \leq \text{TMax}_w$的 $x,\ y$, 令$s=x +_w^t y$，则
   1. 发生正溢出当且仅当$x>0,y>0,s\leq 0$，
   2. 发生负溢出当且仅当$x<0,y<0,s\geq 0$.

对于补码而言，判断是否发生溢出的代码如下：

```C
int tadd_ok(int x, int y){
    int sum = x + y;
    int neg_over = x < 0 && y < 0 && sum >=0;
    int pos_over = x >= 0 && y >= 0 && sum < 0;
    return !neg_over && !pos_over;
}
```
注意以下写法是不对的：
```C
int tadd_ok(int x, int y){
    int sum = x + y;
    return (sum - x == y) && (sum -y == x);
}
```
因为模数加法构成阿贝尔群，$(x+y-x)$的结果永远都是$y$.

虽然我们现在可以判断加法是否溢出，我们是无法直接简单地通过加法来判断减法是否溢出的：
```C
int tsub_ok(int x, int y){
    return tadd_ok(x, -y);
}
```
当 $x>0,\ y = \text{TMin}_w$ 时，$-y = \text{TMin}_w$，此时一正一负判断为不溢出，然而实际是溢出的。

#### 整数乘法

1. 对于满足$0\leq x,y < 2^w$的整数$x,\ y$ 有:

$$ x *_w^u y = (x\cdot y)\ \text{mod}\ 2^w.$$

2. 对于满足 $-2^{w-1} \leq x,y \leq 2^{w-1}-1$的整数$x,\ y$，有:

$$ x *_w^t y = \text{U2T}_w((x\cdot y)\ \text{mod}\ 2^w).$$

无符号和补码乘法的位级操作是等价的，即给定长度为$w$的位向量$\mathbf{x}, \mathbf{y}$，用补码形式来定义整数$x,y$，用无符号形式来定义整数$x', y'$，则有

$$\text{T2B}_w(x *_w^t y) = \text{U2B}_w(x' *_w^u y').$$

检测整数乘法是否溢出的代码如下：
```C
int tmult_ok(int x, int y){
    // first way:
    int p = x * y;
    return !x || p/x == y;

    // second way:
    int64_t p = x*y;
    return p == (int)p;
}
```
证明思路如下：
1. $x$和$y$的乘积可以写作$x\cdot y = p + t2^w$, 计算溢出当且仅当$t\neq 0$.
2. $p$可以写作 $p = xq +r$，其中$|r| < |x|$.
3. 可证明 $q=y$当且仅当 $r=t=0$.

##### 乘以常数

1. C中变量x和k有无符号数$x$和$k$，且$0\leq k < w$，则有`x<<k`得到数值 $x *_w^u 2^k$.
2. C中变量x和k有补码值$x$和无符号数$k$，且$0\leq k < w$，则有`x<<k`得到数值 $x *_w^t 2^k$.

对于某个常数$K$，编译器会将$K$的二进制表达为一组01序列:$[(0\ldots 0)(1\ldots 1)(0\ldots 0)\ldots(1\ldots 1)]$，考虑一组从位置$n$到位置$m$的连续的1，我们可以用下面两种不同形式的一种来计算这些位对乘积的影响：
1. `(x<<n) + (x<<(n-1)) + ... + (x<<m)`
2. `(x<<(n+1)) - (x<<m)`

##### 除以2的幂

1. C中变量x和k有无符号数$x$和$k$，且$0\leq k < w$，则有`x>>k`得到数值 $\lfloor x/2^k \rfloor$.
2. C中变量x和k有补码值$x$和无符号数$k$，且$0\leq k < w$，则有`x>>k`得到数值 $\lfloor x/2^k \rfloor$.

然而对于负数而言，移位会导致结果向下舍入，但我们更希望向零舍入，此时我们利用**偏移(biasing)**的方法来进行修正：

C中变量x和k有补码值$x$和无符号数$k$，且$0\leq k < w$，则有`(x+ (1<<k) - 1) >> k`得到数值 $\lceil x/2^k \rceil$.

这里利用了性质：对于整数$x,y(y>0)$，有$\rceil x/y \rceil = \rfloor (x+y-1)/y \lfloor.$ 由此我们可以写出C语言计算$x/2^k$的代码
```C
(x < 0 ? x + (1<<k) - 1 : x) >> k
```

例题：写一个函数计算$x/16$:
```C
int bias = (x >> 31) & 0xF;
x = (x + bias) >> 4;
```
**注意这里利用了算术右移以及掩码的性质。**

#### 一些C语言Interger puzzles

1. $x<0 \nRightarrow(x*2)<0$
2. $ux \geq 0$
3. $x \& 7 == 7 \Rightarrow (x<<30)<0$
4. $ux > -1$是错的
5. $x>y \nRightarrow -x<-y$，注意TMin的情况
6. $x*x\geq 0$是错的
7. $x>0 \&\& y>0 \nRightarrow x+y > 0 $
8. $x\geq 0 \Rightarrow -x\leq 0$
9. $x\leq 0 \nRightarrow -x \geq 0$
10. $(x|-x)>>31 == -1$ 当$x\neq 0$的情况下成立
11. $ux>>3 == ux/8$
12. $x>>3 == x/8$ 当$x$为负数的时候不成立
13. $x\& (x-1)!=0$当$x==2^k$的时候不成立
14. $x+y == ux + uy$
15. $x * \sim y + uy*ux == -x$

