---
layout: post
title: Leetcode记录：滑动窗口和前缀和
date: 2024-7-31 14:00 +0800
tags: [数据结构与算法]
toc: true
---


## 滑动窗口
滑动窗口算法的基本思想是维护一个窗口，通过移动窗口的两个边界来处理问题。

具体来说，我们可以使用两个指针 `left` 和 `right` 分别表示滑动窗口的左右边界，然后通过不断移动右指针 `right` 来扩大窗口，同时根据问题的要求调整左指针 `left` 来缩小窗口。当右指针 `right` 扫描到字符串或数组的末尾时，算法的执行就完成了。

在扩大或缩小窗口的过程中，可以记录下一些中间结果，例如最大值、最小值、子串长度等等，从而求解问题的最终答案。

### 适用问题

滑动窗口算法可以用于解决一些字符串和数组问题，例如：
1. 字符串匹配问题，例如 Leetcode 第 28 题和第 76 题；
2. 最长子串或子数组问题，例如 Leetcode 第 3 题、第 209 题和第 424 题；
3. 最小覆盖子串问题，例如 Leetcode 第 76 题；
4. 字符串排列问题，例如 Leetcode 第 567 题；
5. 求解字符串或数组中的一些性质，例如 Leetcode 第 438 题、第 567 题和第 1004 题等。

### 实现方法
滑动窗口算法的实现方法相对简单，主要分为以下几个步骤：
1. 初始化左右指针 $left$ 和 $right$，并根据问题的要求进行一些初始化操作。
2. 不断移动右指针 $right$，直到出现不符合条件的情况，或者扫描到字符串或数组的末尾。
3. 对于每个右指针位置 $i$，更新一些中间结果。
4. 移动左指针 $left$，直到出现符合条件的情况，或者左右指针重合。
5. 重复第 2 步至第 4 步，直到右指针扫描到字符串或数组的末尾。

#### 示例1
Leetcode 206.【长度最小的子数组】
给定一个含有 `n` 个正整数的数组和一个正整数 `target` 。找出该数组中满足其总和大于等于 `target` 的长度最小的 子数组`[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

这道题之所以可以使用滑动窗口，很重要的一个原因是，**在移动终止位置的时候，初始位置是不可逆的，初始位置只可能往后移动，而不用每次都从第零个元素开始。** 代码实现如下：
```cpp
int minSubArrayLen(int s, vector<int>& nums) {
        int result = INT32_MAX;
        int sum = 0; // 滑动窗口数值之和
        int i = 0; // 滑动窗口起始位置
        int subLength = 0; // 滑动窗口的长度
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while (sum >= s) {
                subLength = (j - i + 1); // 取子序列的长度
                result = result < subLength ? result : subLength;
                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
        }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
```

#### 示例2

Leetcode 3.【无重复最长子串】
给定一个字符串 `s` ，请你找出其中不含有重复字符的最长子串的长度。


```cpp
int lengthOfLongestSubstring(string s) {
    int n = s.size();
    int ans = 0;
    unordered_map<char, int> map;//记录字符上一次出现的位置,字符为key，位置为value
    for(int i = 0, j = 0; j < n; j++){//i表示子串的起始位置，j表示子串的结束位置
        if(map.find(s[j]) != map.end()){//如果字符上一次出现的位置在i之后，更新i
            i = max(map[s[j]], i);//map[s[j]]表示字符s[j]上一次出现的位置
        }
        ans = max(ans, j - i + 1);//更新结果
        map[s[j]] = j + 1;		//更新字符s[j]上一次出现的位置
    }
    return ans;
}
```

#### 示例3
Leetcode 1004.【最大连续1的个数】

给定一个二进制数组 `nums` 和一个整数 `k`，如果可以翻转最多 `k` 个`0` ，则返回数组中连续 `1` 的最大个数。

```cpp
int longestOnes(vector<int>& nums, int k) {
    int n = nums.size();
    int left = 0, lsum = 0, rsum = 0;
    int ans = 0;
    for (int right = 0; right < n; ++right) {
        rsum += 1 - nums[right]; //[0，right]中0的个数.
        while (lsum < rsum - k) {
            lsum += 1 - nums[left];
            ++left;
        }
        ans = max(ans, right - left + 1);
    }
    return ans;
}
```

该问题也可以用前缀和思路来考虑：要想快速判断一个区间内 `0` 的个数，我们可以考虑将数组中的 `0` 变成 `1`，`1` 变成 `0`。此时，我们对数组 A 求出前缀和，记为数组 `P`，那么 `[left,right]` 中包含不超过 `k` 个 `1`（注意这里就不是 `0` 了），当且仅当二者的前缀和之差：`P[right]−P[left−1]<=k`.

```cpp
int longestOnes(vector<int>& nums, int k) {
    int n = nums.size();
    vector<int> P(n + 1);
    for (int i = 1; i <= n; ++i) {
        P[i] = P[i - 1] + (1 - nums[i - 1]);
    }

    int ans = 0;
    for (int right = 0; right < n; ++right) {
        int left = lower_bound(P.begin(), P.end(), P[right + 1] - k) - P.begin();
        ans = max(ans, right - left + 1);
    }
    return ans;
    }
```
其中 `lower_bound` 用于在有序序列中查找第一个大于或等于给定值的元素的位置（迭代器）。

#### 904，76待做


## 前缀和

前缀和算法（Prefix Sum）是一种用于快速计算数组元素之和的技术。它通过预先计算数组中每个位置前所有元素的累加和，将这些部分和存储在一个新的数组中，从而在需要计算某个区间的和时，可以通过简单的减法操作得到结果，而不必重新遍历整个区间。

一维前缀和：给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。

```cpp
int main() {
    int n, a, b;
    cin >> n;
    vector<int> vec(n);
    vector<int> p(n);
    int presum = 0;
    for (int i = 0; i < n; i++) {
        cin >> vec[i];
        presum += vec[i];
        p[i] = presum;
    }

    while (cin >> a >> b) {
        int sum;
        if (a == 0) sum = p[b];
        else sum = p[b] - p[a - 1];
        cout << sum << endl;
    }
}
```

二维前缀和：给你一个n行m列的矩阵A ，下标从1开始。请输出以 (x1, y1) 为左上角 , (x2,y2) 为右下角的子矩阵的和。

```cpp
int main() 
{
    int n = 0, m = 0
    cin >> n >> m;
    vector<vector<int>> arr(n + 1, vector<int>(m + 1));
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            cin >> arr[i][j];
 
    vector<vector<long long>> dp(n + 1, vector<long long>(m + 1));
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            dp[i][j] = dp[i-1][j] + dp[i][j-1] + arr[i][j] - dp[i-1][j-1]; //注意这一步.
 
    int x1 = 0, y1 = 0, x2 = 0, y2 = 0;
    while (cin >> x1 >> y1 >> x2 >> y2;)
    {
        cout << dp[x2][y2] - dp[x1-1][y2] - dp[x2][y1-1] + dp[x1-1][y1-1] << endl;
    }
 
    return 0;
}
```

<div align="center"> <img src="/pic/DS/2DPrefix_Sum.png" width = 800/> </div>

#### 示例1

Leetcode 238.【除自身以外数组的乘积】
给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积。

```cpp
vector<int> productExceptSelf(vector<int>& nums) {
    int length = nums.size();
    vector<int> answer(length);

    // answer[i] 表示索引 i 左侧所有元素的乘积
    // 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1
    answer[0] = 1;
    for (int i = 1; i < length; i++) {
        answer[i] = nums[i - 1] * answer[i - 1];
    }

    // R 为右侧所有元素的乘积
    // 刚开始右边没有元素，所以 R = 1
    int R = 1;
    for (int i = length - 1; i >= 0; i--) {
        // 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R
        answer[i] = answer[i] * R;
        // R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上
        R *= nums[i];
    }
    return answer;
}
```

#### 示例2
Leetcode 560.【和为k的子数组】
给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回该数组中和为 `k` 的子数组的个数。

```cpp
int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> mp;
        mp[0] = 1; //注意！
        int count = 0, pre = 0;
        for (auto& x:nums) {
            pre += x;
            if (mp.find(pre - k) != mp.end()) {
                count += mp[pre - k];
            }
            mp[pre]++;
        }
        return count;
    }
```
